
out/mg-stm32l_acquisition_supervisor.elf:     file format elf32-littlearm


Disassembly of section .text:

08000000 <__text_start>:
 8000000:	20000d80 	.word	0x20000d80
 8000004:	08000149 	.word	0x08000149
 8000008:	08000209 	.word	0x08000209
 800000c:	08000209 	.word	0x08000209
 8000010:	08000209 	.word	0x08000209
 8000014:	08000209 	.word	0x08000209
 8000018:	08000209 	.word	0x08000209
 800001c:	08000209 	.word	0x08000209
 8000020:	08000209 	.word	0x08000209
 8000024:	08000209 	.word	0x08000209
 8000028:	08000209 	.word	0x08000209
 800002c:	080005cd 	.word	0x080005cd
 8000030:	08000209 	.word	0x08000209
 8000034:	08000209 	.word	0x08000209
 8000038:	0800062d 	.word	0x0800062d
 800003c:	08000669 	.word	0x08000669
 8000040:	08000209 	.word	0x08000209
 8000044:	08000209 	.word	0x08000209
 8000048:	08000209 	.word	0x08000209
 800004c:	08000209 	.word	0x08000209
 8000050:	08000209 	.word	0x08000209
 8000054:	08000209 	.word	0x08000209
 8000058:	08000209 	.word	0x08000209
 800005c:	08000209 	.word	0x08000209
 8000060:	08000209 	.word	0x08000209
 8000064:	08000209 	.word	0x08000209
 8000068:	08000209 	.word	0x08000209
 800006c:	08000209 	.word	0x08000209
 8000070:	08000209 	.word	0x08000209
 8000074:	08000209 	.word	0x08000209
 8000078:	08000a05 	.word	0x08000a05
 800007c:	08000209 	.word	0x08000209
 8000080:	08000209 	.word	0x08000209
 8000084:	08000209 	.word	0x08000209
 8000088:	08000209 	.word	0x08000209
 800008c:	08000209 	.word	0x08000209
 8000090:	08000209 	.word	0x08000209
 8000094:	08000209 	.word	0x08000209
 8000098:	08000209 	.word	0x08000209
 800009c:	08000209 	.word	0x08000209
 80000a0:	08000209 	.word	0x08000209
 80000a4:	08000209 	.word	0x08000209
 80000a8:	08000209 	.word	0x08000209
 80000ac:	08000209 	.word	0x08000209
 80000b0:	08000209 	.word	0x08000209
 80000b4:	08000209 	.word	0x08000209
 80000b8:	08000209 	.word	0x08000209
 80000bc:	08000209 	.word	0x08000209
 80000c0:	08000209 	.word	0x08000209
 80000c4:	08000209 	.word	0x08000209
 80000c8:	08000209 	.word	0x08000209
 80000cc:	08000209 	.word	0x08000209
 80000d0:	08000209 	.word	0x08000209
 80000d4:	08000a41 	.word	0x08000a41
 80000d8:	08000209 	.word	0x08000209
 80000dc:	08000209 	.word	0x08000209
 80000e0:	08000209 	.word	0x08000209
 80000e4:	08000209 	.word	0x08000209
 80000e8:	08000209 	.word	0x08000209
 80000ec:	08000891 	.word	0x08000891
 80000f0:	08000209 	.word	0x08000209

080000f4 <__do_global_dtors_aux>:
 80000f4:	b510      	push	{r4, lr}
 80000f6:	4c05      	ldr	r4, [pc, #20]	; (800010c <__do_global_dtors_aux+0x18>)
 80000f8:	7823      	ldrb	r3, [r4, #0]
 80000fa:	b933      	cbnz	r3, 800010a <__do_global_dtors_aux+0x16>
 80000fc:	4804      	ldr	r0, [pc, #16]	; (8000110 <__do_global_dtors_aux+0x1c>)
 80000fe:	b110      	cbz	r0, 8000106 <__do_global_dtors_aux+0x12>
 8000100:	4804      	ldr	r0, [pc, #16]	; (8000114 <__do_global_dtors_aux+0x20>)
 8000102:	f3af 8000 	nop.w
 8000106:	2101      	movs	r1, #1
 8000108:	7021      	strb	r1, [r4, #0]
 800010a:	bd10      	pop	{r4, pc}
 800010c:	20000854 	.word	0x20000854
 8000110:	00000000 	.word	0x00000000
 8000114:	08001644 	.word	0x08001644

08000118 <frame_dummy>:
 8000118:	b508      	push	{r3, lr}
 800011a:	4b06      	ldr	r3, [pc, #24]	; (8000134 <frame_dummy+0x1c>)
 800011c:	b11b      	cbz	r3, 8000126 <frame_dummy+0xe>
 800011e:	4806      	ldr	r0, [pc, #24]	; (8000138 <frame_dummy+0x20>)
 8000120:	4906      	ldr	r1, [pc, #24]	; (800013c <frame_dummy+0x24>)
 8000122:	f3af 8000 	nop.w
 8000126:	4806      	ldr	r0, [pc, #24]	; (8000140 <frame_dummy+0x28>)
 8000128:	6801      	ldr	r1, [r0, #0]
 800012a:	b111      	cbz	r1, 8000132 <frame_dummy+0x1a>
 800012c:	4a05      	ldr	r2, [pc, #20]	; (8000144 <frame_dummy+0x2c>)
 800012e:	b102      	cbz	r2, 8000132 <frame_dummy+0x1a>
 8000130:	4790      	blx	r2
 8000132:	bd08      	pop	{r3, pc}
 8000134:	00000000 	.word	0x00000000
 8000138:	08001644 	.word	0x08001644
 800013c:	20000858 	.word	0x20000858
 8000140:	20000854 	.word	0x20000854
 8000144:	00000000 	.word	0x00000000

08000148 <Reset_Handler>:

Reset_Handler:

// Initialize the process stack pointer

	ldr		r0, =__process_stack_end
 8000148:	481b      	ldr	r0, [pc, #108]	; (80001b8 <__default_low_level_init+0x4>)
	msr		PSP, r0
 800014a:	f380 8809 	msr	PSP, r0

// Thread mode uses process stack (PSP) and is privileged

	movs	r0, #CONTROL_ALTERNATE_STACK
 800014e:	2002      	movs	r0, #2
	msr		CONTROL, r0
 8000150:	f380 8814 	msr	CONTROL, r0
	isb
 8000154:	f3bf 8f6f 	isb	sy

// Branch to low_level_init_0() function (.data and .bss are not initialized!)

	ldr		r0, =low_level_init_0
 8000158:	4818      	ldr	r0, [pc, #96]	; (80001bc <__default_low_level_init+0x8>)
	blx		r0
 800015a:	4780      	blx	r0

// Initialize sections from data_array (including .data)

	ldr		r4, =__data_array_start
 800015c:	4c18      	ldr	r4, [pc, #96]	; (80001c0 <__default_low_level_init+0xc>)
	ldr		r5, =__data_array_end
 800015e:	4d19      	ldr	r5, [pc, #100]	; (80001c4 <__default_low_level_init+0x10>)

1:	cmp		r4, r5							// outer loop - addresses from data_array
 8000160:	42ac      	cmp	r4, r5
	ittte	lo
 8000162:	bf3d      	ittte	cc
	ldrlo	r1, [r4], #4					// start of source address
 8000164:	f854 1b04 	ldrcc.w	r1, [r4], #4
	ldrlo	r2, [r4], #4					// start of destination address
 8000168:	f854 2b04 	ldrcc.w	r2, [r4], #4
	ldrlo	r3, [r4], #4					// end of destination address
 800016c:	f854 3b04 	ldrcc.w	r3, [r4], #4
	bhs		3f
 8000170:	e007      	bcs.n	8000182 <Reset_Handler+0x3a>

2:	cmp		r2, r3							// inner loop - section initialization
 8000172:	429a      	cmp	r2, r3
	ittt	lo
 8000174:	bf3e      	ittt	cc
	ldrlo	r0, [r1], #4
 8000176:	f851 0b04 	ldrcc.w	r0, [r1], #4
	strlo	r0, [r2], #4
 800017a:	f842 0b04 	strcc.w	r0, [r2], #4
	blo		2b
 800017e:	e7f8      	bcc.n	8000172 <Reset_Handler+0x2a>

	b		1b								// go back to start
 8000180:	e7ee      	b.n	8000160 <Reset_Handler+0x18>

3:

// Zero-init sections from bss_array (including .bss)

	movs	r0, #0
 8000182:	2000      	movs	r0, #0
	ldr		r3, =__bss_array_start
 8000184:	4b10      	ldr	r3, [pc, #64]	; (80001c8 <__default_low_level_init+0x14>)
	ldr		r4, =__bss_array_end
 8000186:	4c11      	ldr	r4, [pc, #68]	; (80001cc <__default_low_level_init+0x18>)

1:	cmp		r3, r4							// outer loop - addresses from data_array
 8000188:	42a3      	cmp	r3, r4
	itte	lo
 800018a:	bf3a      	itte	cc
	ldrlo	r1, [r3], #4					// start of destination address
 800018c:	f853 1b04 	ldrcc.w	r1, [r3], #4
	ldrlo	r2, [r3], #4					// end of destination address
 8000190:	f853 2b04 	ldrcc.w	r2, [r3], #4
	bhs		3f
 8000194:	e005      	bcs.n	80001a2 <Reset_Handler+0x5a>

2:	cmp		r1, r2							// inner loop - section initialization
 8000196:	4291      	cmp	r1, r2
	itt		lo
 8000198:	bf3c      	itt	cc
	strlo	r0, [r1], #4
 800019a:	f841 0b04 	strcc.w	r0, [r1], #4
	blo		2b
 800019e:	e7fa      	bcc.n	8000196 <Reset_Handler+0x4e>

	b		1b								// go back to start
 80001a0:	e7f2      	b.n	8000188 <Reset_Handler+0x40>
3:

// Call C++ constructors for global and static objects

#ifdef __USES_CXX
	ldr		r0, =__libc_init_array
 80001a2:	480b      	ldr	r0, [pc, #44]	; (80001d0 <__default_low_level_init+0x1c>)
	blx		r0
 80001a4:	4780      	blx	r0
#endif

// Branch to low_level_init_1() function

	ldr		r0, =low_level_init_1
 80001a6:	480b      	ldr	r0, [pc, #44]	; (80001d4 <__default_low_level_init+0x20>)
	blx		r0
 80001a8:	4780      	blx	r0

// Branch to main() with link

	ldr		r0, =main
 80001aa:	480b      	ldr	r0, [pc, #44]	; (80001d8 <__default_low_level_init+0x24>)
	blx		r0
 80001ac:	4780      	blx	r0

// Call C++ destructors for global and static objects

#ifdef __USES_CXX
	ldr		r0, =__libc_fini_array
 80001ae:	480b      	ldr	r0, [pc, #44]	; (80001dc <__default_low_level_init+0x28>)
	blx		r0
 80001b0:	4780      	blx	r0
#endif

// On return - loop till the end of the world

	b		.
 80001b2:	e7fe      	b.n	80001b2 <Reset_Handler+0x6a>

080001b4 <__default_low_level_init>:
.thumb
.thumb_func
.global __default_low_level_init

__default_low_level_init:
	bx		lr
 80001b4:	4770      	bx	lr
 80001b6:	0000      	.short	0x0000

Reset_Handler:

// Initialize the process stack pointer

	ldr		r0, =__process_stack_end
 80001b8:	20001180 	.word	0x20001180
	msr		CONTROL, r0
	isb

// Branch to low_level_init_0() function (.data and .bss are not initialized!)

	ldr		r0, =low_level_init_0
 80001bc:	080001b5 	.word	0x080001b5
	blx		r0

// Initialize sections from data_array (including .data)

	ldr		r4, =__data_array_start
 80001c0:	08001644 	.word	0x08001644
	ldr		r5, =__data_array_end
 80001c4:	08001650 	.word	0x08001650
3:

// Zero-init sections from bss_array (including .bss)

	movs	r0, #0
	ldr		r3, =__bss_array_start
 80001c8:	08001650 	.word	0x08001650
	ldr		r4, =__bss_array_end
 80001cc:	08001658 	.word	0x08001658
3:

// Call C++ constructors for global and static objects

#ifdef __USES_CXX
	ldr		r0, =__libc_init_array
 80001d0:	08000bf9 	.word	0x08000bf9
	blx		r0
#endif

// Branch to low_level_init_1() function

	ldr		r0, =low_level_init_1
 80001d4:	080001b5 	.word	0x080001b5
	blx		r0

// Branch to main() with link

	ldr		r0, =main
 80001d8:	080006c1 	.word	0x080006c1
	blx		r0

// Call C++ destructors for global and static objects

#ifdef __USES_CXX
	ldr		r0, =__libc_fini_array
 80001dc:	08000ba9 	.word	0x08000ba9

080001e0 <_sbrk_r>:
	static char *current_heap_end = &__heap_start;
	char *previous_heap_end;

	(void)r;								// suppress warning

	previous_heap_end = current_heap_end;
 80001e0:	4b06      	ldr	r3, [pc, #24]	; (80001fc <_sbrk_r+0x1c>)

	if (current_heap_end + size > &__heap_end)	// is there enough space on the heap left?
 80001e2:	4a07      	ldr	r2, [pc, #28]	; (8000200 <_sbrk_r+0x20>)
	static char *current_heap_end = &__heap_start;
	char *previous_heap_end;

	(void)r;								// suppress warning

	previous_heap_end = current_heap_end;
 80001e4:	6818      	ldr	r0, [r3, #0]

	if (current_heap_end + size > &__heap_end)	// is there enough space on the heap left?
 80001e6:	1841      	adds	r1, r0, r1
 80001e8:	4291      	cmp	r1, r2
 80001ea:	d905      	bls.n	80001f8 <_sbrk_r+0x18>
	{
		errno = ENOMEM;						// not enough memory left
 80001ec:	4b05      	ldr	r3, [pc, #20]	; (8000204 <_sbrk_r+0x24>)
 80001ee:	200c      	movs	r0, #12
 80001f0:	6018      	str	r0, [r3, #0]
		return (caddr_t) -1;				// return immediatelly
 80001f2:	f04f 30ff 	mov.w	r0, #4294967295
 80001f6:	4770      	bx	lr
	}

	current_heap_end += size;				// increase data space
 80001f8:	6019      	str	r1, [r3, #0]

	return (caddr_t)previous_heap_end;		// return requested data space
}
 80001fa:	4770      	bx	lr
 80001fc:	20000004 	.word	0x20000004
 8000200:	20004000 	.word	0x20004000
 8000204:	20000978 	.word	0x20000978

08000208 <__Default_Handler>:
 * own handler defined.
*/

void __Default_Handler(void) __attribute__ ((interrupt));
void __Default_Handler(void)
{
 8000208:	4668      	mov	r0, sp
 800020a:	f020 0107 	bic.w	r1, r0, #7
 800020e:	468d      	mov	sp, r1
 8000210:	e7fe      	b.n	8000210 <__Default_Handler+0x8>

08000212 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 8000212:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex->pxNext;
 8000214:	685a      	ldr	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
 8000216:	608b      	str	r3, [r1, #8]
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;

	pxNewListItem->pxNext = pxIndex->pxNext;
 8000218:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 800021a:	685a      	ldr	r2, [r3, #4]
 800021c:	6091      	str	r1, [r2, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 800021e:	6059      	str	r1, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 8000220:	6041      	str	r1, [r0, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8000222:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8000224:	6801      	ldr	r1, [r0, #0]
 8000226:	1c4b      	adds	r3, r1, #1
 8000228:	6003      	str	r3, [r0, #0]
 800022a:	4770      	bx	lr

0800022c <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800022c:	6843      	ldr	r3, [r0, #4]
 800022e:	6882      	ldr	r2, [r0, #8]
 8000230:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8000232:	6882      	ldr	r2, [r0, #8]
 8000234:	6053      	str	r3, [r2, #4]
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 8000236:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8000238:	6859      	ldr	r1, [r3, #4]
 800023a:	4281      	cmp	r1, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 800023c:	bf08      	it	eq
 800023e:	605a      	streq	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
 8000240:	2200      	movs	r2, #0
 8000242:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8000244:	6818      	ldr	r0, [r3, #0]
 8000246:	1e41      	subs	r1, r0, #1
 8000248:	6019      	str	r1, [r3, #0]
 800024a:	4770      	bx	lr

0800024c <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
 800024c:	b538      	push	{r3, r4, r5, lr}
 800024e:	4613      	mov	r3, r2
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 8000250:	6c02      	ldr	r2, [r0, #64]	; 0x40

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
 8000252:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 8000254:	b932      	cbnz	r2, 8000264 <prvCopyDataToQueue+0x18>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8000256:	6805      	ldr	r5, [r0, #0]
 8000258:	bb05      	cbnz	r5, 800029c <prvCopyDataToQueue+0x50>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 800025a:	6840      	ldr	r0, [r0, #4]
 800025c:	f000 f992 	bl	8000584 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 8000260:	6065      	str	r5, [r4, #4]
 8000262:	e01b      	b.n	800029c <prvCopyDataToQueue+0x50>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
 8000264:	b963      	cbnz	r3, 8000280 <prvCopyDataToQueue+0x34>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 8000266:	6880      	ldr	r0, [r0, #8]
 8000268:	f000 ffb8 	bl	80011dc <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800026c:	68a0      	ldr	r0, [r4, #8]
 800026e:	6c21      	ldr	r1, [r4, #64]	; 0x40
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 8000270:	6862      	ldr	r2, [r4, #4]
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8000272:	1843      	adds	r3, r0, r1
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 8000274:	4293      	cmp	r3, r2
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8000276:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 8000278:	d310      	bcc.n	800029c <prvCopyDataToQueue+0x50>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 800027a:	6820      	ldr	r0, [r4, #0]
 800027c:	60a0      	str	r0, [r4, #8]
 800027e:	e00d      	b.n	800029c <prvCopyDataToQueue+0x50>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 8000280:	68c0      	ldr	r0, [r0, #12]
 8000282:	f000 ffab 	bl	80011dc <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 8000286:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8000288:	68e2      	ldr	r2, [r4, #12]
 800028a:	4243      	negs	r3, r0
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 800028c:	6821      	ldr	r1, [r4, #0]
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 800028e:	18d0      	adds	r0, r2, r3
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 8000290:	4288      	cmp	r0, r1
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 8000292:	60e0      	str	r0, [r4, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 8000294:	d202      	bcs.n	800029c <prvCopyDataToQueue+0x50>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8000296:	6862      	ldr	r2, [r4, #4]
 8000298:	18d3      	adds	r3, r2, r3
 800029a:	60e3      	str	r3, [r4, #12]
		}
	}

	++( pxQueue->uxMessagesWaiting );
 800029c:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800029e:	1c4b      	adds	r3, r1, #1
 80002a0:	63a3      	str	r3, [r4, #56]	; 0x38
 80002a2:	bd38      	pop	{r3, r4, r5, pc}

080002a4 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
 80002a4:	b538      	push	{r3, r4, r5, lr}
 80002a6:	4604      	mov	r4, r0
 80002a8:	4615      	mov	r5, r2
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80002aa:	f04f 0050 	mov.w	r0, #80	; 0x50
 80002ae:	f380 8811 	msr	BASEPRI, r0
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 80002b2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80002b4:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 80002b6:	4282      	cmp	r2, r0
 80002b8:	d216      	bcs.n	80002e8 <xQueueGenericSendFromISR+0x44>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80002ba:	461a      	mov	r2, r3
 80002bc:	4620      	mov	r0, r4
 80002be:	f7ff ffc5 	bl	800024c <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
 80002c2:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 80002c4:	1c4b      	adds	r3, r1, #1
 80002c6:	d10a      	bne.n	80002de <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80002c8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80002ca:	b15b      	cbz	r3, 80002e4 <xQueueGenericSendFromISR+0x40>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80002cc:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80002d0:	f000 f926 	bl	8000520 <xTaskRemoveFromEventList>
 80002d4:	b130      	cbz	r0, 80002e4 <xQueueGenericSendFromISR+0x40>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
 80002d6:	b12d      	cbz	r5, 80002e4 <xQueueGenericSendFromISR+0x40>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
 80002d8:	2301      	movs	r3, #1
 80002da:	602b      	str	r3, [r5, #0]
 80002dc:	e005      	b.n	80002ea <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
 80002de:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 80002e0:	1c50      	adds	r0, r2, #1
 80002e2:	64a0      	str	r0, [r4, #72]	; 0x48
			}

			xReturn = pdPASS;
 80002e4:	2301      	movs	r3, #1
 80002e6:	e000      	b.n	80002ea <xQueueGenericSendFromISR+0x46>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 80002e8:	2300      	movs	r3, #0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 80002ea:	f04f 0000 	mov.w	r0, #0
 80002ee:	f380 8811 	msr	BASEPRI, r0

	return xReturn;
}
 80002f2:	4618      	mov	r0, r3
 80002f4:	bd38      	pop	{r3, r4, r5, pc}
	...

080002f8 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
 80002f8:	4b02      	ldr	r3, [pc, #8]	; (8000304 <vTaskSuspendAll+0xc>)
 80002fa:	681a      	ldr	r2, [r3, #0]
 80002fc:	1c50      	adds	r0, r2, #1
 80002fe:	6018      	str	r0, [r3, #0]
 8000300:	4770      	bx	lr
 8000302:	bf00      	nop
 8000304:	20000908 	.word	0x20000908

08000308 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
 8000308:	b538      	push	{r3, r4, r5, lr}
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 800030a:	4b2b      	ldr	r3, [pc, #172]	; (80003b8 <vTaskIncrementTick+0xb0>)
 800030c:	6818      	ldr	r0, [r3, #0]
 800030e:	2800      	cmp	r0, #0
 8000310:	d14c      	bne.n	80003ac <vTaskIncrementTick+0xa4>
	{
		++xTickCount;
 8000312:	482a      	ldr	r0, [pc, #168]	; (80003bc <vTaskIncrementTick+0xb4>)
 8000314:	6801      	ldr	r1, [r0, #0]
 8000316:	1c4a      	adds	r2, r1, #1
 8000318:	6002      	str	r2, [r0, #0]
		if( xTickCount == ( portTickType ) 0U )
 800031a:	6803      	ldr	r3, [r0, #0]
 800031c:	b9ab      	cbnz	r3, 800034a <vTaskIncrementTick+0x42>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
 800031e:	4b28      	ldr	r3, [pc, #160]	; (80003c0 <vTaskIncrementTick+0xb8>)
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 8000320:	4a28      	ldr	r2, [pc, #160]	; (80003c4 <vTaskIncrementTick+0xbc>)
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
 8000322:	6819      	ldr	r1, [r3, #0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 8000324:	6810      	ldr	r0, [r2, #0]
 8000326:	6018      	str	r0, [r3, #0]
			pxOverflowDelayedTaskList = pxTemp;
 8000328:	6011      	str	r1, [r2, #0]
			xNumOfOverflows++;
 800032a:	4a27      	ldr	r2, [pc, #156]	; (80003c8 <vTaskIncrementTick+0xc0>)
 800032c:	6811      	ldr	r1, [r2, #0]
 800032e:	1c48      	adds	r0, r1, #1
 8000330:	6010      	str	r0, [r2, #0]
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8000332:	681a      	ldr	r2, [r3, #0]
 8000334:	4825      	ldr	r0, [pc, #148]	; (80003cc <vTaskIncrementTick+0xc4>)
 8000336:	6811      	ldr	r1, [r2, #0]
 8000338:	b911      	cbnz	r1, 8000340 <vTaskIncrementTick+0x38>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
 800033a:	f04f 33ff 	mov.w	r3, #4294967295
 800033e:	e003      	b.n	8000348 <vTaskIncrementTick+0x40>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8000340:	681b      	ldr	r3, [r3, #0]
 8000342:	68da      	ldr	r2, [r3, #12]
 8000344:	68d1      	ldr	r1, [r2, #12]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 8000346:	684b      	ldr	r3, [r1, #4]
 8000348:	6003      	str	r3, [r0, #0]
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
 800034a:	481c      	ldr	r0, [pc, #112]	; (80003bc <vTaskIncrementTick+0xb4>)
 800034c:	491f      	ldr	r1, [pc, #124]	; (80003cc <vTaskIncrementTick+0xc4>)
 800034e:	6802      	ldr	r2, [r0, #0]
 8000350:	680b      	ldr	r3, [r1, #0]
 8000352:	429a      	cmp	r2, r3
 8000354:	d32e      	bcc.n	80003b4 <vTaskIncrementTick+0xac>
 8000356:	481a      	ldr	r0, [pc, #104]	; (80003c0 <vTaskIncrementTick+0xb8>)
 8000358:	6802      	ldr	r2, [r0, #0]
 800035a:	6811      	ldr	r1, [r2, #0]
 800035c:	b919      	cbnz	r1, 8000366 <vTaskIncrementTick+0x5e>
 800035e:	f04f 33ff 	mov.w	r3, #4294967295
 8000362:	491a      	ldr	r1, [pc, #104]	; (80003cc <vTaskIncrementTick+0xc4>)
 8000364:	e025      	b.n	80003b2 <vTaskIncrementTick+0xaa>
 8000366:	6804      	ldr	r4, [r0, #0]
 8000368:	4a14      	ldr	r2, [pc, #80]	; (80003bc <vTaskIncrementTick+0xb4>)
 800036a:	68e3      	ldr	r3, [r4, #12]
 800036c:	68dc      	ldr	r4, [r3, #12]
 800036e:	6811      	ldr	r1, [r2, #0]
 8000370:	6860      	ldr	r0, [r4, #4]
 8000372:	4281      	cmp	r1, r0
 8000374:	d202      	bcs.n	800037c <vTaskIncrementTick+0x74>
 8000376:	4b15      	ldr	r3, [pc, #84]	; (80003cc <vTaskIncrementTick+0xc4>)
 8000378:	6018      	str	r0, [r3, #0]
 800037a:	bd38      	pop	{r3, r4, r5, pc}
 800037c:	1d25      	adds	r5, r4, #4
 800037e:	4628      	mov	r0, r5
 8000380:	f7ff ff54 	bl	800022c <vListRemove>
 8000384:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8000386:	b11b      	cbz	r3, 8000390 <vTaskIncrementTick+0x88>
 8000388:	f104 0018 	add.w	r0, r4, #24
 800038c:	f7ff ff4e 	bl	800022c <vListRemove>
 8000390:	480f      	ldr	r0, [pc, #60]	; (80003d0 <vTaskIncrementTick+0xc8>)
 8000392:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8000394:	6802      	ldr	r2, [r0, #0]
 8000396:	4293      	cmp	r3, r2
 8000398:	bf88      	it	hi
 800039a:	6003      	strhi	r3, [r0, #0]
 800039c:	480d      	ldr	r0, [pc, #52]	; (80003d4 <vTaskIncrementTick+0xcc>)
 800039e:	2114      	movs	r1, #20
 80003a0:	fb01 0003 	mla	r0, r1, r3, r0
 80003a4:	4629      	mov	r1, r5
 80003a6:	f7ff ff34 	bl	8000212 <vListInsertEnd>
 80003aa:	e7d4      	b.n	8000356 <vTaskIncrementTick+0x4e>
	}
	else
	{
		++uxMissedTicks;
 80003ac:	490a      	ldr	r1, [pc, #40]	; (80003d8 <vTaskIncrementTick+0xd0>)
 80003ae:	680a      	ldr	r2, [r1, #0]
 80003b0:	1c53      	adds	r3, r2, #1
 80003b2:	600b      	str	r3, [r1, #0]
 80003b4:	bd38      	pop	{r3, r4, r5, pc}
 80003b6:	bf00      	nop
 80003b8:	20000908 	.word	0x20000908
 80003bc:	20000874 	.word	0x20000874
 80003c0:	200008e0 	.word	0x200008e0
 80003c4:	200008dc 	.word	0x200008dc
 80003c8:	20000910 	.word	0x20000910
 80003cc:	20000008 	.word	0x20000008
 80003d0:	20000870 	.word	0x20000870
 80003d4:	20000878 	.word	0x20000878
 80003d8:	2000090c 	.word	0x2000090c

080003dc <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 80003dc:	b570      	push	{r4, r5, r6, lr}
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 80003de:	f000 f90d 	bl	80005fc <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 80003e2:	4b26      	ldr	r3, [pc, #152]	; (800047c <xTaskResumeAll+0xa0>)
 80003e4:	681a      	ldr	r2, [r3, #0]
 80003e6:	1e50      	subs	r0, r2, #1
 80003e8:	6018      	str	r0, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 80003ea:	681d      	ldr	r5, [r3, #0]
 80003ec:	b10d      	cbz	r5, 80003f2 <xTaskResumeAll+0x16>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 80003ee:	2400      	movs	r4, #0
 80003f0:	e03f      	b.n	8000472 <xTaskResumeAll+0x96>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 80003f2:	4923      	ldr	r1, [pc, #140]	; (8000480 <xTaskResumeAll+0xa4>)
 80003f4:	680c      	ldr	r4, [r1, #0]
 80003f6:	2c00      	cmp	r4, #0
 80003f8:	d0f9      	beq.n	80003ee <xTaskResumeAll+0x12>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 80003fa:	4b22      	ldr	r3, [pc, #136]	; (8000484 <xTaskResumeAll+0xa8>)
 80003fc:	681a      	ldr	r2, [r3, #0]
 80003fe:	b1f2      	cbz	r2, 800043e <xTaskResumeAll+0x62>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 8000400:	68de      	ldr	r6, [r3, #12]
 8000402:	68f4      	ldr	r4, [r6, #12]
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
 8000404:	1d26      	adds	r6, r4, #4
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
 8000406:	f104 0018 	add.w	r0, r4, #24
 800040a:	f7ff ff0f 	bl	800022c <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
 800040e:	4630      	mov	r0, r6
 8000410:	f7ff ff0c 	bl	800022c <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 8000414:	481c      	ldr	r0, [pc, #112]	; (8000488 <xTaskResumeAll+0xac>)
 8000416:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8000418:	6801      	ldr	r1, [r0, #0]
 800041a:	4a1c      	ldr	r2, [pc, #112]	; (800048c <xTaskResumeAll+0xb0>)
 800041c:	428b      	cmp	r3, r1
 800041e:	bf88      	it	hi
 8000420:	6003      	strhi	r3, [r0, #0]
 8000422:	2014      	movs	r0, #20
 8000424:	fb00 2003 	mla	r0, r0, r3, r2
 8000428:	4631      	mov	r1, r6
 800042a:	f7ff fef2 	bl	8000212 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800042e:	4b18      	ldr	r3, [pc, #96]	; (8000490 <xTaskResumeAll+0xb4>)
 8000430:	6ae4      	ldr	r4, [r4, #44]	; 0x2c
 8000432:	6819      	ldr	r1, [r3, #0]
 8000434:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
					{
						xYieldRequired = pdTRUE;
 8000436:	4284      	cmp	r4, r0
 8000438:	bf28      	it	cs
 800043a:	2501      	movcs	r5, #1
 800043c:	e7dd      	b.n	80003fa <xTaskResumeAll+0x1e>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 800043e:	4815      	ldr	r0, [pc, #84]	; (8000494 <xTaskResumeAll+0xb8>)
 8000440:	6801      	ldr	r1, [r0, #0]
 8000442:	b141      	cbz	r1, 8000456 <xTaskResumeAll+0x7a>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 8000444:	4c13      	ldr	r4, [pc, #76]	; (8000494 <xTaskResumeAll+0xb8>)
 8000446:	6822      	ldr	r2, [r4, #0]
 8000448:	b13a      	cbz	r2, 800045a <xTaskResumeAll+0x7e>
					{
						vTaskIncrementTick();
 800044a:	f7ff ff5d 	bl	8000308 <vTaskIncrementTick>
						--uxMissedTicks;
 800044e:	6823      	ldr	r3, [r4, #0]
 8000450:	1e5a      	subs	r2, r3, #1
 8000452:	6022      	str	r2, [r4, #0]
 8000454:	e7f6      	b.n	8000444 <xTaskResumeAll+0x68>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 8000456:	2d01      	cmp	r5, #1
 8000458:	d106      	bne.n	8000468 <xTaskResumeAll+0x8c>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
 800045a:	490f      	ldr	r1, [pc, #60]	; (8000498 <xTaskResumeAll+0xbc>)
 800045c:	2000      	movs	r0, #0
 800045e:	6008      	str	r0, [r1, #0]
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
 8000460:	2401      	movs	r4, #1
					xMissedYield = pdFALSE;
					portYIELD_WITHIN_API();
 8000462:	f000 f8c3 	bl	80005ec <vPortYieldFromISR>
 8000466:	e004      	b.n	8000472 <xTaskResumeAll+0x96>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 8000468:	4c0b      	ldr	r4, [pc, #44]	; (8000498 <xTaskResumeAll+0xbc>)
 800046a:	6823      	ldr	r3, [r4, #0]
 800046c:	2b01      	cmp	r3, #1
 800046e:	d1be      	bne.n	80003ee <xTaskResumeAll+0x12>
 8000470:	e7f3      	b.n	800045a <xTaskResumeAll+0x7e>
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
 8000472:	f000 f8cf 	bl	8000614 <vPortExitCritical>

	return xAlreadyYielded;
}
 8000476:	4620      	mov	r0, r4
 8000478:	bd70      	pop	{r4, r5, r6, pc}
 800047a:	bf00      	nop
 800047c:	20000908 	.word	0x20000908
 8000480:	200008e4 	.word	0x200008e4
 8000484:	200008e8 	.word	0x200008e8
 8000488:	20000870 	.word	0x20000870
 800048c:	20000878 	.word	0x20000878
 8000490:	20000904 	.word	0x20000904
 8000494:	2000090c 	.word	0x2000090c
 8000498:	20000900 	.word	0x20000900

0800049c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 800049c:	4b18      	ldr	r3, [pc, #96]	; (8000500 <vTaskSwitchContext+0x64>)

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 800049e:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 80004a0:	6818      	ldr	r0, [r3, #0]
 80004a2:	b110      	cbz	r0, 80004aa <vTaskSwitchContext+0xe>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 80004a4:	2101      	movs	r1, #1
 80004a6:	4817      	ldr	r0, [pc, #92]	; (8000504 <vTaskSwitchContext+0x68>)
 80004a8:	e028      	b.n	80004fc <vTaskSwitchContext+0x60>
			unsigned long ulTempCounter;
			
				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
				#else
					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
 80004aa:	4917      	ldr	r1, [pc, #92]	; (8000508 <vTaskSwitchContext+0x6c>)
 80004ac:	4c17      	ldr	r4, [pc, #92]	; (800050c <vTaskSwitchContext+0x70>)
 80004ae:	880a      	ldrh	r2, [r1, #0]
				/* Add the amount of time the task has been running to the accumulated
				time so far.  The time the task started running was stored in
				ulTaskSwitchedInTime.  Note that there is no overflow protection here
				so count values are only valid until the timer overflows.  Generally
				this will be about 1 hour assuming a 1uS timer increment. */
				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
 80004b0:	4817      	ldr	r0, [pc, #92]	; (8000510 <vTaskSwitchContext+0x74>)
			unsigned long ulTempCounter;
			
				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
				#else
					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
 80004b2:	6a63      	ldr	r3, [r4, #36]	; 0x24
				/* Add the amount of time the task has been running to the accumulated
				time so far.  The time the task started running was stored in
				ulTaskSwitchedInTime.  Note that there is no overflow protection here
				so count values are only valid until the timer overflows.  Generally
				this will be about 1 hour assuming a 1uS timer increment. */
				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
 80004b4:	6801      	ldr	r1, [r0, #0]
			unsigned long ulTempCounter;
			
				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
				#else
					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
 80004b6:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
				/* Add the amount of time the task has been running to the accumulated
				time so far.  The time the task started running was stored in
				ulTaskSwitchedInTime.  Note that there is no overflow protection here
				so count values are only valid until the timer overflows.  Generally
				this will be about 1 hour assuming a 1uS timer increment. */
				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
 80004ba:	4b16      	ldr	r3, [pc, #88]	; (8000514 <vTaskSwitchContext+0x78>)
 80004bc:	6ccc      	ldr	r4, [r1, #76]	; 0x4c
 80004be:	6818      	ldr	r0, [r3, #0]
				ulTaskSwitchedInTime = ulTempCounter;
 80004c0:	601a      	str	r2, [r3, #0]
				/* Add the amount of time the task has been running to the accumulated
				time so far.  The time the task started running was stored in
				ulTaskSwitchedInTime.  Note that there is no overflow protection here
				so count values are only valid until the timer overflows.  Generally
				this will be about 1 hour assuming a 1uS timer increment. */
				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
 80004c2:	1a20      	subs	r0, r4, r0
 80004c4:	1880      	adds	r0, r0, r2
 80004c6:	64c8      	str	r0, [r1, #76]	; 0x4c
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 80004c8:	4a13      	ldr	r2, [pc, #76]	; (8000518 <vTaskSwitchContext+0x7c>)
 80004ca:	2314      	movs	r3, #20
 80004cc:	6810      	ldr	r0, [r2, #0]
 80004ce:	4913      	ldr	r1, [pc, #76]	; (800051c <vTaskSwitchContext+0x80>)
 80004d0:	4358      	muls	r0, r3
 80004d2:	5808      	ldr	r0, [r1, r0]
 80004d4:	b918      	cbnz	r0, 80004de <vTaskSwitchContext+0x42>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
 80004d6:	6813      	ldr	r3, [r2, #0]
 80004d8:	1e59      	subs	r1, r3, #1
 80004da:	6011      	str	r1, [r2, #0]
 80004dc:	e7f4      	b.n	80004c8 <vTaskSwitchContext+0x2c>
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 80004de:	6812      	ldr	r2, [r2, #0]
 80004e0:	fb03 1302 	mla	r3, r3, r2, r1
 80004e4:	6859      	ldr	r1, [r3, #4]
 80004e6:	f103 0208 	add.w	r2, r3, #8
 80004ea:	6848      	ldr	r0, [r1, #4]
 80004ec:	4290      	cmp	r0, r2
 80004ee:	6058      	str	r0, [r3, #4]
 80004f0:	bf04      	itt	eq
 80004f2:	6840      	ldreq	r0, [r0, #4]
 80004f4:	6058      	streq	r0, [r3, #4]
 80004f6:	685b      	ldr	r3, [r3, #4]
 80004f8:	4805      	ldr	r0, [pc, #20]	; (8000510 <vTaskSwitchContext+0x74>)
 80004fa:	68d9      	ldr	r1, [r3, #12]
 80004fc:	6001      	str	r1, [r0, #0]
 80004fe:	bd10      	pop	{r4, pc}
 8000500:	20000908 	.word	0x20000908
 8000504:	20000900 	.word	0x20000900
 8000508:	20000920 	.word	0x20000920
 800050c:	40001000 	.word	0x40001000
 8000510:	20000904 	.word	0x20000904
 8000514:	200008fc 	.word	0x200008fc
 8000518:	20000870 	.word	0x20000870
 800051c:	20000878 	.word	0x20000878

08000520 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
 8000520:	b538      	push	{r3, r4, r5, lr}
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8000522:	68c3      	ldr	r3, [r0, #12]
 8000524:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8000526:	f104 0518 	add.w	r5, r4, #24
 800052a:	4628      	mov	r0, r5
 800052c:	f7ff fe7e 	bl	800022c <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8000530:	480f      	ldr	r0, [pc, #60]	; (8000570 <xTaskRemoveFromEventList+0x50>)
 8000532:	6801      	ldr	r1, [r0, #0]
 8000534:	b971      	cbnz	r1, 8000554 <xTaskRemoveFromEventList+0x34>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 8000536:	1d25      	adds	r5, r4, #4
 8000538:	4628      	mov	r0, r5
 800053a:	f7ff fe77 	bl	800022c <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
 800053e:	4a0d      	ldr	r2, [pc, #52]	; (8000574 <xTaskRemoveFromEventList+0x54>)
 8000540:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8000542:	6810      	ldr	r0, [r2, #0]
 8000544:	4283      	cmp	r3, r0
 8000546:	bf88      	it	hi
 8000548:	6013      	strhi	r3, [r2, #0]
 800054a:	4a0b      	ldr	r2, [pc, #44]	; (8000578 <xTaskRemoveFromEventList+0x58>)
 800054c:	2114      	movs	r1, #20
 800054e:	fb01 2003 	mla	r0, r1, r3, r2
 8000552:	e000      	b.n	8000556 <xTaskRemoveFromEventList+0x36>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8000554:	4809      	ldr	r0, [pc, #36]	; (800057c <xTaskRemoveFromEventList+0x5c>)
 8000556:	4629      	mov	r1, r5
 8000558:	f7ff fe5b 	bl	8000212 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800055c:	4b08      	ldr	r3, [pc, #32]	; (8000580 <xTaskRemoveFromEventList+0x60>)
 800055e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8000560:	6819      	ldr	r1, [r3, #0]
 8000562:	6aca      	ldr	r2, [r1, #44]	; 0x2c
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
 8000564:	4290      	cmp	r0, r2
 8000566:	bf34      	ite	cc
 8000568:	2000      	movcc	r0, #0
 800056a:	2001      	movcs	r0, #1
 800056c:	bd38      	pop	{r3, r4, r5, pc}
 800056e:	bf00      	nop
 8000570:	20000908 	.word	0x20000908
 8000574:	20000870 	.word	0x20000870
 8000578:	20000878 	.word	0x20000878
 800057c:	200008e8 	.word	0x200008e8
 8000580:	20000904 	.word	0x20000904

08000584 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
 8000584:	b538      	push	{r3, r4, r5, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
 8000586:	4604      	mov	r4, r0
 8000588:	b1d0      	cbz	r0, 80005c0 <vTaskPriorityDisinherit+0x3c>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800058a:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 800058c:	6c83      	ldr	r3, [r0, #72]	; 0x48
 800058e:	429a      	cmp	r2, r3
 8000590:	d016      	beq.n	80005c0 <vTaskPriorityDisinherit+0x3c>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
 8000592:	1d05      	adds	r5, r0, #4
 8000594:	4628      	mov	r0, r5
 8000596:	f7ff fe49 	bl	800022c <vListRemove>
				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
 800059a:	4a0a      	ldr	r2, [pc, #40]	; (80005c4 <vTaskPriorityDisinherit+0x40>)
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
 800059c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
 800059e:	6811      	ldr	r1, [r2, #0]

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
 80005a0:	f1c3 0005 	rsb	r0, r3, #5
				prvAddTaskToReadyQueue( pxTCB );
 80005a4:	428b      	cmp	r3, r1
 80005a6:	bf88      	it	hi
 80005a8:	6013      	strhi	r3, [r2, #0]
 80005aa:	4a07      	ldr	r2, [pc, #28]	; (80005c8 <vTaskPriorityDisinherit+0x44>)

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
 80005ac:	61a0      	str	r0, [r4, #24]
				prvAddTaskToReadyQueue( pxTCB );
 80005ae:	2014      	movs	r0, #20
 80005b0:	fb00 2003 	mla	r0, r0, r3, r2
 80005b4:	4629      	mov	r1, r5
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
 80005b6:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
			}
		}
	}
 80005b8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
 80005bc:	f7ff be29 	b.w	8000212 <vListInsertEnd>
 80005c0:	bd38      	pop	{r3, r4, r5, pc}
 80005c2:	bf00      	nop
 80005c4:	20000870 	.word	0x20000870
 80005c8:	20000878 	.word	0x20000878

080005cc <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 80005cc:	4b06      	ldr	r3, [pc, #24]	; (80005e8 <pxCurrentTCBConst2>)
 80005ce:	6819      	ldr	r1, [r3, #0]
 80005d0:	6808      	ldr	r0, [r1, #0]
 80005d2:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80005d6:	f380 8809 	msr	PSP, r0
 80005da:	f04f 0000 	mov.w	r0, #0
 80005de:	f380 8811 	msr	BASEPRI, r0
 80005e2:	f04e 0e0d 	orr.w	lr, lr, #13
 80005e6:	4770      	bx	lr

080005e8 <pxCurrentTCBConst2>:
 80005e8:	20000904 	.word	0x20000904

080005ec <vPortYieldFromISR>:
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
	/* Set a PendSV to request a context switch. */
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 80005ec:	4b02      	ldr	r3, [pc, #8]	; (80005f8 <vPortYieldFromISR+0xc>)
 80005ee:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80005f2:	601a      	str	r2, [r3, #0]
 80005f4:	4770      	bx	lr
 80005f6:	bf00      	nop
 80005f8:	e000ed04 	.word	0xe000ed04

080005fc <vPortEnterCritical>:
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
	portDISABLE_INTERRUPTS();
 80005fc:	f04f 0050 	mov.w	r0, #80	; 0x50
 8000600:	f380 8811 	msr	BASEPRI, r0
	uxCriticalNesting++;
 8000604:	4b02      	ldr	r3, [pc, #8]	; (8000610 <vPortEnterCritical+0x14>)
 8000606:	681a      	ldr	r2, [r3, #0]
 8000608:	1c50      	adds	r0, r2, #1
 800060a:	6018      	str	r0, [r3, #0]
 800060c:	4770      	bx	lr
 800060e:	bf00      	nop
 8000610:	2000000c 	.word	0x2000000c

08000614 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	uxCriticalNesting--;
 8000614:	4a04      	ldr	r2, [pc, #16]	; (8000628 <vPortExitCritical+0x14>)
 8000616:	6813      	ldr	r3, [r2, #0]
 8000618:	1e58      	subs	r0, r3, #1
 800061a:	6010      	str	r0, [r2, #0]
	if( uxCriticalNesting == 0 )
 800061c:	b918      	cbnz	r0, 8000626 <vPortExitCritical+0x12>
	{
		portENABLE_INTERRUPTS();
 800061e:	f04f 0000 	mov.w	r0, #0
 8000622:	f380 8811 	msr	BASEPRI, r0
 8000626:	4770      	bx	lr
 8000628:	2000000c 	.word	0x2000000c

0800062c <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 800062c:	f3ef 8009 	mrs	r0, PSP
 8000630:	4b0c      	ldr	r3, [pc, #48]	; (8000664 <pxCurrentTCBConst>)
 8000632:	681a      	ldr	r2, [r3, #0]
 8000634:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8000638:	6010      	str	r0, [r2, #0]
 800063a:	e92d 4008 	stmdb	sp!, {r3, lr}
 800063e:	f04f 0050 	mov.w	r0, #80	; 0x50
 8000642:	f380 8811 	msr	BASEPRI, r0
 8000646:	f7ff ff29 	bl	800049c <vTaskSwitchContext>
 800064a:	f04f 0000 	mov.w	r0, #0
 800064e:	f380 8811 	msr	BASEPRI, r0
 8000652:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8000656:	6819      	ldr	r1, [r3, #0]
 8000658:	6808      	ldr	r0, [r1, #0]
 800065a:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800065e:	f380 8809 	msr	PSP, r0
 8000662:	4770      	bx	lr

08000664 <pxCurrentTCBConst>:
 8000664:	20000904 	.word	0x20000904

08000668 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8000668:	b508      	push	{r3, lr}
unsigned long ulDummy;

	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 800066a:	4b07      	ldr	r3, [pc, #28]	; (8000688 <SysTick_Handler+0x20>)
 800066c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000670:	601a      	str	r2, [r3, #0]
	#endif

	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
 8000672:	f04f 0050 	mov.w	r0, #80	; 0x50
 8000676:	f380 8811 	msr	BASEPRI, r0
	{
		vTaskIncrementTick();
 800067a:	f7ff fe45 	bl	8000308 <vTaskIncrementTick>
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulDummy );
 800067e:	f04f 0000 	mov.w	r0, #0
 8000682:	f380 8811 	msr	BASEPRI, r0
 8000686:	bd08      	pop	{r3, pc}
 8000688:	e000ed04 	.word	0xe000ed04

0800068c <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 800068c:	b510      	push	{r4, lr}
 800068e:	4604      	mov	r4, r0
void *pvReturn;

	vTaskSuspendAll();
 8000690:	f7ff fe32 	bl	80002f8 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
 8000694:	4620      	mov	r0, r4
 8000696:	f000 faf9 	bl	8000c8c <malloc>
 800069a:	4604      	mov	r4, r0
	}
	xTaskResumeAll();
 800069c:	f7ff fe9e 	bl	80003dc <xTaskResumeAll>
		}
	}
	#endif
	
	return pvReturn;
}
 80006a0:	4620      	mov	r0, r4
 80006a2:	bd10      	pop	{r4, pc}

080006a4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 80006a4:	b510      	push	{r4, lr}
	if( pv )
 80006a6:	4604      	mov	r4, r0
 80006a8:	b140      	cbz	r0, 80006bc <vPortFree+0x18>
	{
		vTaskSuspendAll();
 80006aa:	f7ff fe25 	bl	80002f8 <vTaskSuspendAll>
		{
			free( pv );
 80006ae:	4620      	mov	r0, r4
 80006b0:	f000 faf4 	bl	8000c9c <free>
		}
		xTaskResumeAll();
	}
}
 80006b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	{
		vTaskSuspendAll();
		{
			free( pv );
		}
		xTaskResumeAll();
 80006b8:	f7ff be90 	b.w	80003dc <xTaskResumeAll>
 80006bc:	bd10      	pop	{r4, pc}
	...

080006c0 <main>:
uint8_t danaZMSP = 0x30;
uint8_t * pointer = (uint8_t*)pvPortMalloc(129*sizeof(uint8_t));


int main(void)
{
 80006c0:	b508      	push	{r3, lr}
	RCC_APB1ENR_PWREN_bb = 1;
 80006c2:	4b10      	ldr	r3, [pc, #64]	; (8000704 <main+0x44>)
 80006c4:	2201      	movs	r2, #1
	PWR->CR = (PWR->CR & (~PWR_CR_VOS)) | PWR_CR_VOS_0;	// set VCORE voltage range 1 (1.8V)
 80006c6:	4810      	ldr	r0, [pc, #64]	; (8000708 <main+0x48>)
uint8_t * pointer = (uint8_t*)pvPortMalloc(129*sizeof(uint8_t));


int main(void)
{
	RCC_APB1ENR_PWREN_bb = 1;
 80006c8:	601a      	str	r2, [r3, #0]
	PWR->CR = (PWR->CR & (~PWR_CR_VOS)) | PWR_CR_VOS_0;	// set VCORE voltage range 1 (1.8V)
 80006ca:	6801      	ldr	r1, [r0, #0]
 80006cc:	f421 52c0 	bic.w	r2, r1, #6144	; 0x1800
 80006d0:	f442 6300 	orr.w	r3, r2, #2048	; 0x800
 80006d4:	6003      	str	r3, [r0, #0]
	while((PWR->CSR & PWR_CSR_VOSF) != 0);	// wait for regulator ready
 80006d6:	6841      	ldr	r1, [r0, #4]
 80006d8:	06ca      	lsls	r2, r1, #27
 80006da:	d4fc      	bmi.n	80006d6 <main+0x16>

	RCC_CR_HSION_bb = 1;					// enable HSI oscillator
 80006dc:	4a0b      	ldr	r2, [pc, #44]	; (800070c <main+0x4c>)
 80006de:	2001      	movs	r0, #1
 80006e0:	6010      	str	r0, [r2, #0]
	while (RCC_CR_HSIRDY_bb == 0);
 80006e2:	4b0b      	ldr	r3, [pc, #44]	; (8000710 <main+0x50>)
 80006e4:	6819      	ldr	r1, [r3, #0]
 80006e6:	2900      	cmp	r1, #0
 80006e8:	d0fb      	beq.n	80006e2 <main+0x22>

	rccStartPll(RCC_PLL_INPUT_HSI, HSI_VALUE, FREQUENCY);
 80006ea:	490a      	ldr	r1, [pc, #40]	; (8000714 <main+0x54>)
 80006ec:	4a0a      	ldr	r2, [pc, #40]	; (8000718 <main+0x58>)
 80006ee:	2000      	movs	r0, #0
 80006f0:	f000 f8ea 	bl	80008c8 <rccStartPll(rccPllInput, unsigned long, unsigned long)>

	gpioInitialize();
 80006f4:	f000 f87a 	bl	80007ec <gpioInitialize()>
//	commandRegister(&_dirCommandDefinition);
//	commandRegister(&_runtimestatsCommandDefinition);
//	commandRegister(&_tasklistCommandDefinition);


	enum Error errorSerial = serialInitialize();
 80006f8:	f000 f94a 	bl	8000990 <serialInitialize()>

	for(;;)
		serialSendCharacter('c');
 80006fc:	2063      	movs	r0, #99	; 0x63
 80006fe:	f000 f975 	bl	80009ec <serialSendCharacter>
 8000702:	e7fb      	b.n	80006fc <main+0x3c>
 8000704:	424704f0 	.word	0x424704f0
 8000708:	40007000 	.word	0x40007000
 800070c:	42470000 	.word	0x42470000
 8000710:	42470004 	.word	0x42470004
 8000714:	00f42400 	.word	0x00f42400
 8000718:	01e84800 	.word	0x01e84800

0800071c <_GLOBAL__sub_I_danaZMSP>:
		error = ERROR_BUFFER_OVERFLOW;

	vPortFree(buffer);

	return error;
}
 800071c:	b508      	push	{r3, lr}
 * Main code block
 */
const unsigned char dana[] = {0x50};
const uint8_t adresMSP = 0x48;
uint8_t danaZMSP = 0x30;
uint8_t * pointer = (uint8_t*)pvPortMalloc(129*sizeof(uint8_t));
 800071e:	2081      	movs	r0, #129	; 0x81
 8000720:	f7ff ffb4 	bl	800068c <pvPortMalloc>
 8000724:	4b01      	ldr	r3, [pc, #4]	; (800072c <_GLOBAL__sub_I_danaZMSP+0x10>)
 8000726:	6018      	str	r0, [r3, #0]
 8000728:	bd08      	pop	{r3, pc}
 800072a:	bf00      	nop
 800072c:	20000914 	.word	0x20000914

08000730 <operator new(unsigned int)>:
 * \return pointer to allocated memory or NULL if allocation failed
 */

void* operator new(size_t size) throw()
{
	return pvPortMalloc(size);
 8000730:	f7ff bfac 	b.w	800068c <pvPortMalloc>

08000734 <operator delete(void*)>:
 * \param [in] ptr is the pointer to memory segment that should be freed
 */

void operator delete(void* ptr) throw ()
{
	if (ptr)
 8000734:	b108      	cbz	r0, 800073a <operator delete(void*)+0x6>
		vPortFree(ptr);
 8000736:	f7ff bfb5 	b.w	80006a4 <vPortFree>
 800073a:	4770      	bx	lr

0800073c <_helpHandler(char const**, unsigned long, char*, unsigned int)>:
 * \return ERROR_NONE on success, otherwise an error code defined in the file error.h
 */

static enum Error _helpHandler(const char **arguments_array, uint32_t arguments_count, char *output_buffer,
		size_t output_buffer_length)
{
 800073c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000740:	4698      	mov	r8, r3
       *  Returns a read/write iterator that points to the first element in the
       *  %list.  Iteration is done in ordinary element order.
       */
      iterator
      begin() _GLIBCXX_NOEXCEPT
      { return iterator(this->_M_impl._M_node._M_next); }
 8000742:	4b0f      	ldr	r3, [pc, #60]	; (8000780 <_helpHandler(char const**, unsigned long, char*, unsigned int)+0x44>)
 8000744:	4614      	mov	r4, r2
 8000746:	681d      	ldr	r5, [r3, #0]
	(void)arguments_array;					// suppress warning
	(void)arguments_count;					// suppress warning

	for (const CommandDefinition *definition : _commands)
 8000748:	480d      	ldr	r0, [pc, #52]	; (8000780 <_helpHandler(char const**, unsigned long, char*, unsigned int)+0x44>)
 800074a:	4285      	cmp	r5, r0
 800074c:	d011      	beq.n	8000772 <_helpHandler(char const**, unsigned long, char*, unsigned int)+0x36>
	{
		size_t string_length = strlen(definition->help_string);
 800074e:	68a9      	ldr	r1, [r5, #8]
 8000750:	68cf      	ldr	r7, [r1, #12]
 8000752:	4638      	mov	r0, r7
 8000754:	f000 fdf4 	bl	8001340 <strlen>

		if ((output_buffer_length - 1) < string_length)	// will the help string fit into buffer?
 8000758:	f108 32ff 	add.w	r2, r8, #4294967295
 800075c:	4282      	cmp	r2, r0
	(void)arguments_array;					// suppress warning
	(void)arguments_count;					// suppress warning

	for (const CommandDefinition *definition : _commands)
	{
		size_t string_length = strlen(definition->help_string);
 800075e:	4606      	mov	r6, r0

		if ((output_buffer_length - 1) < string_length)	// will the help string fit into buffer?
 8000760:	d30b      	bcc.n	800077a <_helpHandler(char const**, unsigned long, char*, unsigned int)+0x3e>
			return ERROR_BUFFER_OVERFLOW;

		memcpy(output_buffer, definition->help_string, string_length);
 8000762:	4620      	mov	r0, r4
 8000764:	4639      	mov	r1, r7
 8000766:	4632      	mov	r2, r6
 8000768:	f000 fd38 	bl	80011dc <memcpy>
		output_buffer += string_length;
 800076c:	19a4      	adds	r4, r4, r6
      { return std::__addressof(static_cast<_Node*>(_M_node)->_M_data); }

      _Self&
      operator++()
      {
	_M_node = _M_node->_M_next;
 800076e:	682d      	ldr	r5, [r5, #0]
 8000770:	e7ea      	b.n	8000748 <_helpHandler(char const**, unsigned long, char*, unsigned int)+0xc>
	}

	*output_buffer = '\0';					// add trailing '\0' to the end of output
 8000772:	2000      	movs	r0, #0
 8000774:	7020      	strb	r0, [r4, #0]

	return ERROR_NONE;
 8000776:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (const CommandDefinition *definition : _commands)
	{
		size_t string_length = strlen(definition->help_string);

		if ((output_buffer_length - 1) < string_length)	// will the help string fit into buffer?
			return ERROR_BUFFER_OVERFLOW;
 800077a:	2019      	movs	r0, #25
	}

	*output_buffer = '\0';					// add trailing '\0' to the end of output

	return ERROR_NONE;
}
 800077c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000780:	20000918 	.word	0x20000918

08000784 <std::list<CommandDefinition const*, std::allocator<CommandDefinition const*> >::~list()>:
   *  we start at the tail and move forward by one.  When this member
   *  iterator's next/previous pointers refer to itself, the %list is
   *  %empty. 
  */
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
 8000784:	b538      	push	{r3, r4, r5, lr}
 8000786:	4604      	mov	r4, r0
    void
    _List_base<_Tp, _Alloc>::
    _M_clear()
    {
      typedef _List_node<_Tp>  _Node;
      _Node* __cur = static_cast<_Node*>(_M_impl._M_node._M_next);
 8000788:	6800      	ldr	r0, [r0, #0]
      while (__cur != &_M_impl._M_node)
 800078a:	42a0      	cmp	r0, r4
 800078c:	d004      	beq.n	8000798 <std::list<CommandDefinition const*, std::allocator<CommandDefinition const*> >::~list()+0x14>
	{
	  _Node* __tmp = __cur;
	  __cur = static_cast<_Node*>(__cur->_M_next);
 800078e:	6805      	ldr	r5, [r0, #0]
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
 8000790:	f7ff ffd0 	bl	8000734 <operator delete(void*)>
 8000794:	4628      	mov	r0, r5
 8000796:	e7f8      	b.n	800078a <std::list<CommandDefinition const*, std::allocator<CommandDefinition const*> >::~list()+0x6>
 8000798:	bd38      	pop	{r3, r4, r5, pc}

0800079a <void std::list<CommandDefinition const*, std::allocator<CommandDefinition const*> >::_M_insert<CommandDefinition const* const&>(std::_List_iterator<CommandDefinition const*>, CommandDefinition const* const&)>:
        __tmp->_M_hook(__position._M_node);
      }
#else
     template<typename... _Args>
       void
       _M_insert(iterator __position, _Args&&... __args)
 800079a:	b538      	push	{r3, r4, r5, lr}
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
 800079c:	200c      	movs	r0, #12
 800079e:	460c      	mov	r4, r1
 80007a0:	4615      	mov	r5, r2
 80007a2:	f7ff ffc5 	bl	8000730 <operator new(unsigned int)>

#ifdef __GXX_EXPERIMENTAL_CXX0X__
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
 80007a6:	b120      	cbz	r0, 80007b2 <void std::list<CommandDefinition const*, std::allocator<CommandDefinition const*> >::_M_insert<CommandDefinition const* const&>(std::_List_iterator<CommandDefinition const*>, CommandDefinition const* const&)+0x18>
      _Tp _M_data;

#ifdef __GXX_EXPERIMENTAL_CXX0X__
      template<typename... _Args>
        _List_node(_Args&&... __args)
	: __detail::_List_node_base(), _M_data(std::forward<_Args>(__args)...) 
 80007a8:	2300      	movs	r3, #0
 80007aa:	6003      	str	r3, [r0, #0]
 80007ac:	6043      	str	r3, [r0, #4]
 80007ae:	6829      	ldr	r1, [r5, #0]
 80007b0:	6081      	str	r1, [r0, #8]
     template<typename... _Args>
       void
       _M_insert(iterator __position, _Args&&... __args)
       {
	 _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
	 __tmp->_M_hook(__position._M_node);
 80007b2:	4621      	mov	r1, r4
       }
 80007b4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     template<typename... _Args>
       void
       _M_insert(iterator __position, _Args&&... __args)
       {
	 _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
	 __tmp->_M_hook(__position._M_node);
 80007b8:	f000 b98e 	b.w	8000ad8 <std::__detail::_List_node_base::_M_hook(std::__detail::_List_node_base*)>

080007bc <_GLOBAL__sub_I__commands>:
 80007bc:	b510      	push	{r4, lr}
      _M_clear();

      void
      _M_init()
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
 80007be:	4c07      	ldr	r4, [pc, #28]	; (80007dc <_GLOBAL__sub_I__commands+0x20>)
       *  in constant time, and does not invalidate iterators and
       *  references.
       */
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }
 80007c0:	4a07      	ldr	r2, [pc, #28]	; (80007e0 <_GLOBAL__sub_I__commands+0x24>)
 80007c2:	4620      	mov	r0, r4
 80007c4:	4621      	mov	r1, r4
      _M_clear();

      void
      _M_init()
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
 80007c6:	6024      	str	r4, [r4, #0]
        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
 80007c8:	6064      	str	r4, [r4, #4]
       *  in constant time, and does not invalidate iterators and
       *  references.
       */
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }
 80007ca:	f7ff ffe6 	bl	800079a <void std::list<CommandDefinition const*, std::allocator<CommandDefinition const*> >::_M_insert<CommandDefinition const* const&>(std::_List_iterator<CommandDefinition const*>, CommandDefinition const* const&)>
		0,									// maximum number of arguments
		_helpHandler,						// callback function
		"help: lists all available commands\r\n",	// string displayed by help function
};

std::list<const CommandDefinition*> _commands = {&_helpCommandDefinition};
 80007ce:	4905      	ldr	r1, [pc, #20]	; (80007e4 <_GLOBAL__sub_I__commands+0x28>)
 80007d0:	4a05      	ldr	r2, [pc, #20]	; (80007e8 <_GLOBAL__sub_I__commands+0x2c>)
 80007d2:	4620      	mov	r0, r4
	}

	*output_buffer = '\0';					// add trailing '\0' to the end of output

	return ERROR_NONE;
}
 80007d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		0,									// maximum number of arguments
		_helpHandler,						// callback function
		"help: lists all available commands\r\n",	// string displayed by help function
};

std::list<const CommandDefinition*> _commands = {&_helpCommandDefinition};
 80007d8:	f000 b978 	b.w	8000acc <__aeabi_atexit>
 80007dc:	20000918 	.word	0x20000918
 80007e0:	080015ec 	.word	0x080015ec
 80007e4:	08000785 	.word	0x08000785
 80007e8:	20000000 	.word	0x20000000

080007ec <gpioInitialize()>:
 */

void gpioInitialize(void)
{
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN | RCC_AHBENR_GPIOBEN | RCC_AHBENR_GPIOCEN | RCC_AHBENR_GPIODEN |
			RCC_AHBENR_GPIOEEN | RCC_AHBENR_GPIOFEN | RCC_AHBENR_GPIOGEN | RCC_AHBENR_GPIOHEN;
 80007ec:	4b02      	ldr	r3, [pc, #8]	; (80007f8 <gpioInitialize()+0xc>)
 80007ee:	69da      	ldr	r2, [r3, #28]
 80007f0:	f042 00ff 	orr.w	r0, r2, #255	; 0xff
 80007f4:	61d8      	str	r0, [r3, #28]
 80007f6:	4770      	bx	lr
 80007f8:	40023800 	.word	0x40023800

080007fc <gpioConfigurePin(GPIO_TypeDef*, GpioPin, GpioConfiguration)>:
void gpioConfigurePin(GPIO_TypeDef *port, enum GpioPin pin, enum GpioConfiguration configuration)
{
	uint32_t moder, otyper, ospeedr, pupdr, afr, afrx;

	moder = port->MODER;				// localize
	moder &= ~(GPIO_MODER_mask << (pin * 2));	// clear current setting
 80007fc:	004b      	lsls	r3, r1, #1
 * GPIO_[AF0; AF15]_{PP, OD}_{400kHz, 2MHz, 10MHz, 40MHz},
 * GPIO_[AF0; AF15]_{PP, OD}_{400kHz, 2MHz, 10MHz, 40MHz}_{PULL_UP, PULL_DOWN}, GPIO_ANALOG}
 */

void gpioConfigurePin(GPIO_TypeDef *port, enum GpioPin pin, enum GpioConfiguration configuration)
{
 80007fe:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t moder, otyper, ospeedr, pupdr, afr, afrx;

	moder = port->MODER;				// localize
	moder &= ~(GPIO_MODER_mask << (pin * 2));	// clear current setting
 8000800:	2403      	movs	r4, #3
 8000802:	fa04 f403 	lsl.w	r4, r4, r3
	moder |= (GPIO_GET_MODER(configuration) << (pin * 2));	// apply new setting
 8000806:	f002 050f 	and.w	r5, r2, #15
 800080a:	fa05 f503 	lsl.w	r5, r5, r3

void gpioConfigurePin(GPIO_TypeDef *port, enum GpioPin pin, enum GpioConfiguration configuration)
{
	uint32_t moder, otyper, ospeedr, pupdr, afr, afrx;

	moder = port->MODER;				// localize
 800080e:	6806      	ldr	r6, [r0, #0]
	moder &= ~(GPIO_MODER_mask << (pin * 2));	// clear current setting
 8000810:	43e4      	mvns	r4, r4
 8000812:	4026      	ands	r6, r4
	moder |= (GPIO_GET_MODER(configuration) << (pin * 2));	// apply new setting
 8000814:	ea46 0705 	orr.w	r7, r6, r5
	port->MODER = moder;				// save back
 8000818:	6007      	str	r7, [r0, #0]

	otyper = port->OTYPER;				// localize
 800081a:	8886      	ldrh	r6, [r0, #4]
	otyper &= ~(GPIO_OTYPER_mask << pin);	// clear current setting
 800081c:	2501      	movs	r5, #1
	moder = port->MODER;				// localize
	moder &= ~(GPIO_MODER_mask << (pin * 2));	// clear current setting
	moder |= (GPIO_GET_MODER(configuration) << (pin * 2));	// apply new setting
	port->MODER = moder;				// save back

	otyper = port->OTYPER;				// localize
 800081e:	b2b7      	uxth	r7, r6
	otyper &= ~(GPIO_OTYPER_mask << pin);	// clear current setting
 8000820:	fa05 f601 	lsl.w	r6, r5, r1
 8000824:	ea27 0706 	bic.w	r7, r7, r6
	otyper |= (GPIO_GET_OTYPER(configuration) << pin);	// apply new setting
 8000828:	f3c2 1603 	ubfx	r6, r2, #4, #4
 800082c:	fa06 f601 	lsl.w	r6, r6, r1
 8000830:	433e      	orrs	r6, r7
	port->OTYPER = otyper;				// save back
 8000832:	b2b7      	uxth	r7, r6

	ospeedr = port->OSPEEDR;			// localize
	ospeedr &= ~(GPIO_OSPEEDR_mask << (pin * 2));	// clear current setting
	ospeedr |= (GPIO_GET_OSPEEDR(configuration) << (pin * 2));	// apply new setting
 8000834:	f3c2 2603 	ubfx	r6, r2, #8, #4
 8000838:	fa06 f603 	lsl.w	r6, r6, r3
	port->MODER = moder;				// save back

	otyper = port->OTYPER;				// localize
	otyper &= ~(GPIO_OTYPER_mask << pin);	// clear current setting
	otyper |= (GPIO_GET_OTYPER(configuration) << pin);	// apply new setting
	port->OTYPER = otyper;				// save back
 800083c:	8087      	strh	r7, [r0, #4]

	ospeedr = port->OSPEEDR;			// localize
 800083e:	6887      	ldr	r7, [r0, #8]
	pupdr = port->PUPDR;				// localize
	pupdr &= ~(GPIO_PUPDR_mask << (pin * 2));	// clear current setting
	pupdr |= (GPIO_GET_PUPDR(configuration) << (pin * 2));	// apply new setting
	port->PUPDR = pupdr;				// save back

	if (pin < 8)							// determine which AFR register should be used
 8000840:	2907      	cmp	r1, #7
	otyper &= ~(GPIO_OTYPER_mask << pin);	// clear current setting
	otyper |= (GPIO_GET_OTYPER(configuration) << pin);	// apply new setting
	port->OTYPER = otyper;				// save back

	ospeedr = port->OSPEEDR;			// localize
	ospeedr &= ~(GPIO_OSPEEDR_mask << (pin * 2));	// clear current setting
 8000842:	ea07 0704 	and.w	r7, r7, r4
	ospeedr |= (GPIO_GET_OSPEEDR(configuration) << (pin * 2));	// apply new setting
 8000846:	ea46 0607 	orr.w	r6, r6, r7
	port->OSPEEDR = ospeedr;			// save back
 800084a:	6086      	str	r6, [r0, #8]

	pupdr = port->PUPDR;				// localize
 800084c:	68c6      	ldr	r6, [r0, #12]
	pupdr &= ~(GPIO_PUPDR_mask << (pin * 2));	// clear current setting
 800084e:	ea04 0406 	and.w	r4, r4, r6
	pupdr |= (GPIO_GET_PUPDR(configuration) << (pin * 2));	// apply new setting
 8000852:	f3c2 3603 	ubfx	r6, r2, #12, #4
 8000856:	fa06 f303 	lsl.w	r3, r6, r3
 800085a:	ea43 0304 	orr.w	r3, r3, r4
	port->PUPDR = pupdr;				// save back
 800085e:	60c3      	str	r3, [r0, #12]

	if (pin < 8)							// determine which AFR register should be used
 8000860:	d903      	bls.n	800086a <gpioConfigurePin(GPIO_TypeDef*, GpioPin, GpioConfiguration)+0x6e>
		afrx = 0;							// AFRL - pins [0; 7]
	else
	{
		afrx = 1;							// AFRH - pins [8; 15]
		pin = (enum GpioPin)(((uint32_t)pin) - 8);	// trim pin number
 8000862:	3908      	subs	r1, #8
 8000864:	b2c9      	uxtb	r1, r1

	if (pin < 8)							// determine which AFR register should be used
		afrx = 0;							// AFRL - pins [0; 7]
	else
	{
		afrx = 1;							// AFRH - pins [8; 15]
 8000866:	462b      	mov	r3, r5
 8000868:	e000      	b.n	800086c <gpioConfigurePin(GPIO_TypeDef*, GpioPin, GpioConfiguration)+0x70>
	pupdr &= ~(GPIO_PUPDR_mask << (pin * 2));	// clear current setting
	pupdr |= (GPIO_GET_PUPDR(configuration) << (pin * 2));	// apply new setting
	port->PUPDR = pupdr;				// save back

	if (pin < 8)							// determine which AFR register should be used
		afrx = 0;							// AFRL - pins [0; 7]
 800086a:	2300      	movs	r3, #0
		afrx = 1;							// AFRH - pins [8; 15]
		pin = (enum GpioPin)(((uint32_t)pin) - 8);	// trim pin number
	}

	afr = port->AFR[afrx];				// localize
	afr &= ~(GPIO_AFRx_mask << (pin * 4));	// clear current setting
 800086c:	0089      	lsls	r1, r1, #2
 800086e:	240f      	movs	r4, #15
 8000870:	fa04 f401 	lsl.w	r4, r4, r1
	afr |= (GPIO_GET_AFR(configuration) << (pin * 4));	// apply new setting
 8000874:	f3c2 4203 	ubfx	r2, r2, #16, #4
 8000878:	fa02 f101 	lsl.w	r1, r2, r1
	{
		afrx = 1;							// AFRH - pins [8; 15]
		pin = (enum GpioPin)(((uint32_t)pin) - 8);	// trim pin number
	}

	afr = port->AFR[afrx];				// localize
 800087c:	3308      	adds	r3, #8
 800087e:	f850 5023 	ldr.w	r5, [r0, r3, lsl #2]
	afr &= ~(GPIO_AFRx_mask << (pin * 4));	// clear current setting
 8000882:	ea25 0404 	bic.w	r4, r5, r4
	afr |= (GPIO_GET_AFR(configuration) << (pin * 4));	// apply new setting
 8000886:	ea44 0201 	orr.w	r2, r4, r1
	port->AFR[afrx] = afr;				// save back
 800088a:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 800088e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08000890 <TIM6_IRQHandler>:
 */

extern "C" void TIM6_IRQHandler(void) __attribute__ ((interrupt));
void TIM6_IRQHandler(void)
{
	tim6OverflowCount++;
 8000890:	4b08      	ldr	r3, [pc, #32]	; (80008b4 <TIM6_IRQHandler+0x24>)
 * TIM6_IRQHandler
 */

extern "C" void TIM6_IRQHandler(void) __attribute__ ((interrupt));
void TIM6_IRQHandler(void)
{
 8000892:	4668      	mov	r0, sp
	tim6OverflowCount++;
 8000894:	881a      	ldrh	r2, [r3, #0]
 * TIM6_IRQHandler
 */

extern "C" void TIM6_IRQHandler(void) __attribute__ ((interrupt));
void TIM6_IRQHandler(void)
{
 8000896:	f020 0107 	bic.w	r1, r0, #7
 800089a:	468d      	mov	sp, r1
 800089c:	b501      	push	{r0, lr}
	tim6OverflowCount++;
 800089e:	1c50      	adds	r0, r2, #1
 80008a0:	b281      	uxth	r1, r0
 80008a2:	8019      	strh	r1, [r3, #0]

	TIM6->SR = 0;							// clear UIF which is only bit in this register
 80008a4:	4b04      	ldr	r3, [pc, #16]	; (80008b8 <TIM6_IRQHandler+0x28>)
 80008a6:	2200      	movs	r2, #0
 80008a8:	821a      	strh	r2, [r3, #16]
}
 80008aa:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
 80008ae:	4685      	mov	sp, r0
 80008b0:	4770      	bx	lr
 80008b2:	bf00      	nop
 80008b4:	20000920 	.word	0x20000920
 80008b8:	40001000 	.word	0x40001000

080008bc <rccGetCoreFrequency>:
 */

uint32_t rccGetCoreFrequency(void)
{
	return _coreFrequency;
}
 80008bc:	4b01      	ldr	r3, [pc, #4]	; (80008c4 <rccGetCoreFrequency+0x8>)
 80008be:	6818      	ldr	r0, [r3, #0]
 80008c0:	4770      	bx	lr
 80008c2:	bf00      	nop
 80008c4:	20000010 	.word	0x20000010

080008c8 <rccStartPll(rccPllInput, unsigned long, unsigned long)>:
 *
 * \return real frequency that was set
 */

uint32_t rccStartPll(enum rccPllInput pll_input, uint32_t input_frequency, uint32_t output_frequency)
{
 80008c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	#error "Invalid value of DEVICE_VCORE_mV!"
#endif

	static const uint8_t muls[] = {3, 4, 6, 8, 12, 16, 24, 32, 48};	// allowed values of PLL multiplier
	uint32_t mul_i;
	uint32_t best_frequency = 0, best_mul_i = 0, best_div = 0;
 80008cc:	2400      	movs	r4, #0
 80008ce:	46a4      	mov	ip, r4
 80008d0:	4623      	mov	r3, r4

	for (mul_i = 0; mul_i < sizeof (muls) / sizeof (muls[0]); mul_i++)	// loop through all multipliers
 80008d2:	4625      	mov	r5, r4
	{
		uint32_t pllvco = input_frequency * muls[mul_i];
 80008d4:	4e26      	ldr	r6, [pc, #152]	; (8000970 <rccStartPll(rccPllInput, unsigned long, unsigned long)+0xa8>)
 80008d6:	f815 8006 	ldrb.w	r8, [r5, r6]

		if (pllvco > pllvco_max)			// internal PLL frequency out of valid range?
 80008da:	4e26      	ldr	r6, [pc, #152]	; (8000974 <rccStartPll(rccPllInput, unsigned long, unsigned long)+0xac>)
	uint32_t mul_i;
	uint32_t best_frequency = 0, best_mul_i = 0, best_div = 0;

	for (mul_i = 0; mul_i < sizeof (muls) / sizeof (muls[0]); mul_i++)	// loop through all multipliers
	{
		uint32_t pllvco = input_frequency * muls[mul_i];
 80008dc:	fb01 f808 	mul.w	r8, r1, r8

		if (pllvco > pllvco_max)			// internal PLL frequency out of valid range?
 80008e0:	45b0      	cmp	r8, r6
 80008e2:	d810      	bhi.n	8000906 <rccStartPll(rccPllInput, unsigned long, unsigned long)+0x3e>
 80008e4:	2602      	movs	r6, #2

		uint32_t div;

		for (div = 2; div <= 4; div++)		// loop through all dividers
		{
			uint32_t frequency = pllvco / div;
 80008e6:	fbb8 f7f6 	udiv	r7, r8, r6

			if (frequency > output_frequency)	// resulting frequency too high?
 80008ea:	4297      	cmp	r7, r2
 80008ec:	d806      	bhi.n	80008fc <rccStartPll(rccPllInput, unsigned long, unsigned long)+0x34>
				continue;

			if (frequency > best_frequency)	// is this configuration better than previously found?
 80008ee:	429f      	cmp	r7, r3
 80008f0:	d904      	bls.n	80008fc <rccStartPll(rccPllInput, unsigned long, unsigned long)+0x34>
			{
				best_frequency = frequency;	// yes - store values
				best_mul_i = mul_i;
				best_div = div;

				if (best_frequency == output_frequency)	// is this a perfect match?
 80008f2:	4297      	cmp	r7, r2
 80008f4:	4634      	mov	r4, r6
 80008f6:	46ac      	mov	ip, r5
 80008f8:	d009      	beq.n	800090e <rccStartPll(rccPllInput, unsigned long, unsigned long)+0x46>
 80008fa:	463b      	mov	r3, r7
		if (pllvco > pllvco_max)			// internal PLL frequency out of valid range?
			continue;

		uint32_t div;

		for (div = 2; div <= 4; div++)		// loop through all dividers
 80008fc:	3601      	adds	r6, #1
 80008fe:	2e05      	cmp	r6, #5
 8000900:	d1f1      	bne.n	80008e6 <rccStartPll(rccPllInput, unsigned long, unsigned long)+0x1e>
				if (best_frequency == output_frequency)	// is this a perfect match?
					break;
			}
		}

		if (best_frequency == output_frequency)	// is this a perfect match?
 8000902:	4293      	cmp	r3, r2
 8000904:	d004      	beq.n	8000910 <rccStartPll(rccPllInput, unsigned long, unsigned long)+0x48>

	static const uint8_t muls[] = {3, 4, 6, 8, 12, 16, 24, 32, 48};	// allowed values of PLL multiplier
	uint32_t mul_i;
	uint32_t best_frequency = 0, best_mul_i = 0, best_div = 0;

	for (mul_i = 0; mul_i < sizeof (muls) / sizeof (muls[0]); mul_i++)	// loop through all multipliers
 8000906:	3501      	adds	r5, #1
 8000908:	2d09      	cmp	r5, #9
 800090a:	d1e3      	bne.n	80008d4 <rccStartPll(rccPllInput, unsigned long, unsigned long)+0xc>
 800090c:	e000      	b.n	8000910 <rccStartPll(rccPllInput, unsigned long, unsigned long)+0x48>

		uint32_t div;

		for (div = 2; div <= 4; div++)		// loop through all dividers
		{
			uint32_t frequency = pllvco / div;
 800090e:	4613      	mov	r3, r2
	if (frequency > 16000000)
		wait_states = 1;
	else
		wait_states = 0;

    FLASH->ACR |= FLASH_ACR_ACC64;
 8000910:	4a19      	ldr	r2, [pc, #100]	; (8000978 <rccStartPll(rccPllInput, unsigned long, unsigned long)+0xb0>)
	}

	_flashLatency(best_frequency);			// configure flash latency using found frequency

	RCC->CFGR = ((best_div - 1) << RCC_CFGR_PLLDIV_bit) | (best_mul_i << RCC_CFGR_PLLMUL_bit) |
			(pll_input << RCC_CFGR_PLLSRC_bit);	// set PLL
 8000912:	0400      	lsls	r0, r0, #16
	if (frequency > 16000000)
		wait_states = 1;
	else
		wait_states = 0;

    FLASH->ACR |= FLASH_ACR_ACC64;
 8000914:	6811      	ldr	r1, [r2, #0]
	}

	_flashLatency(best_frequency);			// configure flash latency using found frequency

	RCC->CFGR = ((best_div - 1) << RCC_CFGR_PLLDIV_bit) | (best_mul_i << RCC_CFGR_PLLMUL_bit) |
			(pll_input << RCC_CFGR_PLLSRC_bit);	// set PLL
 8000916:	ea40 4c8c 	orr.w	ip, r0, ip, lsl #18
	if (frequency > 16000000)
		wait_states = 1;
	else
		wait_states = 0;

    FLASH->ACR |= FLASH_ACR_ACC64;
 800091a:	f041 0504 	orr.w	r5, r1, #4
 800091e:	6015      	str	r5, [r2, #0]
    FLASH->ACR = (FLASH->ACR & (~FLASH_ACR_LATENCY)) | FLASH_ACR_PRFTEN | wait_states;
 8000920:	6811      	ldr	r1, [r2, #0]
	}

	_flashLatency(best_frequency);			// configure flash latency using found frequency

	RCC->CFGR = ((best_div - 1) << RCC_CFGR_PLLDIV_bit) | (best_mul_i << RCC_CFGR_PLLMUL_bit) |
			(pll_input << RCC_CFGR_PLLSRC_bit);	// set PLL
 8000922:	3c01      	subs	r4, #1
		wait_states = 1;
	else
		wait_states = 0;

    FLASH->ACR |= FLASH_ACR_ACC64;
    FLASH->ACR = (FLASH->ACR & (~FLASH_ACR_LATENCY)) | FLASH_ACR_PRFTEN | wait_states;
 8000924:	f021 0503 	bic.w	r5, r1, #3
 8000928:	f045 0102 	orr.w	r1, r5, #2
 800092c:	4d13      	ldr	r5, [pc, #76]	; (800097c <rccStartPll(rccPllInput, unsigned long, unsigned long)+0xb4>)
	}

	_flashLatency(best_frequency);			// configure flash latency using found frequency

	RCC->CFGR = ((best_div - 1) << RCC_CFGR_PLLDIV_bit) | (best_mul_i << RCC_CFGR_PLLMUL_bit) |
			(pll_input << RCC_CFGR_PLLSRC_bit);	// set PLL
 800092e:	ea4c 5484 	orr.w	r4, ip, r4, lsl #22
		wait_states = 1;
	else
		wait_states = 0;

    FLASH->ACR |= FLASH_ACR_ACC64;
    FLASH->ACR = (FLASH->ACR & (~FLASH_ACR_LATENCY)) | FLASH_ACR_PRFTEN | wait_states;
 8000932:	42ab      	cmp	r3, r5
 8000934:	bf88      	it	hi
 8000936:	f041 0101 	orrhi.w	r1, r1, #1
 800093a:	6011      	str	r1, [r2, #0]
	_flashLatency(best_frequency);			// configure flash latency using found frequency

	RCC->CFGR = ((best_div - 1) << RCC_CFGR_PLLDIV_bit) | (best_mul_i << RCC_CFGR_PLLMUL_bit) |
			(pll_input << RCC_CFGR_PLLSRC_bit);	// set PLL

	RCC_CR_PLLON_bb = 1;					// enable PLL and wait for stabilization
 800093c:	4910      	ldr	r1, [pc, #64]	; (8000980 <rccStartPll(rccPllInput, unsigned long, unsigned long)+0xb8>)
	}

	_flashLatency(best_frequency);			// configure flash latency using found frequency

	RCC->CFGR = ((best_div - 1) << RCC_CFGR_PLLDIV_bit) | (best_mul_i << RCC_CFGR_PLLMUL_bit) |
			(pll_input << RCC_CFGR_PLLSRC_bit);	// set PLL
 800093e:	f5a2 6280 	sub.w	r2, r2, #1024	; 0x400

	RCC_CR_PLLON_bb = 1;					// enable PLL and wait for stabilization
 8000942:	2001      	movs	r0, #1
	}

	_flashLatency(best_frequency);			// configure flash latency using found frequency

	RCC->CFGR = ((best_div - 1) << RCC_CFGR_PLLDIV_bit) | (best_mul_i << RCC_CFGR_PLLMUL_bit) |
			(pll_input << RCC_CFGR_PLLSRC_bit);	// set PLL
 8000944:	6094      	str	r4, [r2, #8]

	RCC_CR_PLLON_bb = 1;					// enable PLL and wait for stabilization
 8000946:	6008      	str	r0, [r1, #0]
	while (RCC_CR_PLLRDY_bb == 0);
 8000948:	480e      	ldr	r0, [pc, #56]	; (8000984 <rccStartPll(rccPllInput, unsigned long, unsigned long)+0xbc>)
 800094a:	6801      	ldr	r1, [r0, #0]
 800094c:	2900      	cmp	r1, #0
 800094e:	d0fb      	beq.n	8000948 <rccStartPll(rccPllInput, unsigned long, unsigned long)+0x80>

	RCC->CFGR |= RCC_CFGR_SW_PLL;			// change SYSCLK to PLL
 8000950:	6890      	ldr	r0, [r2, #8]
 8000952:	f040 0103 	orr.w	r1, r0, #3
 8000956:	6091      	str	r1, [r2, #8]
	while (((RCC->CFGR) & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);	// wait for switch
 8000958:	4a0b      	ldr	r2, [pc, #44]	; (8000988 <rccStartPll(rccPllInput, unsigned long, unsigned long)+0xc0>)
 800095a:	6890      	ldr	r0, [r2, #8]
 800095c:	f000 010c 	and.w	r1, r0, #12
 8000960:	290c      	cmp	r1, #12
 8000962:	d1f9      	bne.n	8000958 <rccStartPll(rccPllInput, unsigned long, unsigned long)+0x90>

	_coreFrequency = best_frequency;
 8000964:	4a09      	ldr	r2, [pc, #36]	; (800098c <rccStartPll(rccPllInput, unsigned long, unsigned long)+0xc4>)

	return best_frequency;
}
 8000966:	4618      	mov	r0, r3
	while (RCC_CR_PLLRDY_bb == 0);

	RCC->CFGR |= RCC_CFGR_SW_PLL;			// change SYSCLK to PLL
	while (((RCC->CFGR) & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);	// wait for switch

	_coreFrequency = best_frequency;
 8000968:	6013      	str	r3, [r2, #0]

	return best_frequency;
}
 800096a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800096e:	bf00      	nop
 8000970:	08001630 	.word	0x08001630
 8000974:	05b8d800 	.word	0x05b8d800
 8000978:	40023c00 	.word	0x40023c00
 800097c:	00f42400 	.word	0x00f42400
 8000980:	42470060 	.word	0x42470060
 8000984:	42470064 	.word	0x42470064
 8000988:	40023800 	.word	0x40023800
 800098c:	20000010 	.word	0x20000010

08000990 <serialInitialize()>:
 * tasks were successfully created and added to a ready list, otherwise an error
 * code defined in the file error.h
 */

enum Error serialInitialize(void)
{
 8000990:	b538      	push	{r3, r4, r5, lr}
	RCC->APB2ENR |= RCC_APB1ENR_USART2EN;
 8000992:	4b11      	ldr	r3, [pc, #68]	; (80009d8 <serialInitialize()+0x48>)
	gpioConfigurePin(GPIOA, GPIO_PIN_2, GPIO_AF7_PP_40MHz_PULL_UP);
 8000994:	4d11      	ldr	r5, [pc, #68]	; (80009dc <serialInitialize()+0x4c>)
 * code defined in the file error.h
 */

enum Error serialInitialize(void)
{
	RCC->APB2ENR |= RCC_APB1ENR_USART2EN;
 8000996:	6a1a      	ldr	r2, [r3, #32]
	gpioConfigurePin(GPIOA, GPIO_PIN_2, GPIO_AF7_PP_40MHz_PULL_UP);
 8000998:	4c11      	ldr	r4, [pc, #68]	; (80009e0 <serialInitialize()+0x50>)
 * code defined in the file error.h
 */

enum Error serialInitialize(void)
{
	RCC->APB2ENR |= RCC_APB1ENR_USART2EN;
 800099a:	f442 3000 	orr.w	r0, r2, #131072	; 0x20000
 800099e:	6218      	str	r0, [r3, #32]
	gpioConfigurePin(GPIOA, GPIO_PIN_2, GPIO_AF7_PP_40MHz_PULL_UP);
 80009a0:	2102      	movs	r1, #2
 80009a2:	4628      	mov	r0, r5
 80009a4:	4622      	mov	r2, r4
 80009a6:	f7ff ff29 	bl	80007fc <gpioConfigurePin(GPIO_TypeDef*, GpioPin, GpioConfiguration)>
	gpioConfigurePin(GPIOA, GPIO_PIN_3, GPIO_AF7_PP_40MHz_PULL_UP);
 80009aa:	4622      	mov	r2, r4
 80009ac:	4628      	mov	r0, r5
 80009ae:	2103      	movs	r1, #3
 80009b0:	f7ff ff24 	bl	80007fc <gpioConfigurePin(GPIO_TypeDef*, GpioPin, GpioConfiguration)>

	RCC_APB1ENR_USART2EN_bb = 1;			// enable USART in RCC
 80009b4:	4b0b      	ldr	r3, [pc, #44]	; (80009e4 <serialInitialize()+0x54>)
 80009b6:	2101      	movs	r1, #1
 80009b8:	6019      	str	r1, [r3, #0]

	USART2->BRR = (rccGetCoreFrequency() + SERIALx_BAUDRATE / 2) / SERIALx_BAUDRATE;	// calculate baudrate (with rounding)
 80009ba:	f7ff ff7f 	bl	80008bc <rccGetCoreFrequency>
 80009be:	f500 4261 	add.w	r2, r0, #57600	; 0xe100
 80009c2:	f44f 30e1 	mov.w	r0, #115200	; 0x1c200
 80009c6:	fbb2 f1f0 	udiv	r1, r2, r0
 80009ca:	4b07      	ldr	r3, [pc, #28]	; (80009e8 <serialInitialize()+0x58>)
	// enable peripheral, transmitter and receiver, enable RXNE interrupt
	USART2->CR1 = USART_CR1_UE | USART_CR1_TE | USART_CR1_RE;
 80009cc:	f242 000c 	movw	r0, #8204	; 0x200c
	gpioConfigurePin(GPIOA, GPIO_PIN_2, GPIO_AF7_PP_40MHz_PULL_UP);
	gpioConfigurePin(GPIOA, GPIO_PIN_3, GPIO_AF7_PP_40MHz_PULL_UP);

	RCC_APB1ENR_USART2EN_bb = 1;			// enable USART in RCC

	USART2->BRR = (rccGetCoreFrequency() + SERIALx_BAUDRATE / 2) / SERIALx_BAUDRATE;	// calculate baudrate (with rounding)
 80009d0:	b28a      	uxth	r2, r1
 80009d2:	811a      	strh	r2, [r3, #8]
	// enable peripheral, transmitter and receiver, enable RXNE interrupt
	USART2->CR1 = USART_CR1_UE | USART_CR1_TE | USART_CR1_RE;
 80009d4:	8198      	strh	r0, [r3, #12]

}
 80009d6:	bd38      	pop	{r3, r4, r5, pc}
 80009d8:	40023800 	.word	0x40023800
 80009dc:	40020000 	.word	0x40020000
 80009e0:	00071302 	.word	0x00071302
 80009e4:	424704c4 	.word	0x424704c4
 80009e8:	40004400 	.word	0x40004400

080009ec <serialSendCharacter>:
 * \param [in] c is the character that will be printed
 */

void serialSendCharacter(char c)
{
	while (!(USARTx_SR_TXE_bb(SERIALx)));
 80009ec:	4b03      	ldr	r3, [pc, #12]	; (80009fc <serialSendCharacter+0x10>)
 80009ee:	6819      	ldr	r1, [r3, #0]
 80009f0:	2900      	cmp	r1, #0
 80009f2:	d0fb      	beq.n	80009ec <serialSendCharacter>
	USART2->DR = c;
 80009f4:	4a02      	ldr	r2, [pc, #8]	; (8000a00 <serialSendCharacter+0x14>)
 80009f6:	8090      	strh	r0, [r2, #4]
 80009f8:	4770      	bx	lr
 80009fa:	bf00      	nop
 80009fc:	4208801c 	.word	0x4208801c
 8000a00:	40004400 	.word	0x40004400

08000a04 <DMA1_Channel4_IRQHandler>:
 *
 * DMA channel interrupt handler
 */

extern "C" void USARTx_DMAx_TX_CH_IRQHandler(void) __attribute__ ((interrupt));
void USARTx_DMAx_TX_CH_IRQHandler(void) {
 8000a04:	4668      	mov	r0, sp
 8000a06:	f020 0107 	bic.w	r1, r0, #7
 8000a0a:	468d      	mov	sp, r1
 8000a0c:	b501      	push	{r0, lr}
	signed portBASE_TYPE higher_priority_task_woken;

	xSemaphoreGiveFromISR(_dmaTxSemaphore, &higher_priority_task_woken);
 8000a0e:	4b0a      	ldr	r3, [pc, #40]	; (8000a38 <DMA1_Channel4_IRQHandler+0x34>)
 *
 * DMA channel interrupt handler
 */

extern "C" void USARTx_DMAx_TX_CH_IRQHandler(void) __attribute__ ((interrupt));
void USARTx_DMAx_TX_CH_IRQHandler(void) {
 8000a10:	b082      	sub	sp, #8
	signed portBASE_TYPE higher_priority_task_woken;

	xSemaphoreGiveFromISR(_dmaTxSemaphore, &higher_priority_task_woken);
 8000a12:	2100      	movs	r1, #0
 8000a14:	6818      	ldr	r0, [r3, #0]
 8000a16:	aa01      	add	r2, sp, #4
 8000a18:	460b      	mov	r3, r1
 8000a1a:	f7ff fc43 	bl	80002a4 <xQueueGenericSendFromISR>

	USARTx_DMAx_TX_IFCR_CTCIFx_bb = 1;			// clear interrupt flag
 8000a1e:	4807      	ldr	r0, [pc, #28]	; (8000a3c <DMA1_Channel4_IRQHandler+0x38>)
 8000a20:	2201      	movs	r2, #1
 8000a22:	6002      	str	r2, [r0, #0]

	portEND_SWITCHING_ISR(higher_priority_task_woken);
 8000a24:	9901      	ldr	r1, [sp, #4]
 8000a26:	b109      	cbz	r1, 8000a2c <DMA1_Channel4_IRQHandler+0x28>
 8000a28:	f7ff fde0 	bl	80005ec <vPortYieldFromISR>
}
 8000a2c:	b002      	add	sp, #8
 8000a2e:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
 8000a32:	4685      	mov	sp, r0
 8000a34:	4770      	bx	lr
 8000a36:	bf00      	nop
 8000a38:	20000940 	.word	0x20000940
 8000a3c:	424c00b4 	.word	0x424c00b4

08000a40 <USART1_IRQHandler>:
 *
 * USART interrupt handler
 */

extern "C" void USARTx_IRQHandler(void) __attribute((interrupt));
void USARTx_IRQHandler(void) {
 8000a40:	4668      	mov	r0, sp
 8000a42:	f020 0107 	bic.w	r1, r0, #7
 8000a46:	468d      	mov	sp, r1
 8000a48:	b511      	push	{r0, r4, lr}
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
 8000a4a:	2300      	movs	r3, #0
 *
 * USART interrupt handler
 */

extern "C" void USARTx_IRQHandler(void) __attribute((interrupt));
void USARTx_IRQHandler(void) {
 8000a4c:	b083      	sub	sp, #12
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
 8000a4e:	9301      	str	r3, [sp, #4]
	static struct _RxMessage message;

	while (USARTx_SR_RXNE_bb(USARTx))		// loop while data is available
 8000a50:	481a      	ldr	r0, [pc, #104]	; (8000abc <USART1_IRQHandler+0x7c>)
 8000a52:	6802      	ldr	r2, [r0, #0]
 8000a54:	b34a      	cbz	r2, 8000aaa <USART1_IRQHandler+0x6a>
	{
		char c = USARTx->DR;
 8000a56:	4b1a      	ldr	r3, [pc, #104]	; (8000ac0 <USART1_IRQHandler+0x80>)
 8000a58:	8898      	ldrh	r0, [r3, #4]
		message.string[message.length++] = c;	// get char to buffer
 8000a5a:	4b1a      	ldr	r3, [pc, #104]	; (8000ac4 <USART1_IRQHandler+0x84>)
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	static struct _RxMessage message;

	while (USARTx_SR_RXNE_bb(USARTx))		// loop while data is available
	{
		char c = USARTx->DR;
 8000a5c:	b2c2      	uxtb	r2, r0
		message.string[message.length++] = c;	// get char to buffer
 8000a5e:	6819      	ldr	r1, [r3, #0]
 8000a60:	1858      	adds	r0, r3, r1
 8000a62:	7142      	strb	r2, [r0, #5]

		// check for "\r\n" sequence in the string
		if ((message.status == RX_STATUS_HAD_CR) && (c == '\n'))
 8000a64:	7918      	ldrb	r0, [r3, #4]
	static struct _RxMessage message;

	while (USARTx_SR_RXNE_bb(USARTx))		// loop while data is available
	{
		char c = USARTx->DR;
		message.string[message.length++] = c;	// get char to buffer
 8000a66:	3101      	adds	r1, #1

		// check for "\r\n" sequence in the string
		if ((message.status == RX_STATUS_HAD_CR) && (c == '\n'))
 8000a68:	2801      	cmp	r0, #1
	static struct _RxMessage message;

	while (USARTx_SR_RXNE_bb(USARTx))		// loop while data is available
	{
		char c = USARTx->DR;
		message.string[message.length++] = c;	// get char to buffer
 8000a6a:	6019      	str	r1, [r3, #0]

		// check for "\r\n" sequence in the string
		if ((message.status == RX_STATUS_HAD_CR) && (c == '\n'))
 8000a6c:	d103      	bne.n	8000a76 <USART1_IRQHandler+0x36>
 8000a6e:	2a0a      	cmp	r2, #10
 8000a70:	d101      	bne.n	8000a76 <USART1_IRQHandler+0x36>
			message.status = RX_STATUS_HAD_CR_LF;
 8000a72:	2202      	movs	r2, #2
 8000a74:	e004      	b.n	8000a80 <USART1_IRQHandler+0x40>
		else if (c == '\r')
 8000a76:	2a0d      	cmp	r2, #13
 8000a78:	d101      	bne.n	8000a7e <USART1_IRQHandler+0x3e>
			message.status = RX_STATUS_HAD_CR;
 8000a7a:	2201      	movs	r2, #1
 8000a7c:	e000      	b.n	8000a80 <USART1_IRQHandler+0x40>
		else
			message.status = RX_STATUS_HAD_NONE;
 8000a7e:	2200      	movs	r2, #0

		// transfer block only if out of space or "\r\n" sequence was found
		if ((message.length >= USARTx_RX_QUEUE_BUFFER_LENGTH)
 8000a80:	290f      	cmp	r1, #15
		if ((message.status == RX_STATUS_HAD_CR) && (c == '\n'))
			message.status = RX_STATUS_HAD_CR_LF;
		else if (c == '\r')
			message.status = RX_STATUS_HAD_CR;
		else
			message.status = RX_STATUS_HAD_NONE;
 8000a82:	711a      	strb	r2, [r3, #4]

		// transfer block only if out of space or "\r\n" sequence was found
		if ((message.length >= USARTx_RX_QUEUE_BUFFER_LENGTH)
 8000a84:	d802      	bhi.n	8000a8c <USART1_IRQHandler+0x4c>
 8000a86:	791b      	ldrb	r3, [r3, #4]
 8000a88:	2b02      	cmp	r3, #2
 8000a8a:	d1e1      	bne.n	8000a50 <USART1_IRQHandler+0x10>
				|| (message.status == RX_STATUS_HAD_CR_LF)) {
			xQueueSendFromISR(_rxQueue, &message, &higher_priority_task_woken);
 8000a8c:	4c0d      	ldr	r4, [pc, #52]	; (8000ac4 <USART1_IRQHandler+0x84>)
 8000a8e:	490e      	ldr	r1, [pc, #56]	; (8000ac8 <USART1_IRQHandler+0x88>)
 8000a90:	aa01      	add	r2, sp, #4
 8000a92:	6808      	ldr	r0, [r1, #0]
 8000a94:	2300      	movs	r3, #0
 8000a96:	4621      	mov	r1, r4
 8000a98:	f7ff fc04 	bl	80002a4 <xQueueGenericSendFromISR>

			message.length = 0;

			if (message.status == RX_STATUS_HAD_CR_LF)
 8000a9c:	7922      	ldrb	r2, [r4, #4]
		// transfer block only if out of space or "\r\n" sequence was found
		if ((message.length >= USARTx_RX_QUEUE_BUFFER_LENGTH)
				|| (message.status == RX_STATUS_HAD_CR_LF)) {
			xQueueSendFromISR(_rxQueue, &message, &higher_priority_task_woken);

			message.length = 0;
 8000a9e:	2000      	movs	r0, #0

			if (message.status == RX_STATUS_HAD_CR_LF)
 8000aa0:	2a02      	cmp	r2, #2
		// transfer block only if out of space or "\r\n" sequence was found
		if ((message.length >= USARTx_RX_QUEUE_BUFFER_LENGTH)
				|| (message.status == RX_STATUS_HAD_CR_LF)) {
			xQueueSendFromISR(_rxQueue, &message, &higher_priority_task_woken);

			message.length = 0;
 8000aa2:	6020      	str	r0, [r4, #0]

			if (message.status == RX_STATUS_HAD_CR_LF)
				message.status = RX_STATUS_HAD_NONE;
 8000aa4:	bf08      	it	eq
 8000aa6:	7120      	strbeq	r0, [r4, #4]
 8000aa8:	e7d2      	b.n	8000a50 <USART1_IRQHandler+0x10>
		}
	}

	portEND_SWITCHING_ISR(higher_priority_task_woken);
 8000aaa:	9901      	ldr	r1, [sp, #4]
 8000aac:	b109      	cbz	r1, 8000ab2 <USART1_IRQHandler+0x72>
 8000aae:	f7ff fd9d 	bl	80005ec <vPortYieldFromISR>
}
 8000ab2:	b003      	add	sp, #12
 8000ab4:	e8bd 4011 	ldmia.w	sp!, {r0, r4, lr}
 8000ab8:	4685      	mov	sp, r0
 8000aba:	4770      	bx	lr
 8000abc:	42270014 	.word	0x42270014
 8000ac0:	40013800 	.word	0x40013800
 8000ac4:	20000928 	.word	0x20000928
 8000ac8:	20000924 	.word	0x20000924

08000acc <__aeabi_atexit>:
 8000acc:	4603      	mov	r3, r0
 8000ace:	4608      	mov	r0, r1
 8000ad0:	4619      	mov	r1, r3
 8000ad2:	f000 b85f 	b.w	8000b94 <__cxa_atexit>
 8000ad6:	bf00      	nop

08000ad8 <std::__detail::_List_node_base::_M_hook(std::__detail::_List_node_base*)>:
 8000ad8:	684b      	ldr	r3, [r1, #4]
 8000ada:	6001      	str	r1, [r0, #0]
 8000adc:	6043      	str	r3, [r0, #4]
 8000ade:	684a      	ldr	r2, [r1, #4]
 8000ae0:	6048      	str	r0, [r1, #4]
 8000ae2:	6010      	str	r0, [r2, #0]
 8000ae4:	4770      	bx	lr
 8000ae6:	bf00      	nop

08000ae8 <__register_exitproc>:
 8000ae8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000aec:	4c27      	ldr	r4, [pc, #156]	; (8000b8c <__register_exitproc+0xa4>)
 8000aee:	b084      	sub	sp, #16
 8000af0:	6825      	ldr	r5, [r4, #0]
 8000af2:	4607      	mov	r7, r0
 8000af4:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
 8000af8:	2c00      	cmp	r4, #0
 8000afa:	d041      	beq.n	8000b80 <__register_exitproc+0x98>
 8000afc:	6866      	ldr	r6, [r4, #4]
 8000afe:	2e1f      	cmp	r6, #31
 8000b00:	dd1c      	ble.n	8000b3c <__register_exitproc+0x54>
 8000b02:	4823      	ldr	r0, [pc, #140]	; (8000b90 <__register_exitproc+0xa8>)
 8000b04:	b910      	cbnz	r0, 8000b0c <__register_exitproc+0x24>
 8000b06:	f04f 30ff 	mov.w	r0, #4294967295
 8000b0a:	e01f      	b.n	8000b4c <__register_exitproc+0x64>
 8000b0c:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8000b10:	9103      	str	r1, [sp, #12]
 8000b12:	9202      	str	r2, [sp, #8]
 8000b14:	9301      	str	r3, [sp, #4]
 8000b16:	f000 f8b9 	bl	8000c8c <malloc>
 8000b1a:	9903      	ldr	r1, [sp, #12]
 8000b1c:	4604      	mov	r4, r0
 8000b1e:	9a02      	ldr	r2, [sp, #8]
 8000b20:	9b01      	ldr	r3, [sp, #4]
 8000b22:	2800      	cmp	r0, #0
 8000b24:	d0ef      	beq.n	8000b06 <__register_exitproc+0x1e>
 8000b26:	f8d5 6148 	ldr.w	r6, [r5, #328]	; 0x148
 8000b2a:	2000      	movs	r0, #0
 8000b2c:	6060      	str	r0, [r4, #4]
 8000b2e:	6026      	str	r6, [r4, #0]
 8000b30:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
 8000b34:	f8c4 0188 	str.w	r0, [r4, #392]	; 0x188
 8000b38:	f8c4 018c 	str.w	r0, [r4, #396]	; 0x18c
 8000b3c:	6865      	ldr	r5, [r4, #4]
 8000b3e:	b947      	cbnz	r7, 8000b52 <__register_exitproc+0x6a>
 8000b40:	1ca8      	adds	r0, r5, #2
 8000b42:	3501      	adds	r5, #1
 8000b44:	f844 1020 	str.w	r1, [r4, r0, lsl #2]
 8000b48:	6065      	str	r5, [r4, #4]
 8000b4a:	2000      	movs	r0, #0
 8000b4c:	b004      	add	sp, #16
 8000b4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000b52:	2001      	movs	r0, #1
 8000b54:	fa00 f005 	lsl.w	r0, r0, r5
 8000b58:	f8d4 6188 	ldr.w	r6, [r4, #392]	; 0x188
 8000b5c:	eb04 0885 	add.w	r8, r4, r5, lsl #2
 8000b60:	4306      	orrs	r6, r0
 8000b62:	2f02      	cmp	r7, #2
 8000b64:	f8c8 2088 	str.w	r2, [r8, #136]	; 0x88
 8000b68:	f8c4 6188 	str.w	r6, [r4, #392]	; 0x188
 8000b6c:	f8c8 3108 	str.w	r3, [r8, #264]	; 0x108
 8000b70:	d1e6      	bne.n	8000b40 <__register_exitproc+0x58>
 8000b72:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
 8000b76:	ea43 0200 	orr.w	r2, r3, r0
 8000b7a:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
 8000b7e:	e7df      	b.n	8000b40 <__register_exitproc+0x58>
 8000b80:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
 8000b84:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
 8000b88:	e7b8      	b.n	8000afc <__register_exitproc+0x14>
 8000b8a:	bf00      	nop
 8000b8c:	08001640 	.word	0x08001640
 8000b90:	08000c8d 	.word	0x08000c8d

08000b94 <__cxa_atexit>:
 8000b94:	b430      	push	{r4, r5}
 8000b96:	4605      	mov	r5, r0
 8000b98:	460c      	mov	r4, r1
 8000b9a:	4613      	mov	r3, r2
 8000b9c:	2002      	movs	r0, #2
 8000b9e:	4629      	mov	r1, r5
 8000ba0:	4622      	mov	r2, r4
 8000ba2:	bc30      	pop	{r4, r5}
 8000ba4:	f7ff bfa0 	b.w	8000ae8 <__register_exitproc>

08000ba8 <__libc_fini_array>:
 8000ba8:	4b11      	ldr	r3, [pc, #68]	; (8000bf0 <__libc_fini_array+0x48>)
 8000baa:	4a12      	ldr	r2, [pc, #72]	; (8000bf4 <__libc_fini_array+0x4c>)
 8000bac:	b570      	push	{r4, r5, r6, lr}
 8000bae:	1a98      	subs	r0, r3, r2
 8000bb0:	1083      	asrs	r3, r0, #2
 8000bb2:	d018      	beq.n	8000be6 <__libc_fini_array+0x3e>
 8000bb4:	1e59      	subs	r1, r3, #1
 8000bb6:	eb02 0483 	add.w	r4, r2, r3, lsl #2
 8000bba:	460d      	mov	r5, r1
 8000bbc:	f854 2d04 	ldr.w	r2, [r4, #-4]!
 8000bc0:	f001 0601 	and.w	r6, r1, #1
 8000bc4:	4790      	blx	r2
 8000bc6:	b175      	cbz	r5, 8000be6 <__libc_fini_array+0x3e>
 8000bc8:	b126      	cbz	r6, 8000bd4 <__libc_fini_array+0x2c>
 8000bca:	f854 0d04 	ldr.w	r0, [r4, #-4]!
 8000bce:	4780      	blx	r0
 8000bd0:	3d01      	subs	r5, #1
 8000bd2:	d008      	beq.n	8000be6 <__libc_fini_array+0x3e>
 8000bd4:	f854 3d04 	ldr.w	r3, [r4, #-4]!
 8000bd8:	4798      	blx	r3
 8000bda:	3d01      	subs	r5, #1
 8000bdc:	f854 1d04 	ldr.w	r1, [r4, #-4]!
 8000be0:	4788      	blx	r1
 8000be2:	3d01      	subs	r5, #1
 8000be4:	d1f6      	bne.n	8000bd4 <__libc_fini_array+0x2c>
 8000be6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8000bea:	f000 bd43 	b.w	8001674 <_fini>
 8000bee:	bf00      	nop
 8000bf0:	08001684 	.word	0x08001684
 8000bf4:	08001680 	.word	0x08001680

08000bf8 <__libc_init_array>:
 8000bf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000bfa:	4f20      	ldr	r7, [pc, #128]	; (8000c7c <__libc_init_array+0x84>)
 8000bfc:	4c20      	ldr	r4, [pc, #128]	; (8000c80 <__libc_init_array+0x88>)
 8000bfe:	1b38      	subs	r0, r7, r4
 8000c00:	1087      	asrs	r7, r0, #2
 8000c02:	d017      	beq.n	8000c34 <__libc_init_array+0x3c>
 8000c04:	1e7a      	subs	r2, r7, #1
 8000c06:	6823      	ldr	r3, [r4, #0]
 8000c08:	2501      	movs	r5, #1
 8000c0a:	f002 0601 	and.w	r6, r2, #1
 8000c0e:	4798      	blx	r3
 8000c10:	42af      	cmp	r7, r5
 8000c12:	d00f      	beq.n	8000c34 <__libc_init_array+0x3c>
 8000c14:	b12e      	cbz	r6, 8000c22 <__libc_init_array+0x2a>
 8000c16:	f854 1f04 	ldr.w	r1, [r4, #4]!
 8000c1a:	2502      	movs	r5, #2
 8000c1c:	4788      	blx	r1
 8000c1e:	42af      	cmp	r7, r5
 8000c20:	d008      	beq.n	8000c34 <__libc_init_array+0x3c>
 8000c22:	6860      	ldr	r0, [r4, #4]
 8000c24:	4780      	blx	r0
 8000c26:	3502      	adds	r5, #2
 8000c28:	68a2      	ldr	r2, [r4, #8]
 8000c2a:	1d26      	adds	r6, r4, #4
 8000c2c:	4790      	blx	r2
 8000c2e:	3408      	adds	r4, #8
 8000c30:	42af      	cmp	r7, r5
 8000c32:	d1f6      	bne.n	8000c22 <__libc_init_array+0x2a>
 8000c34:	4f13      	ldr	r7, [pc, #76]	; (8000c84 <__libc_init_array+0x8c>)
 8000c36:	4c14      	ldr	r4, [pc, #80]	; (8000c88 <__libc_init_array+0x90>)
 8000c38:	f000 fd0e 	bl	8001658 <_init>
 8000c3c:	1b3b      	subs	r3, r7, r4
 8000c3e:	109f      	asrs	r7, r3, #2
 8000c40:	d018      	beq.n	8000c74 <__libc_init_array+0x7c>
 8000c42:	1e7d      	subs	r5, r7, #1
 8000c44:	6821      	ldr	r1, [r4, #0]
 8000c46:	f005 0601 	and.w	r6, r5, #1
 8000c4a:	2501      	movs	r5, #1
 8000c4c:	4788      	blx	r1
 8000c4e:	42af      	cmp	r7, r5
 8000c50:	d011      	beq.n	8000c76 <__libc_init_array+0x7e>
 8000c52:	b12e      	cbz	r6, 8000c60 <__libc_init_array+0x68>
 8000c54:	f854 0f04 	ldr.w	r0, [r4, #4]!
 8000c58:	2502      	movs	r5, #2
 8000c5a:	4780      	blx	r0
 8000c5c:	42af      	cmp	r7, r5
 8000c5e:	d00b      	beq.n	8000c78 <__libc_init_array+0x80>
 8000c60:	6862      	ldr	r2, [r4, #4]
 8000c62:	4790      	blx	r2
 8000c64:	3502      	adds	r5, #2
 8000c66:	68a3      	ldr	r3, [r4, #8]
 8000c68:	1d26      	adds	r6, r4, #4
 8000c6a:	4798      	blx	r3
 8000c6c:	3408      	adds	r4, #8
 8000c6e:	42af      	cmp	r7, r5
 8000c70:	d1f6      	bne.n	8000c60 <__libc_init_array+0x68>
 8000c72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000c74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000c76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000c78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000c7a:	bf00      	nop
 8000c7c:	08001664 	.word	0x08001664
 8000c80:	08001664 	.word	0x08001664
 8000c84:	08001674 	.word	0x08001674
 8000c88:	08001664 	.word	0x08001664

08000c8c <malloc>:
 8000c8c:	f240 4340 	movw	r3, #1088	; 0x440
 8000c90:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c94:	4601      	mov	r1, r0
 8000c96:	6818      	ldr	r0, [r3, #0]
 8000c98:	f000 b808 	b.w	8000cac <_malloc_r>

08000c9c <free>:
 8000c9c:	f240 4340 	movw	r3, #1088	; 0x440
 8000ca0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000ca4:	4601      	mov	r1, r0
 8000ca6:	6818      	ldr	r0, [r3, #0]
 8000ca8:	f000 bbd6 	b.w	8001458 <_free_r>

08000cac <_malloc_r>:
 8000cac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000cb0:	f101 050b 	add.w	r5, r1, #11
 8000cb4:	2d16      	cmp	r5, #22
 8000cb6:	b083      	sub	sp, #12
 8000cb8:	4606      	mov	r6, r0
 8000cba:	d927      	bls.n	8000d0c <_malloc_r+0x60>
 8000cbc:	f035 0507 	bics.w	r5, r5, #7
 8000cc0:	d427      	bmi.n	8000d12 <_malloc_r+0x66>
 8000cc2:	42a9      	cmp	r1, r5
 8000cc4:	d825      	bhi.n	8000d12 <_malloc_r+0x66>
 8000cc6:	4630      	mov	r0, r6
 8000cc8:	f000 fb36 	bl	8001338 <__malloc_lock>
 8000ccc:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
 8000cd0:	d223      	bcs.n	8000d1a <_malloc_r+0x6e>
 8000cd2:	4fb9      	ldr	r7, [pc, #740]	; (8000fb8 <_malloc_r+0x30c>)
 8000cd4:	ea4f 0cd5 	mov.w	ip, r5, lsr #3
 8000cd8:	eb07 02cc 	add.w	r2, r7, ip, lsl #3
 8000cdc:	68d4      	ldr	r4, [r2, #12]
 8000cde:	4294      	cmp	r4, r2
 8000ce0:	f000 81d8 	beq.w	8001094 <_malloc_r+0x3e8>
 8000ce4:	6863      	ldr	r3, [r4, #4]
 8000ce6:	68e2      	ldr	r2, [r4, #12]
 8000ce8:	f023 0103 	bic.w	r1, r3, #3
 8000cec:	1863      	adds	r3, r4, r1
 8000cee:	6858      	ldr	r0, [r3, #4]
 8000cf0:	68a1      	ldr	r1, [r4, #8]
 8000cf2:	f040 0001 	orr.w	r0, r0, #1
 8000cf6:	6058      	str	r0, [r3, #4]
 8000cf8:	60ca      	str	r2, [r1, #12]
 8000cfa:	6091      	str	r1, [r2, #8]
 8000cfc:	4630      	mov	r0, r6
 8000cfe:	f000 fb1d 	bl	800133c <__malloc_unlock>
 8000d02:	3408      	adds	r4, #8
 8000d04:	4620      	mov	r0, r4
 8000d06:	b003      	add	sp, #12
 8000d08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000d0c:	2510      	movs	r5, #16
 8000d0e:	42a9      	cmp	r1, r5
 8000d10:	d9d9      	bls.n	8000cc6 <_malloc_r+0x1a>
 8000d12:	240c      	movs	r4, #12
 8000d14:	6034      	str	r4, [r6, #0]
 8000d16:	2400      	movs	r4, #0
 8000d18:	e7f4      	b.n	8000d04 <_malloc_r+0x58>
 8000d1a:	ea5f 2c55 	movs.w	ip, r5, lsr #9
 8000d1e:	f000 8089 	beq.w	8000e34 <_malloc_r+0x188>
 8000d22:	f1bc 0f04 	cmp.w	ip, #4
 8000d26:	f200 8153 	bhi.w	8000fd0 <_malloc_r+0x324>
 8000d2a:	ea4f 1795 	mov.w	r7, r5, lsr #6
 8000d2e:	f107 0e38 	add.w	lr, r7, #56	; 0x38
 8000d32:	ea4f 014e 	mov.w	r1, lr, lsl #1
 8000d36:	4fa0      	ldr	r7, [pc, #640]	; (8000fb8 <_malloc_r+0x30c>)
 8000d38:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 8000d3c:	68cc      	ldr	r4, [r1, #12]
 8000d3e:	42a1      	cmp	r1, r4
 8000d40:	d105      	bne.n	8000d4e <_malloc_r+0xa2>
 8000d42:	e00c      	b.n	8000d5e <_malloc_r+0xb2>
 8000d44:	2a00      	cmp	r2, #0
 8000d46:	da7a      	bge.n	8000e3e <_malloc_r+0x192>
 8000d48:	68e4      	ldr	r4, [r4, #12]
 8000d4a:	42a1      	cmp	r1, r4
 8000d4c:	d007      	beq.n	8000d5e <_malloc_r+0xb2>
 8000d4e:	6863      	ldr	r3, [r4, #4]
 8000d50:	f023 0003 	bic.w	r0, r3, #3
 8000d54:	1b42      	subs	r2, r0, r5
 8000d56:	2a0f      	cmp	r2, #15
 8000d58:	ddf4      	ble.n	8000d44 <_malloc_r+0x98>
 8000d5a:	f10e 3eff 	add.w	lr, lr, #4294967295
 8000d5e:	f10e 0c01 	add.w	ip, lr, #1
 8000d62:	4b95      	ldr	r3, [pc, #596]	; (8000fb8 <_malloc_r+0x30c>)
 8000d64:	693c      	ldr	r4, [r7, #16]
 8000d66:	f103 0e08 	add.w	lr, r3, #8
 8000d6a:	4574      	cmp	r4, lr
 8000d6c:	f000 8170 	beq.w	8001050 <_malloc_r+0x3a4>
 8000d70:	6861      	ldr	r1, [r4, #4]
 8000d72:	f021 0103 	bic.w	r1, r1, #3
 8000d76:	1b4a      	subs	r2, r1, r5
 8000d78:	2a0f      	cmp	r2, #15
 8000d7a:	f300 8156 	bgt.w	800102a <_malloc_r+0x37e>
 8000d7e:	2a00      	cmp	r2, #0
 8000d80:	f8c3 e014 	str.w	lr, [r3, #20]
 8000d84:	f8c3 e010 	str.w	lr, [r3, #16]
 8000d88:	da67      	bge.n	8000e5a <_malloc_r+0x1ae>
 8000d8a:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8000d8e:	f080 812d 	bcs.w	8000fec <_malloc_r+0x340>
 8000d92:	08c9      	lsrs	r1, r1, #3
 8000d94:	1088      	asrs	r0, r1, #2
 8000d96:	f04f 0801 	mov.w	r8, #1
 8000d9a:	fa08 f800 	lsl.w	r8, r8, r0
 8000d9e:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 8000da2:	685a      	ldr	r2, [r3, #4]
 8000da4:	6888      	ldr	r0, [r1, #8]
 8000da6:	ea48 0202 	orr.w	r2, r8, r2
 8000daa:	60e1      	str	r1, [r4, #12]
 8000dac:	60a0      	str	r0, [r4, #8]
 8000dae:	605a      	str	r2, [r3, #4]
 8000db0:	608c      	str	r4, [r1, #8]
 8000db2:	60c4      	str	r4, [r0, #12]
 8000db4:	2001      	movs	r0, #1
 8000db6:	ea4f 04ac 	mov.w	r4, ip, asr #2
 8000dba:	fa00 f004 	lsl.w	r0, r0, r4
 8000dbe:	4290      	cmp	r0, r2
 8000dc0:	d855      	bhi.n	8000e6e <_malloc_r+0x1c2>
 8000dc2:	4202      	tst	r2, r0
 8000dc4:	d106      	bne.n	8000dd4 <_malloc_r+0x128>
 8000dc6:	f02c 0c03 	bic.w	ip, ip, #3
 8000dca:	0040      	lsls	r0, r0, #1
 8000dcc:	4202      	tst	r2, r0
 8000dce:	f10c 0c04 	add.w	ip, ip, #4
 8000dd2:	d0fa      	beq.n	8000dca <_malloc_r+0x11e>
 8000dd4:	eb07 09cc 	add.w	r9, r7, ip, lsl #3
 8000dd8:	464c      	mov	r4, r9
 8000dda:	46e0      	mov	r8, ip
 8000ddc:	68e3      	ldr	r3, [r4, #12]
 8000dde:	429c      	cmp	r4, r3
 8000de0:	d107      	bne.n	8000df2 <_malloc_r+0x146>
 8000de2:	e137      	b.n	8001054 <_malloc_r+0x3a8>
 8000de4:	2a00      	cmp	r2, #0
 8000de6:	f280 815f 	bge.w	80010a8 <_malloc_r+0x3fc>
 8000dea:	68db      	ldr	r3, [r3, #12]
 8000dec:	429c      	cmp	r4, r3
 8000dee:	f000 8131 	beq.w	8001054 <_malloc_r+0x3a8>
 8000df2:	6859      	ldr	r1, [r3, #4]
 8000df4:	f021 0103 	bic.w	r1, r1, #3
 8000df8:	1b4a      	subs	r2, r1, r5
 8000dfa:	2a0f      	cmp	r2, #15
 8000dfc:	ddf2      	ble.n	8000de4 <_malloc_r+0x138>
 8000dfe:	461c      	mov	r4, r3
 8000e00:	68d8      	ldr	r0, [r3, #12]
 8000e02:	f854 cf08 	ldr.w	ip, [r4, #8]!
 8000e06:	1959      	adds	r1, r3, r5
 8000e08:	f045 0801 	orr.w	r8, r5, #1
 8000e0c:	f042 0501 	orr.w	r5, r2, #1
 8000e10:	f8cc 000c 	str.w	r0, [ip, #12]
 8000e14:	f8c0 c008 	str.w	ip, [r0, #8]
 8000e18:	f8c3 8004 	str.w	r8, [r3, #4]
 8000e1c:	6179      	str	r1, [r7, #20]
 8000e1e:	6139      	str	r1, [r7, #16]
 8000e20:	f8c1 e00c 	str.w	lr, [r1, #12]
 8000e24:	f8c1 e008 	str.w	lr, [r1, #8]
 8000e28:	604d      	str	r5, [r1, #4]
 8000e2a:	508a      	str	r2, [r1, r2]
 8000e2c:	4630      	mov	r0, r6
 8000e2e:	f000 fa85 	bl	800133c <__malloc_unlock>
 8000e32:	e767      	b.n	8000d04 <_malloc_r+0x58>
 8000e34:	ea4f 0ed5 	mov.w	lr, r5, lsr #3
 8000e38:	ea4f 014e 	mov.w	r1, lr, lsl #1
 8000e3c:	e77b      	b.n	8000d36 <_malloc_r+0x8a>
 8000e3e:	1822      	adds	r2, r4, r0
 8000e40:	6850      	ldr	r0, [r2, #4]
 8000e42:	68e3      	ldr	r3, [r4, #12]
 8000e44:	68a1      	ldr	r1, [r4, #8]
 8000e46:	f040 0001 	orr.w	r0, r0, #1
 8000e4a:	6050      	str	r0, [r2, #4]
 8000e4c:	60cb      	str	r3, [r1, #12]
 8000e4e:	6099      	str	r1, [r3, #8]
 8000e50:	4630      	mov	r0, r6
 8000e52:	f000 fa73 	bl	800133c <__malloc_unlock>
 8000e56:	3408      	adds	r4, #8
 8000e58:	e754      	b.n	8000d04 <_malloc_r+0x58>
 8000e5a:	1862      	adds	r2, r4, r1
 8000e5c:	6853      	ldr	r3, [r2, #4]
 8000e5e:	4630      	mov	r0, r6
 8000e60:	f043 0101 	orr.w	r1, r3, #1
 8000e64:	6051      	str	r1, [r2, #4]
 8000e66:	f000 fa69 	bl	800133c <__malloc_unlock>
 8000e6a:	3408      	adds	r4, #8
 8000e6c:	e74a      	b.n	8000d04 <_malloc_r+0x58>
 8000e6e:	68bc      	ldr	r4, [r7, #8]
 8000e70:	6860      	ldr	r0, [r4, #4]
 8000e72:	f020 0903 	bic.w	r9, r0, #3
 8000e76:	45a9      	cmp	r9, r5
 8000e78:	d304      	bcc.n	8000e84 <_malloc_r+0x1d8>
 8000e7a:	ebc5 0309 	rsb	r3, r5, r9
 8000e7e:	2b0f      	cmp	r3, #15
 8000e80:	f300 808d 	bgt.w	8000f9e <_malloc_r+0x2f2>
 8000e84:	4a4d      	ldr	r2, [pc, #308]	; (8000fbc <_malloc_r+0x310>)
 8000e86:	4b4e      	ldr	r3, [pc, #312]	; (8000fc0 <_malloc_r+0x314>)
 8000e88:	6811      	ldr	r1, [r2, #0]
 8000e8a:	6818      	ldr	r0, [r3, #0]
 8000e8c:	3101      	adds	r1, #1
 8000e8e:	eb04 0b09 	add.w	fp, r4, r9
 8000e92:	eb05 0300 	add.w	r3, r5, r0
 8000e96:	f000 8151 	beq.w	800113c <_malloc_r+0x490>
 8000e9a:	f503 5080 	add.w	r0, r3, #4096	; 0x1000
 8000e9e:	300f      	adds	r0, #15
 8000ea0:	f420 617f 	bic.w	r1, r0, #4080	; 0xff0
 8000ea4:	f021 0c0f 	bic.w	ip, r1, #15
 8000ea8:	4661      	mov	r1, ip
 8000eaa:	4630      	mov	r0, r6
 8000eac:	e88d 1004 	stmia.w	sp, {r2, ip}
 8000eb0:	f7ff f996 	bl	80001e0 <_sbrk_r>
 8000eb4:	e89d 1004 	ldmia.w	sp, {r2, ip}
 8000eb8:	f1b0 3fff 	cmp.w	r0, #4294967295
 8000ebc:	4680      	mov	r8, r0
 8000ebe:	f000 8146 	beq.w	800114e <_malloc_r+0x4a2>
 8000ec2:	4583      	cmp	fp, r0
 8000ec4:	f200 8108 	bhi.w	80010d8 <_malloc_r+0x42c>
 8000ec8:	f8df a100 	ldr.w	sl, [pc, #256]	; 8000fcc <_malloc_r+0x320>
 8000ecc:	45c3      	cmp	fp, r8
 8000ece:	f8da 3000 	ldr.w	r3, [sl]
 8000ed2:	4463      	add	r3, ip
 8000ed4:	f8ca 3000 	str.w	r3, [sl]
 8000ed8:	f000 813e 	beq.w	8001158 <_malloc_r+0x4ac>
 8000edc:	6812      	ldr	r2, [r2, #0]
 8000ede:	3201      	adds	r2, #1
 8000ee0:	f000 814b 	beq.w	800117a <_malloc_r+0x4ce>
 8000ee4:	ebcb 0b08 	rsb	fp, fp, r8
 8000ee8:	445b      	add	r3, fp
 8000eea:	f8ca 3000 	str.w	r3, [sl]
 8000eee:	f018 0107 	ands.w	r1, r8, #7
 8000ef2:	f000 8104 	beq.w	80010fe <_malloc_r+0x452>
 8000ef6:	f1c1 0008 	rsb	r0, r1, #8
 8000efa:	f5c1 5380 	rsb	r3, r1, #4096	; 0x1000
 8000efe:	4480      	add	r8, r0
 8000f00:	f103 0208 	add.w	r2, r3, #8
 8000f04:	eb08 010c 	add.w	r1, r8, ip
 8000f08:	0508      	lsls	r0, r1, #20
 8000f0a:	0d03      	lsrs	r3, r0, #20
 8000f0c:	ebc3 0b02 	rsb	fp, r3, r2
 8000f10:	4630      	mov	r0, r6
 8000f12:	4659      	mov	r1, fp
 8000f14:	f7ff f964 	bl	80001e0 <_sbrk_r>
 8000f18:	1c43      	adds	r3, r0, #1
 8000f1a:	f000 813a 	beq.w	8001192 <_malloc_r+0x4e6>
 8000f1e:	ebc8 0200 	rsb	r2, r8, r0
 8000f22:	eb0b 0102 	add.w	r1, fp, r2
 8000f26:	f041 0001 	orr.w	r0, r1, #1
 8000f2a:	f8da 3000 	ldr.w	r3, [sl]
 8000f2e:	42bc      	cmp	r4, r7
 8000f30:	445b      	add	r3, fp
 8000f32:	f8c7 8008 	str.w	r8, [r7, #8]
 8000f36:	f8ca 3000 	str.w	r3, [sl]
 8000f3a:	f8c8 0004 	str.w	r0, [r8, #4]
 8000f3e:	d015      	beq.n	8000f6c <_malloc_r+0x2c0>
 8000f40:	f1b9 0f0f 	cmp.w	r9, #15
 8000f44:	f240 80e9 	bls.w	800111a <_malloc_r+0x46e>
 8000f48:	6861      	ldr	r1, [r4, #4]
 8000f4a:	f1a9 020c 	sub.w	r2, r9, #12
 8000f4e:	f022 0207 	bic.w	r2, r2, #7
 8000f52:	f001 0c01 	and.w	ip, r1, #1
 8000f56:	2005      	movs	r0, #5
 8000f58:	18a1      	adds	r1, r4, r2
 8000f5a:	ea42 0e0c 	orr.w	lr, r2, ip
 8000f5e:	2a0f      	cmp	r2, #15
 8000f60:	f8c4 e004 	str.w	lr, [r4, #4]
 8000f64:	6048      	str	r0, [r1, #4]
 8000f66:	6088      	str	r0, [r1, #8]
 8000f68:	f200 810b 	bhi.w	8001182 <_malloc_r+0x4d6>
 8000f6c:	4a15      	ldr	r2, [pc, #84]	; (8000fc4 <_malloc_r+0x318>)
 8000f6e:	68bc      	ldr	r4, [r7, #8]
 8000f70:	6810      	ldr	r0, [r2, #0]
 8000f72:	4283      	cmp	r3, r0
 8000f74:	bf88      	it	hi
 8000f76:	6013      	strhi	r3, [r2, #0]
 8000f78:	4a13      	ldr	r2, [pc, #76]	; (8000fc8 <_malloc_r+0x31c>)
 8000f7a:	6811      	ldr	r1, [r2, #0]
 8000f7c:	428b      	cmp	r3, r1
 8000f7e:	bf88      	it	hi
 8000f80:	6013      	strhi	r3, [r2, #0]
 8000f82:	6863      	ldr	r3, [r4, #4]
 8000f84:	f023 0003 	bic.w	r0, r3, #3
 8000f88:	42a8      	cmp	r0, r5
 8000f8a:	ebc5 0300 	rsb	r3, r5, r0
 8000f8e:	d301      	bcc.n	8000f94 <_malloc_r+0x2e8>
 8000f90:	2b0f      	cmp	r3, #15
 8000f92:	dc04      	bgt.n	8000f9e <_malloc_r+0x2f2>
 8000f94:	4630      	mov	r0, r6
 8000f96:	f000 f9d1 	bl	800133c <__malloc_unlock>
 8000f9a:	2400      	movs	r4, #0
 8000f9c:	e6b2      	b.n	8000d04 <_malloc_r+0x58>
 8000f9e:	1962      	adds	r2, r4, r5
 8000fa0:	f043 0101 	orr.w	r1, r3, #1
 8000fa4:	f045 0501 	orr.w	r5, r5, #1
 8000fa8:	6065      	str	r5, [r4, #4]
 8000faa:	4630      	mov	r0, r6
 8000fac:	6051      	str	r1, [r2, #4]
 8000fae:	60ba      	str	r2, [r7, #8]
 8000fb0:	f000 f9c4 	bl	800133c <__malloc_unlock>
 8000fb4:	3408      	adds	r4, #8
 8000fb6:	e6a5      	b.n	8000d04 <_malloc_r+0x58>
 8000fb8:	20000444 	.word	0x20000444
 8000fbc:	20000850 	.word	0x20000850
 8000fc0:	2000094c 	.word	0x2000094c
 8000fc4:	20000948 	.word	0x20000948
 8000fc8:	20000944 	.word	0x20000944
 8000fcc:	20000950 	.word	0x20000950
 8000fd0:	f1bc 0f14 	cmp.w	ip, #20
 8000fd4:	d977      	bls.n	80010c6 <_malloc_r+0x41a>
 8000fd6:	f1bc 0f54 	cmp.w	ip, #84	; 0x54
 8000fda:	f200 8086 	bhi.w	80010ea <_malloc_r+0x43e>
 8000fde:	ea4f 3415 	mov.w	r4, r5, lsr #12
 8000fe2:	f104 0e6e 	add.w	lr, r4, #110	; 0x6e
 8000fe6:	ea4f 014e 	mov.w	r1, lr, lsl #1
 8000fea:	e6a4      	b.n	8000d36 <_malloc_r+0x8a>
 8000fec:	0a48      	lsrs	r0, r1, #9
 8000fee:	2804      	cmp	r0, #4
 8000ff0:	d96e      	bls.n	80010d0 <_malloc_r+0x424>
 8000ff2:	2814      	cmp	r0, #20
 8000ff4:	f200 80a5 	bhi.w	8001142 <_malloc_r+0x496>
 8000ff8:	f100 025b 	add.w	r2, r0, #91	; 0x5b
 8000ffc:	0050      	lsls	r0, r2, #1
 8000ffe:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 8001002:	6883      	ldr	r3, [r0, #8]
 8001004:	f8df 81c8 	ldr.w	r8, [pc, #456]	; 80011d0 <_malloc_r+0x524>
 8001008:	4283      	cmp	r3, r0
 800100a:	d07b      	beq.n	8001104 <_malloc_r+0x458>
 800100c:	685a      	ldr	r2, [r3, #4]
 800100e:	f022 0203 	bic.w	r2, r2, #3
 8001012:	4291      	cmp	r1, r2
 8001014:	d202      	bcs.n	800101c <_malloc_r+0x370>
 8001016:	689b      	ldr	r3, [r3, #8]
 8001018:	4298      	cmp	r0, r3
 800101a:	d1f7      	bne.n	800100c <_malloc_r+0x360>
 800101c:	68d9      	ldr	r1, [r3, #12]
 800101e:	687a      	ldr	r2, [r7, #4]
 8001020:	60e1      	str	r1, [r4, #12]
 8001022:	60a3      	str	r3, [r4, #8]
 8001024:	60dc      	str	r4, [r3, #12]
 8001026:	608c      	str	r4, [r1, #8]
 8001028:	e6c4      	b.n	8000db4 <_malloc_r+0x108>
 800102a:	1961      	adds	r1, r4, r5
 800102c:	f042 0001 	orr.w	r0, r2, #1
 8001030:	f045 0501 	orr.w	r5, r5, #1
 8001034:	6065      	str	r5, [r4, #4]
 8001036:	6159      	str	r1, [r3, #20]
 8001038:	6119      	str	r1, [r3, #16]
 800103a:	6048      	str	r0, [r1, #4]
 800103c:	f8c1 e00c 	str.w	lr, [r1, #12]
 8001040:	f8c1 e008 	str.w	lr, [r1, #8]
 8001044:	508a      	str	r2, [r1, r2]
 8001046:	4630      	mov	r0, r6
 8001048:	f000 f978 	bl	800133c <__malloc_unlock>
 800104c:	3408      	adds	r4, #8
 800104e:	e659      	b.n	8000d04 <_malloc_r+0x58>
 8001050:	685a      	ldr	r2, [r3, #4]
 8001052:	e6af      	b.n	8000db4 <_malloc_r+0x108>
 8001054:	f108 0801 	add.w	r8, r8, #1
 8001058:	3408      	adds	r4, #8
 800105a:	f018 0f03 	tst.w	r8, #3
 800105e:	f47f aebd 	bne.w	8000ddc <_malloc_r+0x130>
 8001062:	4649      	mov	r1, r9
 8001064:	f01c 0f03 	tst.w	ip, #3
 8001068:	f1a1 0408 	sub.w	r4, r1, #8
 800106c:	f10c 3cff 	add.w	ip, ip, #4294967295
 8001070:	f000 80a2 	beq.w	80011b8 <_malloc_r+0x50c>
 8001074:	6809      	ldr	r1, [r1, #0]
 8001076:	42a1      	cmp	r1, r4
 8001078:	d0f4      	beq.n	8001064 <_malloc_r+0x3b8>
 800107a:	687c      	ldr	r4, [r7, #4]
 800107c:	0040      	lsls	r0, r0, #1
 800107e:	42a0      	cmp	r0, r4
 8001080:	f63f aef5 	bhi.w	8000e6e <_malloc_r+0x1c2>
 8001084:	2800      	cmp	r0, #0
 8001086:	f43f aef2 	beq.w	8000e6e <_malloc_r+0x1c2>
 800108a:	4204      	tst	r4, r0
 800108c:	f000 8099 	beq.w	80011c2 <_malloc_r+0x516>
 8001090:	46c4      	mov	ip, r8
 8001092:	e69f      	b.n	8000dd4 <_malloc_r+0x128>
 8001094:	f104 0308 	add.w	r3, r4, #8
 8001098:	6964      	ldr	r4, [r4, #20]
 800109a:	42a3      	cmp	r3, r4
 800109c:	bf08      	it	eq
 800109e:	f10c 0c02 	addeq.w	ip, ip, #2
 80010a2:	f43f ae5e 	beq.w	8000d62 <_malloc_r+0xb6>
 80010a6:	e61d      	b.n	8000ce4 <_malloc_r+0x38>
 80010a8:	1859      	adds	r1, r3, r1
 80010aa:	6848      	ldr	r0, [r1, #4]
 80010ac:	461c      	mov	r4, r3
 80010ae:	f854 2f08 	ldr.w	r2, [r4, #8]!
 80010b2:	68db      	ldr	r3, [r3, #12]
 80010b4:	f040 0001 	orr.w	r0, r0, #1
 80010b8:	6048      	str	r0, [r1, #4]
 80010ba:	60d3      	str	r3, [r2, #12]
 80010bc:	609a      	str	r2, [r3, #8]
 80010be:	4630      	mov	r0, r6
 80010c0:	f000 f93c 	bl	800133c <__malloc_unlock>
 80010c4:	e61e      	b.n	8000d04 <_malloc_r+0x58>
 80010c6:	f10c 0e5b 	add.w	lr, ip, #91	; 0x5b
 80010ca:	ea4f 014e 	mov.w	r1, lr, lsl #1
 80010ce:	e632      	b.n	8000d36 <_malloc_r+0x8a>
 80010d0:	098a      	lsrs	r2, r1, #6
 80010d2:	3238      	adds	r2, #56	; 0x38
 80010d4:	0050      	lsls	r0, r2, #1
 80010d6:	e792      	b.n	8000ffe <_malloc_r+0x352>
 80010d8:	42bc      	cmp	r4, r7
 80010da:	f43f aef5 	beq.w	8000ec8 <_malloc_r+0x21c>
 80010de:	4c3c      	ldr	r4, [pc, #240]	; (80011d0 <_malloc_r+0x524>)
 80010e0:	68a4      	ldr	r4, [r4, #8]
 80010e2:	6862      	ldr	r2, [r4, #4]
 80010e4:	f022 0003 	bic.w	r0, r2, #3
 80010e8:	e74e      	b.n	8000f88 <_malloc_r+0x2dc>
 80010ea:	f5bc 7faa 	cmp.w	ip, #340	; 0x154
 80010ee:	d81a      	bhi.n	8001126 <_malloc_r+0x47a>
 80010f0:	ea4f 32d5 	mov.w	r2, r5, lsr #15
 80010f4:	f102 0e77 	add.w	lr, r2, #119	; 0x77
 80010f8:	ea4f 014e 	mov.w	r1, lr, lsl #1
 80010fc:	e61b      	b.n	8000d36 <_malloc_r+0x8a>
 80010fe:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8001102:	e6ff      	b.n	8000f04 <_malloc_r+0x258>
 8001104:	1091      	asrs	r1, r2, #2
 8001106:	2001      	movs	r0, #1
 8001108:	fa00 f001 	lsl.w	r0, r0, r1
 800110c:	f8d8 2004 	ldr.w	r2, [r8, #4]
 8001110:	4619      	mov	r1, r3
 8001112:	4302      	orrs	r2, r0
 8001114:	f8c8 2004 	str.w	r2, [r8, #4]
 8001118:	e782      	b.n	8001020 <_malloc_r+0x374>
 800111a:	2201      	movs	r2, #1
 800111c:	f8c8 2004 	str.w	r2, [r8, #4]
 8001120:	4644      	mov	r4, r8
 8001122:	2000      	movs	r0, #0
 8001124:	e730      	b.n	8000f88 <_malloc_r+0x2dc>
 8001126:	f240 5354 	movw	r3, #1364	; 0x554
 800112a:	459c      	cmp	ip, r3
 800112c:	d821      	bhi.n	8001172 <_malloc_r+0x4c6>
 800112e:	ea4f 4095 	mov.w	r0, r5, lsr #18
 8001132:	f100 0e7c 	add.w	lr, r0, #124	; 0x7c
 8001136:	ea4f 014e 	mov.w	r1, lr, lsl #1
 800113a:	e5fc      	b.n	8000d36 <_malloc_r+0x8a>
 800113c:	f103 0c10 	add.w	ip, r3, #16
 8001140:	e6b2      	b.n	8000ea8 <_malloc_r+0x1fc>
 8001142:	2854      	cmp	r0, #84	; 0x54
 8001144:	d829      	bhi.n	800119a <_malloc_r+0x4ee>
 8001146:	0b0a      	lsrs	r2, r1, #12
 8001148:	326e      	adds	r2, #110	; 0x6e
 800114a:	0050      	lsls	r0, r2, #1
 800114c:	e757      	b.n	8000ffe <_malloc_r+0x352>
 800114e:	68bc      	ldr	r4, [r7, #8]
 8001150:	6861      	ldr	r1, [r4, #4]
 8001152:	f021 0003 	bic.w	r0, r1, #3
 8001156:	e717      	b.n	8000f88 <_malloc_r+0x2dc>
 8001158:	ea4f 500b 	mov.w	r0, fp, lsl #20
 800115c:	0d01      	lsrs	r1, r0, #20
 800115e:	2900      	cmp	r1, #0
 8001160:	f47f aebc 	bne.w	8000edc <_malloc_r+0x230>
 8001164:	68b8      	ldr	r0, [r7, #8]
 8001166:	eb0c 0109 	add.w	r1, ip, r9
 800116a:	f041 0401 	orr.w	r4, r1, #1
 800116e:	6044      	str	r4, [r0, #4]
 8001170:	e6fc      	b.n	8000f6c <_malloc_r+0x2c0>
 8001172:	21fc      	movs	r1, #252	; 0xfc
 8001174:	f04f 0e7e 	mov.w	lr, #126	; 0x7e
 8001178:	e5dd      	b.n	8000d36 <_malloc_r+0x8a>
 800117a:	4816      	ldr	r0, [pc, #88]	; (80011d4 <_malloc_r+0x528>)
 800117c:	f8c0 8000 	str.w	r8, [r0]
 8001180:	e6b5      	b.n	8000eee <_malloc_r+0x242>
 8001182:	f104 0108 	add.w	r1, r4, #8
 8001186:	4c14      	ldr	r4, [pc, #80]	; (80011d8 <_malloc_r+0x52c>)
 8001188:	4630      	mov	r0, r6
 800118a:	f000 f965 	bl	8001458 <_free_r>
 800118e:	6823      	ldr	r3, [r4, #0]
 8001190:	e6ec      	b.n	8000f6c <_malloc_r+0x2c0>
 8001192:	2001      	movs	r0, #1
 8001194:	f04f 0b00 	mov.w	fp, #0
 8001198:	e6c7      	b.n	8000f2a <_malloc_r+0x27e>
 800119a:	f5b0 7faa 	cmp.w	r0, #340	; 0x154
 800119e:	d803      	bhi.n	80011a8 <_malloc_r+0x4fc>
 80011a0:	0bca      	lsrs	r2, r1, #15
 80011a2:	3277      	adds	r2, #119	; 0x77
 80011a4:	0050      	lsls	r0, r2, #1
 80011a6:	e72a      	b.n	8000ffe <_malloc_r+0x352>
 80011a8:	f240 5354 	movw	r3, #1364	; 0x554
 80011ac:	4298      	cmp	r0, r3
 80011ae:	d80c      	bhi.n	80011ca <_malloc_r+0x51e>
 80011b0:	0c8a      	lsrs	r2, r1, #18
 80011b2:	327c      	adds	r2, #124	; 0x7c
 80011b4:	0050      	lsls	r0, r2, #1
 80011b6:	e722      	b.n	8000ffe <_malloc_r+0x352>
 80011b8:	687c      	ldr	r4, [r7, #4]
 80011ba:	ea24 0400 	bic.w	r4, r4, r0
 80011be:	607c      	str	r4, [r7, #4]
 80011c0:	e75c      	b.n	800107c <_malloc_r+0x3d0>
 80011c2:	0040      	lsls	r0, r0, #1
 80011c4:	f108 0804 	add.w	r8, r8, #4
 80011c8:	e75f      	b.n	800108a <_malloc_r+0x3de>
 80011ca:	20fc      	movs	r0, #252	; 0xfc
 80011cc:	227e      	movs	r2, #126	; 0x7e
 80011ce:	e716      	b.n	8000ffe <_malloc_r+0x352>
 80011d0:	20000444 	.word	0x20000444
 80011d4:	20000850 	.word	0x20000850
 80011d8:	20000950 	.word	0x20000950

080011dc <memcpy>:
 80011dc:	2a0f      	cmp	r2, #15
 80011de:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 80011e2:	f240 80a1 	bls.w	8001328 <memcpy+0x14c>
 80011e6:	ea41 0300 	orr.w	r3, r1, r0
 80011ea:	079b      	lsls	r3, r3, #30
 80011ec:	f040 809e 	bne.w	800132c <memcpy+0x150>
 80011f0:	680c      	ldr	r4, [r1, #0]
 80011f2:	f1a2 0510 	sub.w	r5, r2, #16
 80011f6:	6004      	str	r4, [r0, #0]
 80011f8:	684b      	ldr	r3, [r1, #4]
 80011fa:	46ac      	mov	ip, r5
 80011fc:	6043      	str	r3, [r0, #4]
 80011fe:	688c      	ldr	r4, [r1, #8]
 8001200:	f1bc 0f0f 	cmp.w	ip, #15
 8001204:	6084      	str	r4, [r0, #8]
 8001206:	68cc      	ldr	r4, [r1, #12]
 8001208:	f3c5 1500 	ubfx	r5, r5, #4, #1
 800120c:	60c4      	str	r4, [r0, #12]
 800120e:	f100 0310 	add.w	r3, r0, #16
 8001212:	f101 0410 	add.w	r4, r1, #16
 8001216:	d92b      	bls.n	8001270 <memcpy+0x94>
 8001218:	b175      	cbz	r5, 8001238 <memcpy+0x5c>
 800121a:	6825      	ldr	r5, [r4, #0]
 800121c:	f1ac 0c10 	sub.w	ip, ip, #16
 8001220:	601d      	str	r5, [r3, #0]
 8001222:	6865      	ldr	r5, [r4, #4]
 8001224:	605d      	str	r5, [r3, #4]
 8001226:	68a5      	ldr	r5, [r4, #8]
 8001228:	609d      	str	r5, [r3, #8]
 800122a:	68e5      	ldr	r5, [r4, #12]
 800122c:	3410      	adds	r4, #16
 800122e:	60dd      	str	r5, [r3, #12]
 8001230:	3310      	adds	r3, #16
 8001232:	f1bc 0f0f 	cmp.w	ip, #15
 8001236:	d91b      	bls.n	8001270 <memcpy+0x94>
 8001238:	6827      	ldr	r7, [r4, #0]
 800123a:	f104 0610 	add.w	r6, r4, #16
 800123e:	601f      	str	r7, [r3, #0]
 8001240:	6867      	ldr	r7, [r4, #4]
 8001242:	f103 0510 	add.w	r5, r3, #16
 8001246:	605f      	str	r7, [r3, #4]
 8001248:	68a7      	ldr	r7, [r4, #8]
 800124a:	f1ac 0c20 	sub.w	ip, ip, #32
 800124e:	609f      	str	r7, [r3, #8]
 8001250:	68e7      	ldr	r7, [r4, #12]
 8001252:	60df      	str	r7, [r3, #12]
 8001254:	6924      	ldr	r4, [r4, #16]
 8001256:	611c      	str	r4, [r3, #16]
 8001258:	6877      	ldr	r7, [r6, #4]
 800125a:	f106 0410 	add.w	r4, r6, #16
 800125e:	606f      	str	r7, [r5, #4]
 8001260:	68b7      	ldr	r7, [r6, #8]
 8001262:	3320      	adds	r3, #32
 8001264:	60af      	str	r7, [r5, #8]
 8001266:	68f6      	ldr	r6, [r6, #12]
 8001268:	f1bc 0f0f 	cmp.w	ip, #15
 800126c:	60ee      	str	r6, [r5, #12]
 800126e:	d8e3      	bhi.n	8001238 <memcpy+0x5c>
 8001270:	f1a2 0810 	sub.w	r8, r2, #16
 8001274:	f028 030f 	bic.w	r3, r8, #15
 8001278:	f002 040f 	and.w	r4, r2, #15
 800127c:	f103 0c10 	add.w	ip, r3, #16
 8001280:	2c03      	cmp	r4, #3
 8001282:	eb00 030c 	add.w	r3, r0, ip
 8001286:	eb01 080c 	add.w	r8, r1, ip
 800128a:	d951      	bls.n	8001330 <memcpy+0x154>
 800128c:	1f21      	subs	r1, r4, #4
 800128e:	ea4f 0991 	mov.w	r9, r1, lsr #2
 8001292:	4644      	mov	r4, r8
 8001294:	eb08 0c89 	add.w	ip, r8, r9, lsl #2
 8001298:	f854 6b04 	ldr.w	r6, [r4], #4
 800129c:	ebc8 010c 	rsb	r1, r8, ip
 80012a0:	f10c 0c04 	add.w	ip, ip, #4
 80012a4:	461d      	mov	r5, r3
 80012a6:	4564      	cmp	r4, ip
 80012a8:	f845 6b04 	str.w	r6, [r5], #4
 80012ac:	f3c1 0180 	ubfx	r1, r1, #2, #1
 80012b0:	d012      	beq.n	80012d8 <memcpy+0xfc>
 80012b2:	b129      	cbz	r1, 80012c0 <memcpy+0xe4>
 80012b4:	f854 1b04 	ldr.w	r1, [r4], #4
 80012b8:	4564      	cmp	r4, ip
 80012ba:	f845 1b04 	str.w	r1, [r5], #4
 80012be:	d00b      	beq.n	80012d8 <memcpy+0xfc>
 80012c0:	4627      	mov	r7, r4
 80012c2:	f857 1b04 	ldr.w	r1, [r7], #4
 80012c6:	462e      	mov	r6, r5
 80012c8:	f846 1b04 	str.w	r1, [r6], #4
 80012cc:	6864      	ldr	r4, [r4, #4]
 80012ce:	606c      	str	r4, [r5, #4]
 80012d0:	1d3c      	adds	r4, r7, #4
 80012d2:	1d35      	adds	r5, r6, #4
 80012d4:	4564      	cmp	r4, ip
 80012d6:	d1f3      	bne.n	80012c0 <memcpy+0xe4>
 80012d8:	f109 0c01 	add.w	ip, r9, #1
 80012dc:	ea4f 098c 	mov.w	r9, ip, lsl #2
 80012e0:	f002 0203 	and.w	r2, r2, #3
 80012e4:	eb08 0109 	add.w	r1, r8, r9
 80012e8:	444b      	add	r3, r9
 80012ea:	b1d2      	cbz	r2, 8001322 <memcpy+0x146>
 80012ec:	780d      	ldrb	r5, [r1, #0]
 80012ee:	189a      	adds	r2, r3, r2
 80012f0:	43dc      	mvns	r4, r3
 80012f2:	f803 5b01 	strb.w	r5, [r3], #1
 80012f6:	1914      	adds	r4, r2, r4
 80012f8:	4293      	cmp	r3, r2
 80012fa:	f004 0401 	and.w	r4, r4, #1
 80012fe:	d010      	beq.n	8001322 <memcpy+0x146>
 8001300:	b12c      	cbz	r4, 800130e <memcpy+0x132>
 8001302:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8001306:	f803 4b01 	strb.w	r4, [r3], #1
 800130a:	4293      	cmp	r3, r2
 800130c:	d009      	beq.n	8001322 <memcpy+0x146>
 800130e:	784d      	ldrb	r5, [r1, #1]
 8001310:	461c      	mov	r4, r3
 8001312:	f804 5b01 	strb.w	r5, [r4], #1
 8001316:	788d      	ldrb	r5, [r1, #2]
 8001318:	3102      	adds	r1, #2
 800131a:	705d      	strb	r5, [r3, #1]
 800131c:	1c63      	adds	r3, r4, #1
 800131e:	4293      	cmp	r3, r2
 8001320:	d1f5      	bne.n	800130e <memcpy+0x132>
 8001322:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 8001326:	4770      	bx	lr
 8001328:	4603      	mov	r3, r0
 800132a:	e7de      	b.n	80012ea <memcpy+0x10e>
 800132c:	4603      	mov	r3, r0
 800132e:	e7dd      	b.n	80012ec <memcpy+0x110>
 8001330:	4641      	mov	r1, r8
 8001332:	4622      	mov	r2, r4
 8001334:	e7d9      	b.n	80012ea <memcpy+0x10e>
 8001336:	bf00      	nop

08001338 <__malloc_lock>:
 8001338:	4770      	bx	lr
 800133a:	bf00      	nop

0800133c <__malloc_unlock>:
 800133c:	4770      	bx	lr
 800133e:	bf00      	nop

08001340 <strlen>:
 8001340:	f020 0103 	bic.w	r1, r0, #3
 8001344:	f010 0003 	ands.w	r0, r0, #3
 8001348:	f1c0 0000 	rsb	r0, r0, #0
 800134c:	f851 3b04 	ldr.w	r3, [r1], #4
 8001350:	f100 0c04 	add.w	ip, r0, #4
 8001354:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8001358:	f06f 0200 	mvn.w	r2, #0
 800135c:	bf1c      	itt	ne
 800135e:	fa22 f20c 	lsrne.w	r2, r2, ip
 8001362:	4313      	orrne	r3, r2
 8001364:	f04f 0c01 	mov.w	ip, #1
 8001368:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 800136c:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 8001370:	eba3 020c 	sub.w	r2, r3, ip
 8001374:	ea22 0203 	bic.w	r2, r2, r3
 8001378:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 800137c:	bf04      	itt	eq
 800137e:	f851 3b04 	ldreq.w	r3, [r1], #4
 8001382:	3004      	addeq	r0, #4
 8001384:	d0f4      	beq.n	8001370 <strlen+0x30>
 8001386:	f013 0fff 	tst.w	r3, #255	; 0xff
 800138a:	bf1f      	itttt	ne
 800138c:	3001      	addne	r0, #1
 800138e:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
 8001392:	3001      	addne	r0, #1
 8001394:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
 8001398:	bf18      	it	ne
 800139a:	3001      	addne	r0, #1
 800139c:	4770      	bx	lr
 800139e:	bf00      	nop

080013a0 <register_fini>:
 80013a0:	4b02      	ldr	r3, [pc, #8]	; (80013ac <register_fini+0xc>)
 80013a2:	b113      	cbz	r3, 80013aa <register_fini+0xa>
 80013a4:	4802      	ldr	r0, [pc, #8]	; (80013b0 <register_fini+0x10>)
 80013a6:	f000 b805 	b.w	80013b4 <atexit>
 80013aa:	4770      	bx	lr
 80013ac:	00000000 	.word	0x00000000
 80013b0:	08000ba9 	.word	0x08000ba9

080013b4 <atexit>:
 80013b4:	4601      	mov	r1, r0
 80013b6:	2000      	movs	r0, #0
 80013b8:	4602      	mov	r2, r0
 80013ba:	4603      	mov	r3, r0
 80013bc:	f7ff bb94 	b.w	8000ae8 <__register_exitproc>

080013c0 <_malloc_trim_r>:
 80013c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80013c2:	4d22      	ldr	r5, [pc, #136]	; (800144c <_malloc_trim_r+0x8c>)
 80013c4:	460f      	mov	r7, r1
 80013c6:	4604      	mov	r4, r0
 80013c8:	f7ff ffb6 	bl	8001338 <__malloc_lock>
 80013cc:	68ab      	ldr	r3, [r5, #8]
 80013ce:	685e      	ldr	r6, [r3, #4]
 80013d0:	f026 0603 	bic.w	r6, r6, #3
 80013d4:	f606 70ef 	addw	r0, r6, #4079	; 0xfef
 80013d8:	1bc1      	subs	r1, r0, r7
 80013da:	0b0a      	lsrs	r2, r1, #12
 80013dc:	1e57      	subs	r7, r2, #1
 80013de:	033f      	lsls	r7, r7, #12
 80013e0:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
 80013e4:	db07      	blt.n	80013f6 <_malloc_trim_r+0x36>
 80013e6:	2100      	movs	r1, #0
 80013e8:	4620      	mov	r0, r4
 80013ea:	f7fe fef9 	bl	80001e0 <_sbrk_r>
 80013ee:	68ab      	ldr	r3, [r5, #8]
 80013f0:	1999      	adds	r1, r3, r6
 80013f2:	4288      	cmp	r0, r1
 80013f4:	d004      	beq.n	8001400 <_malloc_trim_r+0x40>
 80013f6:	4620      	mov	r0, r4
 80013f8:	f7ff ffa0 	bl	800133c <__malloc_unlock>
 80013fc:	2000      	movs	r0, #0
 80013fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001400:	4279      	negs	r1, r7
 8001402:	4620      	mov	r0, r4
 8001404:	f7fe feec 	bl	80001e0 <_sbrk_r>
 8001408:	3001      	adds	r0, #1
 800140a:	d00d      	beq.n	8001428 <_malloc_trim_r+0x68>
 800140c:	4b10      	ldr	r3, [pc, #64]	; (8001450 <_malloc_trim_r+0x90>)
 800140e:	68a8      	ldr	r0, [r5, #8]
 8001410:	681a      	ldr	r2, [r3, #0]
 8001412:	1bf6      	subs	r6, r6, r7
 8001414:	f046 0601 	orr.w	r6, r6, #1
 8001418:	1bd7      	subs	r7, r2, r7
 800141a:	6046      	str	r6, [r0, #4]
 800141c:	4620      	mov	r0, r4
 800141e:	601f      	str	r7, [r3, #0]
 8001420:	f7ff ff8c 	bl	800133c <__malloc_unlock>
 8001424:	2001      	movs	r0, #1
 8001426:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001428:	2100      	movs	r1, #0
 800142a:	4620      	mov	r0, r4
 800142c:	f7fe fed8 	bl	80001e0 <_sbrk_r>
 8001430:	68ab      	ldr	r3, [r5, #8]
 8001432:	1ac2      	subs	r2, r0, r3
 8001434:	2a0f      	cmp	r2, #15
 8001436:	ddde      	ble.n	80013f6 <_malloc_trim_r+0x36>
 8001438:	4906      	ldr	r1, [pc, #24]	; (8001454 <_malloc_trim_r+0x94>)
 800143a:	f042 0201 	orr.w	r2, r2, #1
 800143e:	6809      	ldr	r1, [r1, #0]
 8001440:	605a      	str	r2, [r3, #4]
 8001442:	1a40      	subs	r0, r0, r1
 8001444:	4902      	ldr	r1, [pc, #8]	; (8001450 <_malloc_trim_r+0x90>)
 8001446:	6008      	str	r0, [r1, #0]
 8001448:	e7d5      	b.n	80013f6 <_malloc_trim_r+0x36>
 800144a:	bf00      	nop
 800144c:	20000444 	.word	0x20000444
 8001450:	20000950 	.word	0x20000950
 8001454:	20000850 	.word	0x20000850

08001458 <_free_r>:
 8001458:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800145c:	460d      	mov	r5, r1
 800145e:	4606      	mov	r6, r0
 8001460:	2900      	cmp	r1, #0
 8001462:	d055      	beq.n	8001510 <_free_r+0xb8>
 8001464:	f7ff ff68 	bl	8001338 <__malloc_lock>
 8001468:	f855 1c04 	ldr.w	r1, [r5, #-4]
 800146c:	f8df c16c 	ldr.w	ip, [pc, #364]	; 80015dc <_free_r+0x184>
 8001470:	f1a5 0408 	sub.w	r4, r5, #8
 8001474:	f021 0301 	bic.w	r3, r1, #1
 8001478:	18e2      	adds	r2, r4, r3
 800147a:	f8dc 0008 	ldr.w	r0, [ip, #8]
 800147e:	6857      	ldr	r7, [r2, #4]
 8001480:	4290      	cmp	r0, r2
 8001482:	f027 0703 	bic.w	r7, r7, #3
 8001486:	d065      	beq.n	8001554 <_free_r+0xfc>
 8001488:	f011 0101 	ands.w	r1, r1, #1
 800148c:	6057      	str	r7, [r2, #4]
 800148e:	d032      	beq.n	80014f6 <_free_r+0x9e>
 8001490:	2100      	movs	r1, #0
 8001492:	19d0      	adds	r0, r2, r7
 8001494:	6840      	ldr	r0, [r0, #4]
 8001496:	07c0      	lsls	r0, r0, #31
 8001498:	d406      	bmi.n	80014a8 <_free_r+0x50>
 800149a:	19db      	adds	r3, r3, r7
 800149c:	6890      	ldr	r0, [r2, #8]
 800149e:	2900      	cmp	r1, #0
 80014a0:	d04a      	beq.n	8001538 <_free_r+0xe0>
 80014a2:	68d2      	ldr	r2, [r2, #12]
 80014a4:	60c2      	str	r2, [r0, #12]
 80014a6:	6090      	str	r0, [r2, #8]
 80014a8:	f043 0001 	orr.w	r0, r3, #1
 80014ac:	6060      	str	r0, [r4, #4]
 80014ae:	50e3      	str	r3, [r4, r3]
 80014b0:	b9e1      	cbnz	r1, 80014ec <_free_r+0x94>
 80014b2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80014b6:	d32d      	bcc.n	8001514 <_free_r+0xbc>
 80014b8:	0a5a      	lsrs	r2, r3, #9
 80014ba:	2a04      	cmp	r2, #4
 80014bc:	d866      	bhi.n	800158c <_free_r+0x134>
 80014be:	0998      	lsrs	r0, r3, #6
 80014c0:	3038      	adds	r0, #56	; 0x38
 80014c2:	0042      	lsls	r2, r0, #1
 80014c4:	eb0c 0e82 	add.w	lr, ip, r2, lsl #2
 80014c8:	f8de 2008 	ldr.w	r2, [lr, #8]
 80014cc:	4943      	ldr	r1, [pc, #268]	; (80015dc <_free_r+0x184>)
 80014ce:	4572      	cmp	r2, lr
 80014d0:	d062      	beq.n	8001598 <_free_r+0x140>
 80014d2:	6850      	ldr	r0, [r2, #4]
 80014d4:	f020 0103 	bic.w	r1, r0, #3
 80014d8:	428b      	cmp	r3, r1
 80014da:	d202      	bcs.n	80014e2 <_free_r+0x8a>
 80014dc:	6892      	ldr	r2, [r2, #8]
 80014de:	4596      	cmp	lr, r2
 80014e0:	d1f7      	bne.n	80014d2 <_free_r+0x7a>
 80014e2:	68d3      	ldr	r3, [r2, #12]
 80014e4:	60e3      	str	r3, [r4, #12]
 80014e6:	60a2      	str	r2, [r4, #8]
 80014e8:	60d4      	str	r4, [r2, #12]
 80014ea:	609c      	str	r4, [r3, #8]
 80014ec:	4630      	mov	r0, r6
 80014ee:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80014f2:	f7ff bf23 	b.w	800133c <__malloc_unlock>
 80014f6:	f855 5c08 	ldr.w	r5, [r5, #-8]
 80014fa:	f10c 0808 	add.w	r8, ip, #8
 80014fe:	1b64      	subs	r4, r4, r5
 8001500:	68a0      	ldr	r0, [r4, #8]
 8001502:	195b      	adds	r3, r3, r5
 8001504:	4540      	cmp	r0, r8
 8001506:	d03f      	beq.n	8001588 <_free_r+0x130>
 8001508:	68e5      	ldr	r5, [r4, #12]
 800150a:	60c5      	str	r5, [r0, #12]
 800150c:	60a8      	str	r0, [r5, #8]
 800150e:	e7c0      	b.n	8001492 <_free_r+0x3a>
 8001510:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001514:	08d9      	lsrs	r1, r3, #3
 8001516:	108a      	asrs	r2, r1, #2
 8001518:	2001      	movs	r0, #1
 800151a:	fa00 f002 	lsl.w	r0, r0, r2
 800151e:	eb0c 03c1 	add.w	r3, ip, r1, lsl #3
 8001522:	f8dc 1004 	ldr.w	r1, [ip, #4]
 8001526:	689a      	ldr	r2, [r3, #8]
 8001528:	4308      	orrs	r0, r1
 800152a:	60e3      	str	r3, [r4, #12]
 800152c:	60a2      	str	r2, [r4, #8]
 800152e:	f8cc 0004 	str.w	r0, [ip, #4]
 8001532:	609c      	str	r4, [r3, #8]
 8001534:	60d4      	str	r4, [r2, #12]
 8001536:	e7d9      	b.n	80014ec <_free_r+0x94>
 8001538:	4d29      	ldr	r5, [pc, #164]	; (80015e0 <_free_r+0x188>)
 800153a:	42a8      	cmp	r0, r5
 800153c:	d1b1      	bne.n	80014a2 <_free_r+0x4a>
 800153e:	f043 0101 	orr.w	r1, r3, #1
 8001542:	f8cc 4014 	str.w	r4, [ip, #20]
 8001546:	f8cc 4010 	str.w	r4, [ip, #16]
 800154a:	60e0      	str	r0, [r4, #12]
 800154c:	60a0      	str	r0, [r4, #8]
 800154e:	6061      	str	r1, [r4, #4]
 8001550:	50e3      	str	r3, [r4, r3]
 8001552:	e7cb      	b.n	80014ec <_free_r+0x94>
 8001554:	18ff      	adds	r7, r7, r3
 8001556:	07cb      	lsls	r3, r1, #31
 8001558:	d407      	bmi.n	800156a <_free_r+0x112>
 800155a:	f855 0c08 	ldr.w	r0, [r5, #-8]
 800155e:	1a24      	subs	r4, r4, r0
 8001560:	68e3      	ldr	r3, [r4, #12]
 8001562:	68a2      	ldr	r2, [r4, #8]
 8001564:	183f      	adds	r7, r7, r0
 8001566:	60d3      	str	r3, [r2, #12]
 8001568:	609a      	str	r2, [r3, #8]
 800156a:	481e      	ldr	r0, [pc, #120]	; (80015e4 <_free_r+0x18c>)
 800156c:	f047 0101 	orr.w	r1, r7, #1
 8001570:	6803      	ldr	r3, [r0, #0]
 8001572:	6061      	str	r1, [r4, #4]
 8001574:	429f      	cmp	r7, r3
 8001576:	f8cc 4008 	str.w	r4, [ip, #8]
 800157a:	d3b7      	bcc.n	80014ec <_free_r+0x94>
 800157c:	4a1a      	ldr	r2, [pc, #104]	; (80015e8 <_free_r+0x190>)
 800157e:	4630      	mov	r0, r6
 8001580:	6811      	ldr	r1, [r2, #0]
 8001582:	f7ff ff1d 	bl	80013c0 <_malloc_trim_r>
 8001586:	e7b1      	b.n	80014ec <_free_r+0x94>
 8001588:	2101      	movs	r1, #1
 800158a:	e782      	b.n	8001492 <_free_r+0x3a>
 800158c:	2a14      	cmp	r2, #20
 800158e:	d80c      	bhi.n	80015aa <_free_r+0x152>
 8001590:	f102 005b 	add.w	r0, r2, #91	; 0x5b
 8001594:	0042      	lsls	r2, r0, #1
 8001596:	e795      	b.n	80014c4 <_free_r+0x6c>
 8001598:	1080      	asrs	r0, r0, #2
 800159a:	2501      	movs	r5, #1
 800159c:	fa05 f500 	lsl.w	r5, r5, r0
 80015a0:	6848      	ldr	r0, [r1, #4]
 80015a2:	4613      	mov	r3, r2
 80015a4:	4328      	orrs	r0, r5
 80015a6:	6048      	str	r0, [r1, #4]
 80015a8:	e79c      	b.n	80014e4 <_free_r+0x8c>
 80015aa:	2a54      	cmp	r2, #84	; 0x54
 80015ac:	d803      	bhi.n	80015b6 <_free_r+0x15e>
 80015ae:	0b18      	lsrs	r0, r3, #12
 80015b0:	306e      	adds	r0, #110	; 0x6e
 80015b2:	0042      	lsls	r2, r0, #1
 80015b4:	e786      	b.n	80014c4 <_free_r+0x6c>
 80015b6:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 80015ba:	d803      	bhi.n	80015c4 <_free_r+0x16c>
 80015bc:	0bd8      	lsrs	r0, r3, #15
 80015be:	3077      	adds	r0, #119	; 0x77
 80015c0:	0042      	lsls	r2, r0, #1
 80015c2:	e77f      	b.n	80014c4 <_free_r+0x6c>
 80015c4:	f240 5154 	movw	r1, #1364	; 0x554
 80015c8:	428a      	cmp	r2, r1
 80015ca:	d803      	bhi.n	80015d4 <_free_r+0x17c>
 80015cc:	0c98      	lsrs	r0, r3, #18
 80015ce:	307c      	adds	r0, #124	; 0x7c
 80015d0:	0042      	lsls	r2, r0, #1
 80015d2:	e777      	b.n	80014c4 <_free_r+0x6c>
 80015d4:	22fc      	movs	r2, #252	; 0xfc
 80015d6:	207e      	movs	r0, #126	; 0x7e
 80015d8:	e774      	b.n	80014c4 <_free_r+0x6c>
 80015da:	bf00      	nop
 80015dc:	20000444 	.word	0x20000444
 80015e0:	2000044c 	.word	0x2000044c
 80015e4:	2000084c 	.word	0x2000084c
 80015e8:	2000094c 	.word	0x2000094c

080015ec <._101>:
 80015ec:	08001620 0a0d0920 6c656800 65680070      ... ....help.he
 80015fc:	203a706c 7473696c 6c612073 7661206c     lp: lists all av
 800160c:	616c6961 20656c62 6d6d6f63 73646e61     ailable commands
 800161c:	00000a0d                                ....

08001620 <_helpCommandDefinition>:
 8001620:	080015f5 00000000 0800073d 080015fa     ........=.......

08001630 <rccStartPll(rccPllInput, unsigned long, unsigned long)::muls>:
 8001630:	08060403 2018100c 00000030 00000043     ....... 0...C...

08001640 <_global_impure_ptr>:
 8001640:	20000018                                ... 

08001644 <__data_array_start>:
 8001644:	0800168c 	.word	0x0800168c
 8001648:	20000000 	.word	0x20000000
 800164c:	20000854 	.word	0x20000854

08001650 <__bss_array_start>:
 8001650:	20000854 	.word	0x20000854
 8001654:	2000097c 	.word	0x2000097c

08001658 <_init>:
 8001658:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800165a:	bf00      	nop
 800165c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800165e:	bc08      	pop	{r3}
 8001660:	469e      	mov	lr, r3
 8001662:	4770      	bx	lr

08001664 <__init_array_start>:
 8001664:	080013a1 	.word	0x080013a1

08001668 <__frame_dummy_init_array_entry>:
 8001668:	08000119 0800071d 080007bd              ............

08001674 <_fini>:
 8001674:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001676:	bf00      	nop
 8001678:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800167a:	bc08      	pop	{r3}
 800167c:	469e      	mov	lr, r3
 800167e:	4770      	bx	lr

08001680 <__fini_array_start>:
 8001680:	080000f5 	.word	0x080000f5
