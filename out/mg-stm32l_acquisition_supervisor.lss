
out/mg-stm32l_acquisition_supervisor.elf:     file format elf32-littlearm


Disassembly of section .text:

08000000 <__text_start>:
 8000000:	20002390 	.word	0x20002390
 8000004:	08000149 	.word	0x08000149
 8000008:	080001e1 	.word	0x080001e1
 800000c:	080001e1 	.word	0x080001e1
 8000010:	080001e1 	.word	0x080001e1
 8000014:	080001e1 	.word	0x080001e1
 8000018:	080001e1 	.word	0x080001e1
 800001c:	080001e1 	.word	0x080001e1
 8000020:	080001e1 	.word	0x080001e1
 8000024:	080001e1 	.word	0x080001e1
 8000028:	080001e1 	.word	0x080001e1
 800002c:	080001e1 	.word	0x080001e1
 8000030:	080001e1 	.word	0x080001e1
 8000034:	080001e1 	.word	0x080001e1
 8000038:	080001e1 	.word	0x080001e1
 800003c:	080002f5 	.word	0x080002f5
 8000040:	080001e1 	.word	0x080001e1
 8000044:	080001e1 	.word	0x080001e1
 8000048:	080001e1 	.word	0x080001e1
 800004c:	080001e1 	.word	0x080001e1
 8000050:	080001e1 	.word	0x080001e1
 8000054:	080001e1 	.word	0x080001e1
 8000058:	080001e1 	.word	0x080001e1
 800005c:	080001e1 	.word	0x080001e1
 8000060:	080001e1 	.word	0x080001e1
 8000064:	080001e1 	.word	0x080001e1
 8000068:	080001e1 	.word	0x080001e1
 800006c:	080001e1 	.word	0x080001e1
 8000070:	080001e1 	.word	0x080001e1
 8000074:	080001e1 	.word	0x080001e1
 8000078:	080001e1 	.word	0x080001e1
 800007c:	080001e1 	.word	0x080001e1
 8000080:	080001e1 	.word	0x080001e1
 8000084:	080001e1 	.word	0x080001e1
 8000088:	080001e1 	.word	0x080001e1
 800008c:	080001e1 	.word	0x080001e1
 8000090:	08000311 	.word	0x08000311
 8000094:	080001e1 	.word	0x080001e1
 8000098:	080001e1 	.word	0x080001e1
 800009c:	080001e1 	.word	0x080001e1
 80000a0:	080001e1 	.word	0x080001e1
 80000a4:	080001e1 	.word	0x080001e1
 80000a8:	080001e1 	.word	0x080001e1
 80000ac:	080001e1 	.word	0x080001e1
 80000b0:	080001e1 	.word	0x080001e1
 80000b4:	080001e1 	.word	0x080001e1
 80000b8:	080001e1 	.word	0x080001e1
 80000bc:	080001e1 	.word	0x080001e1
 80000c0:	080001e1 	.word	0x080001e1
 80000c4:	080001e1 	.word	0x080001e1
 80000c8:	080001e1 	.word	0x080001e1
 80000cc:	080001e1 	.word	0x080001e1
 80000d0:	080001e1 	.word	0x080001e1
 80000d4:	080001e1 	.word	0x080001e1
 80000d8:	080001e1 	.word	0x080001e1
 80000dc:	080001e1 	.word	0x080001e1
 80000e0:	080001e1 	.word	0x080001e1
 80000e4:	080001e1 	.word	0x080001e1
 80000e8:	080001e1 	.word	0x080001e1
 80000ec:	080001e1 	.word	0x080001e1
 80000f0:	080001e1 	.word	0x080001e1

080000f4 <__do_global_dtors_aux>:
 80000f4:	b510      	push	{r4, lr}
 80000f6:	4c05      	ldr	r4, [pc, #20]	; (800010c <__do_global_dtors_aux+0x18>)
 80000f8:	7823      	ldrb	r3, [r4, #0]
 80000fa:	b933      	cbnz	r3, 800010a <__do_global_dtors_aux+0x16>
 80000fc:	4804      	ldr	r0, [pc, #16]	; (8000110 <__do_global_dtors_aux+0x1c>)
 80000fe:	b110      	cbz	r0, 8000106 <__do_global_dtors_aux+0x12>
 8000100:	4804      	ldr	r0, [pc, #16]	; (8000114 <__do_global_dtors_aux+0x20>)
 8000102:	f3af 8000 	nop.w
 8000106:	2101      	movs	r1, #1
 8000108:	7021      	strb	r1, [r4, #0]
 800010a:	bd10      	pop	{r4, pc}
 800010c:	20000580 	.word	0x20000580
 8000110:	00000000 	.word	0x00000000
 8000114:	08006e08 	.word	0x08006e08

08000118 <frame_dummy>:
 8000118:	b508      	push	{r3, lr}
 800011a:	4b06      	ldr	r3, [pc, #24]	; (8000134 <frame_dummy+0x1c>)
 800011c:	b11b      	cbz	r3, 8000126 <frame_dummy+0xe>
 800011e:	4806      	ldr	r0, [pc, #24]	; (8000138 <frame_dummy+0x20>)
 8000120:	4906      	ldr	r1, [pc, #24]	; (800013c <frame_dummy+0x24>)
 8000122:	f3af 8000 	nop.w
 8000126:	4806      	ldr	r0, [pc, #24]	; (8000140 <frame_dummy+0x28>)
 8000128:	6801      	ldr	r1, [r0, #0]
 800012a:	b111      	cbz	r1, 8000132 <frame_dummy+0x1a>
 800012c:	4a05      	ldr	r2, [pc, #20]	; (8000144 <frame_dummy+0x2c>)
 800012e:	b102      	cbz	r2, 8000132 <frame_dummy+0x1a>
 8000130:	4790      	blx	r2
 8000132:	bd08      	pop	{r3, pc}
 8000134:	00000000 	.word	0x00000000
 8000138:	08006e08 	.word	0x08006e08
 800013c:	20000584 	.word	0x20000584
 8000140:	20000580 	.word	0x20000580
 8000144:	00000000 	.word	0x00000000

08000148 <Reset_Handler>:

Reset_Handler:

// Initialize the process stack pointer

	ldr		r0, =__process_stack_end
 8000148:	481b      	ldr	r0, [pc, #108]	; (80001b8 <__default_low_level_init+0x4>)
	msr		PSP, r0
 800014a:	f380 8809 	msr	PSP, r0

// Thread mode uses process stack (PSP) and is privileged

	movs	r0, #CONTROL_ALTERNATE_STACK
 800014e:	2002      	movs	r0, #2
	msr		CONTROL, r0
 8000150:	f380 8814 	msr	CONTROL, r0
	isb
 8000154:	f3bf 8f6f 	isb	sy

// Branch to low_level_init_0() function (.data and .bss are not initialized!)

	ldr		r0, =low_level_init_0
 8000158:	4818      	ldr	r0, [pc, #96]	; (80001bc <__default_low_level_init+0x8>)
	blx		r0
 800015a:	4780      	blx	r0

// Initialize sections from data_array (including .data)

	ldr		r4, =__data_array_start
 800015c:	4c18      	ldr	r4, [pc, #96]	; (80001c0 <__default_low_level_init+0xc>)
	ldr		r5, =__data_array_end
 800015e:	4d19      	ldr	r5, [pc, #100]	; (80001c4 <__default_low_level_init+0x10>)

1:	cmp		r4, r5							// outer loop - addresses from data_array
 8000160:	42ac      	cmp	r4, r5
	ittte	lo
 8000162:	bf3d      	ittte	cc
	ldrlo	r1, [r4], #4					// start of source address
 8000164:	f854 1b04 	ldrcc.w	r1, [r4], #4
	ldrlo	r2, [r4], #4					// start of destination address
 8000168:	f854 2b04 	ldrcc.w	r2, [r4], #4
	ldrlo	r3, [r4], #4					// end of destination address
 800016c:	f854 3b04 	ldrcc.w	r3, [r4], #4
	bhs		3f
 8000170:	e007      	bcs.n	8000182 <Reset_Handler+0x3a>

2:	cmp		r2, r3							// inner loop - section initialization
 8000172:	429a      	cmp	r2, r3
	ittt	lo
 8000174:	bf3e      	ittt	cc
	ldrlo	r0, [r1], #4
 8000176:	f851 0b04 	ldrcc.w	r0, [r1], #4
	strlo	r0, [r2], #4
 800017a:	f842 0b04 	strcc.w	r0, [r2], #4
	blo		2b
 800017e:	e7f8      	bcc.n	8000172 <Reset_Handler+0x2a>

	b		1b								// go back to start
 8000180:	e7ee      	b.n	8000160 <Reset_Handler+0x18>

3:

// Zero-init sections from bss_array (including .bss)

	movs	r0, #0
 8000182:	2000      	movs	r0, #0
	ldr		r3, =__bss_array_start
 8000184:	4b10      	ldr	r3, [pc, #64]	; (80001c8 <__default_low_level_init+0x14>)
	ldr		r4, =__bss_array_end
 8000186:	4c11      	ldr	r4, [pc, #68]	; (80001cc <__default_low_level_init+0x18>)

1:	cmp		r3, r4							// outer loop - addresses from data_array
 8000188:	42a3      	cmp	r3, r4
	itte	lo
 800018a:	bf3a      	itte	cc
	ldrlo	r1, [r3], #4					// start of destination address
 800018c:	f853 1b04 	ldrcc.w	r1, [r3], #4
	ldrlo	r2, [r3], #4					// end of destination address
 8000190:	f853 2b04 	ldrcc.w	r2, [r3], #4
	bhs		3f
 8000194:	e005      	bcs.n	80001a2 <Reset_Handler+0x5a>

2:	cmp		r1, r2							// inner loop - section initialization
 8000196:	4291      	cmp	r1, r2
	itt		lo
 8000198:	bf3c      	itt	cc
	strlo	r0, [r1], #4
 800019a:	f841 0b04 	strcc.w	r0, [r1], #4
	blo		2b
 800019e:	e7fa      	bcc.n	8000196 <Reset_Handler+0x4e>

	b		1b								// go back to start
 80001a0:	e7f2      	b.n	8000188 <Reset_Handler+0x40>
3:

// Call C++ constructors for global and static objects

#ifdef __USES_CXX
	ldr		r0, =__libc_init_array
 80001a2:	480b      	ldr	r0, [pc, #44]	; (80001d0 <__default_low_level_init+0x1c>)
	blx		r0
 80001a4:	4780      	blx	r0
#endif

// Branch to low_level_init_1() function

	ldr		r0, =low_level_init_1
 80001a6:	480b      	ldr	r0, [pc, #44]	; (80001d4 <__default_low_level_init+0x20>)
	blx		r0
 80001a8:	4780      	blx	r0

// Branch to main() with link

	ldr		r0, =main
 80001aa:	480b      	ldr	r0, [pc, #44]	; (80001d8 <__default_low_level_init+0x24>)
	blx		r0
 80001ac:	4780      	blx	r0

// Call C++ destructors for global and static objects

#ifdef __USES_CXX
	ldr		r0, =__libc_fini_array
 80001ae:	480b      	ldr	r0, [pc, #44]	; (80001dc <__default_low_level_init+0x28>)
	blx		r0
 80001b0:	4780      	blx	r0
#endif

// On return - loop till the end of the world

	b		.
 80001b2:	e7fe      	b.n	80001b2 <Reset_Handler+0x6a>

080001b4 <__default_low_level_init>:
.thumb
.thumb_func
.global __default_low_level_init

__default_low_level_init:
	bx		lr
 80001b4:	4770      	bx	lr
 80001b6:	0000      	.short	0x0000

Reset_Handler:

// Initialize the process stack pointer

	ldr		r0, =__process_stack_end
 80001b8:	20002790 	.word	0x20002790
	msr		CONTROL, r0
	isb

// Branch to low_level_init_0() function (.data and .bss are not initialized!)

	ldr		r0, =low_level_init_0
 80001bc:	080001b5 	.word	0x080001b5
	blx		r0

// Initialize sections from data_array (including .data)

	ldr		r4, =__data_array_start
 80001c0:	08006e08 	.word	0x08006e08
	ldr		r5, =__data_array_end
 80001c4:	08006e14 	.word	0x08006e14
3:

// Zero-init sections from bss_array (including .bss)

	movs	r0, #0
	ldr		r3, =__bss_array_start
 80001c8:	08006e14 	.word	0x08006e14
	ldr		r4, =__bss_array_end
 80001cc:	08006e1c 	.word	0x08006e1c
3:

// Call C++ constructors for global and static objects

#ifdef __USES_CXX
	ldr		r0, =__libc_init_array
 80001d0:	08006cd5 	.word	0x08006cd5
	blx		r0
#endif

// Branch to low_level_init_1() function

	ldr		r0, =low_level_init_1
 80001d4:	080001b5 	.word	0x080001b5
	blx		r0

// Branch to main() with link

	ldr		r0, =main
 80001d8:	080001f1 	.word	0x080001f1
	blx		r0

// Call C++ destructors for global and static objects

#ifdef __USES_CXX
	ldr		r0, =__libc_fini_array
 80001dc:	08006c85 	.word	0x08006c85

080001e0 <__Default_Handler>:
 * own handler defined.
*/

void __Default_Handler(void) __attribute__ ((interrupt));
void __Default_Handler(void)
{
 80001e0:	4668      	mov	r0, sp
 80001e2:	f020 0107 	bic.w	r1, r0, #7
 80001e6:	468d      	mov	sp, r1
 80001e8:	b481      	push	{r0, r7}
 80001ea:	af00      	add	r7, sp, #0
	while (1);
 80001ec:	e7fe      	b.n	80001ec <__Default_Handler+0xc>
 80001ee:	bf00      	nop

080001f0 <main>:
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

int main(void)
{
 80001f0:	b580      	push	{r7, lr}
 80001f2:	af00      	add	r7, sp, #0

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
 // HAL_Init();

  /* Configure the system clock */
  SystemClock_Config();
 80001f4:	f000 f806 	bl	8000204 <SystemClock_Config()>

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 80001f8:	f000 f85e 	bl	80002b8 <MX_GPIO_Init()>
  MX_USB_DEVICE_Init();
 80001fc:	f000 fd58 	bl	8000cb0 <MX_USB_DEVICE_Init>

  /* USER CODE END 2 */

  /* USER CODE BEGIN 3 */
  /* Infinite loop */
  while (1)
 8000200:	e7fe      	b.n	8000200 <main+0x10>
 8000202:	bf00      	nop

08000204 <SystemClock_Config()>:
}

/** System Clock Configuration
*/
void SystemClock_Config(void)
{
 8000204:	b580      	push	{r7, lr}
 8000206:	b092      	sub	sp, #72	; 0x48
 8000208:	af00      	add	r7, sp, #0

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  __PWR_CLK_ENABLE();
 800020a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800020e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000212:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000216:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800021a:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800021c:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000220:	625a      	str	r2, [r3, #36]	; 0x24

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000222:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8000226:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800022a:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 800022e:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8000232:	6812      	ldr	r2, [r2, #0]
 8000234:	f422 52c0 	bic.w	r2, r2, #6144	; 0x1800
 8000238:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800023c:	601a      	str	r2, [r3, #0]

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 800023e:	f04f 0301 	mov.w	r3, #1
 8000242:	603b      	str	r3, [r7, #0]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8000244:	f04f 0301 	mov.w	r3, #1
 8000248:	607b      	str	r3, [r7, #4]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800024a:	f04f 0302 	mov.w	r3, #2
 800024e:	627b      	str	r3, [r7, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000250:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000254:	62bb      	str	r3, [r7, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL12;
 8000256:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800025a:	62fb      	str	r3, [r7, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLDIV = RCC_PLL_DIV4;
 800025c:	f44f 0340 	mov.w	r3, #12582912	; 0xc00000
 8000260:	633b      	str	r3, [r7, #48]	; 0x30
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8000262:	463b      	mov	r3, r7
 8000264:	4618      	mov	r0, r3
 8000266:	f004 fa5f 	bl	8004728 <HAL_RCC_OscConfig>

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK;
 800026a:	f04f 0301 	mov.w	r3, #1
 800026e:	637b      	str	r3, [r7, #52]	; 0x34
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000270:	f04f 0303 	mov.w	r3, #3
 8000274:	63bb      	str	r3, [r7, #56]	; 0x38
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000276:	f04f 0300 	mov.w	r3, #0
 800027a:	63fb      	str	r3, [r7, #60]	; 0x3c
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 800027c:	f04f 0300 	mov.w	r3, #0
 8000280:	643b      	str	r3, [r7, #64]	; 0x40
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000282:	f04f 0300 	mov.w	r3, #0
 8000286:	647b      	str	r3, [r7, #68]	; 0x44
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1);
 8000288:	f107 0334 	add.w	r3, r7, #52	; 0x34
 800028c:	4618      	mov	r0, r3
 800028e:	f04f 0101 	mov.w	r1, #1
 8000292:	f005 fedf 	bl	8006054 <HAL_RCC_ClockConfig>

  __SYSCFG_CLK_ENABLE();
 8000296:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800029a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800029e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80002a2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80002a6:	6a12      	ldr	r2, [r2, #32]
 80002a8:	f042 0201 	orr.w	r2, r2, #1
 80002ac:	621a      	str	r2, [r3, #32]

}
 80002ae:	f107 0748 	add.w	r7, r7, #72	; 0x48
 80002b2:	46bd      	mov	sp, r7
 80002b4:	bd80      	pop	{r7, pc}
 80002b6:	bf00      	nop

080002b8 <MX_GPIO_Init()>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 80002b8:	b480      	push	{r7}
 80002ba:	af00      	add	r7, sp, #0

  /* GPIO Ports Clock Enable */
  __GPIOH_CLK_ENABLE();
 80002bc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80002c0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80002c4:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80002c8:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80002cc:	69d2      	ldr	r2, [r2, #28]
 80002ce:	f042 0220 	orr.w	r2, r2, #32
 80002d2:	61da      	str	r2, [r3, #28]
  __GPIOA_CLK_ENABLE();
 80002d4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80002d8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80002dc:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80002e0:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80002e4:	69d2      	ldr	r2, [r2, #28]
 80002e6:	f042 0201 	orr.w	r2, r2, #1
 80002ea:	61da      	str	r2, [r3, #28]

}
 80002ec:	46bd      	mov	sp, r7
 80002ee:	bc80      	pop	{r7}
 80002f0:	4770      	bx	lr
 80002f2:	bf00      	nop

080002f4 <SysTick_Handler>:
/**
* @brief This function handles System tick timer.
*/
extern "C" void SysTick_Handler(void) __attribute((interrupt));
void SysTick_Handler(void)
{
 80002f4:	4668      	mov	r0, sp
 80002f6:	f020 0107 	bic.w	r1, r0, #7
 80002fa:	468d      	mov	sp, r1
 80002fc:	b589      	push	{r0, r3, r7, lr}
 80002fe:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8000300:	f002 f822 	bl	8002348 <HAL_IncTick>
 // HAL_SYSTICK_IRQHandler();
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8000304:	46bd      	mov	sp, r7
 8000306:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
 800030a:	4685      	mov	sp, r0
 800030c:	4770      	bx	lr
 800030e:	bf00      	nop

08000310 <USB_LP_IRQHandler>:
/**
* @brief This function handles USB Low Priority interrupt.
*/
extern "C" void USB_LP_IRQHandler(void) __attribute((interrupt));
void USB_LP_IRQHandler(void)
{
 8000310:	4668      	mov	r0, sp
 8000312:	f020 0107 	bic.w	r1, r0, #7
 8000316:	468d      	mov	sp, r1
 8000318:	b589      	push	{r0, r3, r7, lr}
 800031a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USB_LP_IRQn 0 */

  /* USER CODE END USB_LP_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_FS);
 800031c:	f640 10a0 	movw	r0, #2464	; 0x9a0
 8000320:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000324:	f002 f956 	bl	80025d4 <HAL_PCD_IRQHandler>
  /* USER CODE BEGIN USB_LP_IRQn 1 */

  /* USER CODE END USB_LP_IRQn 1 */
}
 8000328:	46bd      	mov	sp, r7
 800032a:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
 800032e:	4685      	mov	sp, r0
 8000330:	4770      	bx	lr
 8000332:	bf00      	nop

08000334 <CDC_Init_FS()>:
  *         Initializes the CDC media low layer over the FS USB IP
  * @param  None
  * @retval Result of the opeartion: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Init_FS(void)
{
 8000334:	b580      	push	{r7, lr}
 8000336:	af00      	add	r7, sp, #0
  hUsbDevice_0 = &hUsbDeviceFS;
 8000338:	f640 139c 	movw	r3, #2460	; 0x99c
 800033c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000340:	f641 5264 	movw	r2, #7524	; 0x1d64
 8000344:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8000348:	601a      	str	r2, [r3, #0]
  /* USER CODE BEGIN 4 */ 
  /* Set Application Buffers */
  USBD_CDC_SetTxBuffer(hUsbDevice_0, UserTxBufferFS, 0);
 800034a:	f640 139c 	movw	r3, #2460	; 0x99c
 800034e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000352:	681b      	ldr	r3, [r3, #0]
 8000354:	4618      	mov	r0, r3
 8000356:	f240 719c 	movw	r1, #1948	; 0x79c
 800035a:	f2c2 0100 	movt	r1, #8192	; 0x2000
 800035e:	f04f 0200 	mov.w	r2, #0
 8000362:	f000 feb5 	bl	80010d0 <USBD_CDC_SetTxBuffer(_USBD_HandleTypeDef*, unsigned char*, unsigned short)>
  USBD_CDC_SetRxBuffer(hUsbDevice_0, UserRxBufferFS);
 8000366:	f640 139c 	movw	r3, #2460	; 0x99c
 800036a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800036e:	681b      	ldr	r3, [r3, #0]
 8000370:	4618      	mov	r0, r3
 8000372:	f240 519c 	movw	r1, #1436	; 0x59c
 8000376:	f2c2 0100 	movt	r1, #8192	; 0x2000
 800037a:	f000 fec5 	bl	8001108 <USBD_CDC_SetRxBuffer(_USBD_HandleTypeDef*, unsigned char*)>
  return (USBD_OK);
 800037e:	f04f 0300 	mov.w	r3, #0
 8000382:	b25b      	sxtb	r3, r3
  /* USER CODE END 4 */ 
}
 8000384:	4618      	mov	r0, r3
 8000386:	bd80      	pop	{r7, pc}

08000388 <CDC_DeInit_FS()>:
  *         DeInitializes the CDC media low layer
  * @param  None
  * @retval Result of the opeartion: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_DeInit_FS(void)
{
 8000388:	b480      	push	{r7}
 800038a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 5 */ 
  return (USBD_OK);
 800038c:	f04f 0300 	mov.w	r3, #0
 8000390:	b25b      	sxtb	r3, r3
  /* USER CODE END 5 */ 
}
 8000392:	4618      	mov	r0, r3
 8000394:	46bd      	mov	sp, r7
 8000396:	bc80      	pop	{r7}
 8000398:	4770      	bx	lr
 800039a:	bf00      	nop

0800039c <CDC_Control_FS(unsigned char, unsigned char*, unsigned short)>:
  * @param  Buf: Buffer containing command data (request parameters)
  * @param  Len: Number of data to be sent (in bytes)
  * @retval Result of the opeartion: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Control_FS  (uint8_t cmd, uint8_t* pbuf, uint16_t length)
{ 
 800039c:	b480      	push	{r7}
 800039e:	b083      	sub	sp, #12
 80003a0:	af00      	add	r7, sp, #0
 80003a2:	6039      	str	r1, [r7, #0]
 80003a4:	4613      	mov	r3, r2
 80003a6:	4602      	mov	r2, r0
 80003a8:	71fa      	strb	r2, [r7, #7]
 80003aa:	80bb      	strh	r3, [r7, #4]
  /* USER CODE BEGIN 6 */
  switch (cmd)
 80003ac:	79fb      	ldrb	r3, [r7, #7]
 80003ae:	2b23      	cmp	r3, #35	; 0x23
 80003b0:	d84a      	bhi.n	8000448 <CDC_Control_FS(unsigned char, unsigned char*, unsigned short)+0xac>
 80003b2:	a201      	add	r2, pc, #4	; (adr r2, 80003b8 <CDC_Control_FS(unsigned char, unsigned char*, unsigned short)+0x1c>)
 80003b4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80003b8:	08000449 	.word	0x08000449
 80003bc:	08000449 	.word	0x08000449
 80003c0:	08000449 	.word	0x08000449
 80003c4:	08000449 	.word	0x08000449
 80003c8:	08000449 	.word	0x08000449
 80003cc:	08000449 	.word	0x08000449
 80003d0:	08000449 	.word	0x08000449
 80003d4:	08000449 	.word	0x08000449
 80003d8:	08000449 	.word	0x08000449
 80003dc:	08000449 	.word	0x08000449
 80003e0:	08000449 	.word	0x08000449
 80003e4:	08000449 	.word	0x08000449
 80003e8:	08000449 	.word	0x08000449
 80003ec:	08000449 	.word	0x08000449
 80003f0:	08000449 	.word	0x08000449
 80003f4:	08000449 	.word	0x08000449
 80003f8:	08000449 	.word	0x08000449
 80003fc:	08000449 	.word	0x08000449
 8000400:	08000449 	.word	0x08000449
 8000404:	08000449 	.word	0x08000449
 8000408:	08000449 	.word	0x08000449
 800040c:	08000449 	.word	0x08000449
 8000410:	08000449 	.word	0x08000449
 8000414:	08000449 	.word	0x08000449
 8000418:	08000449 	.word	0x08000449
 800041c:	08000449 	.word	0x08000449
 8000420:	08000449 	.word	0x08000449
 8000424:	08000449 	.word	0x08000449
 8000428:	08000449 	.word	0x08000449
 800042c:	08000449 	.word	0x08000449
 8000430:	08000449 	.word	0x08000449
 8000434:	08000449 	.word	0x08000449
 8000438:	08000449 	.word	0x08000449
 800043c:	08000449 	.word	0x08000449
 8000440:	08000449 	.word	0x08000449
 8000444:	08000449 	.word	0x08000449
  case CDC_SEND_BREAK:
 
    break;    
    
  default:
    break;
 8000448:	bf00      	nop
  }

  return (USBD_OK);
 800044a:	f04f 0300 	mov.w	r3, #0
 800044e:	b25b      	sxtb	r3, r3
  /* USER CODE END 6 */
}
 8000450:	4618      	mov	r0, r3
 8000452:	f107 070c 	add.w	r7, r7, #12
 8000456:	46bd      	mov	sp, r7
 8000458:	bc80      	pop	{r7}
 800045a:	4770      	bx	lr

0800045c <CDC_Receive_FS(unsigned char*, unsigned long*)>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the opeartion: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Receive_FS (uint8_t* Buf, uint32_t *Len)
{
 800045c:	b480      	push	{r7}
 800045e:	b083      	sub	sp, #12
 8000460:	af00      	add	r7, sp, #0
 8000462:	6078      	str	r0, [r7, #4]
 8000464:	6039      	str	r1, [r7, #0]
  /* USER CODE BEGIN 7 */ 
  return (USBD_OK);
 8000466:	f04f 0300 	mov.w	r3, #0
 800046a:	b25b      	sxtb	r3, r3
  /* USER CODE END 7 */ 
}
 800046c:	4618      	mov	r0, r3
 800046e:	f107 070c 	add.w	r7, r7, #12
 8000472:	46bd      	mov	sp, r7
 8000474:	bc80      	pop	{r7}
 8000476:	4770      	bx	lr

08000478 <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* hpcd)
{
 8000478:	b580      	push	{r7, lr}
 800047a:	b082      	sub	sp, #8
 800047c:	af00      	add	r7, sp, #0
 800047e:	6078      	str	r0, [r7, #4]
  if(hpcd->Instance==USB)
 8000480:	687b      	ldr	r3, [r7, #4]
 8000482:	681a      	ldr	r2, [r3, #0]
 8000484:	f44f 43b8 	mov.w	r3, #23552	; 0x5c00
 8000488:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800048c:	429a      	cmp	r2, r3
 800048e:	d117      	bne.n	80004c0 <HAL_PCD_MspInit+0x48>
  {
  /* USER CODE BEGIN USB_MspInit 0 */

  /* USER CODE END USB_MspInit 0 */
    /* Peripheral clock enable */
    __USB_CLK_ENABLE();
 8000490:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000494:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000498:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800049c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80004a0:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80004a2:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 80004a6:	625a      	str	r2, [r3, #36]	; 0x24
    HAL_NVIC_SetPriority(USB_LP_IRQn, 0, 0);
 80004a8:	f04f 0014 	mov.w	r0, #20
 80004ac:	f04f 0100 	mov.w	r1, #0
 80004b0:	f04f 0200 	mov.w	r2, #0
 80004b4:	f001 feee 	bl	8002294 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USB_LP_IRQn);
 80004b8:	f04f 0014 	mov.w	r0, #20
 80004bc:	f001 ff08 	bl	80022d0 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_MspInit 1 */

  /* USER CODE END USB_MspInit 1 */
  }
}
 80004c0:	f107 0708 	add.w	r7, r7, #8
 80004c4:	46bd      	mov	sp, r7
 80004c6:	bd80      	pop	{r7, pc}

080004c8 <HAL_PCD_SetupStageCallback>:
  * @brief  Setup stage callback
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
{
 80004c8:	b580      	push	{r7, lr}
 80004ca:	b082      	sub	sp, #8
 80004cc:	af00      	add	r7, sp, #0
 80004ce:	6078      	str	r0, [r7, #4]
  USBD_LL_SetupStage(hpcd->pData, (uint8_t *)hpcd->Setup);
 80004d0:	687b      	ldr	r3, [r7, #4]
 80004d2:	f8d3 221c 	ldr.w	r2, [r3, #540]	; 0x21c
 80004d6:	687b      	ldr	r3, [r7, #4]
 80004d8:	f503 73f6 	add.w	r3, r3, #492	; 0x1ec
 80004dc:	4610      	mov	r0, r2
 80004de:	4619      	mov	r1, r3
 80004e0:	f000 fece 	bl	8001280 <USBD_LL_SetupStage(_USBD_HandleTypeDef*, unsigned char*)>
}
 80004e4:	f107 0708 	add.w	r7, r7, #8
 80004e8:	46bd      	mov	sp, r7
 80004ea:	bd80      	pop	{r7, pc}

080004ec <HAL_PCD_DataOutStageCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 80004ec:	b580      	push	{r7, lr}
 80004ee:	b082      	sub	sp, #8
 80004f0:	af00      	add	r7, sp, #0
 80004f2:	6078      	str	r0, [r7, #4]
 80004f4:	460b      	mov	r3, r1
 80004f6:	70fb      	strb	r3, [r7, #3]
  USBD_LL_DataOutStage(hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 80004f8:	687b      	ldr	r3, [r7, #4]
 80004fa:	f8d3 121c 	ldr.w	r1, [r3, #540]	; 0x21c
 80004fe:	78fa      	ldrb	r2, [r7, #3]
 8000500:	6878      	ldr	r0, [r7, #4]
 8000502:	4613      	mov	r3, r2
 8000504:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000508:	1a9b      	subs	r3, r3, r2
 800050a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800050e:	18c3      	adds	r3, r0, r3
 8000510:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8000514:	681b      	ldr	r3, [r3, #0]
 8000516:	78fa      	ldrb	r2, [r7, #3]
 8000518:	4608      	mov	r0, r1
 800051a:	4611      	mov	r1, r2
 800051c:	461a      	mov	r2, r3
 800051e:	f000 fefd 	bl	800131c <USBD_LL_DataOutStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)>
}
 8000522:	f107 0708 	add.w	r7, r7, #8
 8000526:	46bd      	mov	sp, r7
 8000528:	bd80      	pop	{r7, pc}
 800052a:	bf00      	nop

0800052c <HAL_PCD_DataInStageCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 800052c:	b580      	push	{r7, lr}
 800052e:	b082      	sub	sp, #8
 8000530:	af00      	add	r7, sp, #0
 8000532:	6078      	str	r0, [r7, #4]
 8000534:	460b      	mov	r3, r1
 8000536:	70fb      	strb	r3, [r7, #3]
  USBD_LL_DataInStage(hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8000538:	687b      	ldr	r3, [r7, #4]
 800053a:	f8d3 121c 	ldr.w	r1, [r3, #540]	; 0x21c
 800053e:	78fa      	ldrb	r2, [r7, #3]
 8000540:	6878      	ldr	r0, [r7, #4]
 8000542:	4613      	mov	r3, r2
 8000544:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000548:	1a9b      	subs	r3, r3, r2
 800054a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800054e:	18c3      	adds	r3, r0, r3
 8000550:	f103 0338 	add.w	r3, r3, #56	; 0x38
 8000554:	681b      	ldr	r3, [r3, #0]
 8000556:	78fa      	ldrb	r2, [r7, #3]
 8000558:	4608      	mov	r0, r1
 800055a:	4611      	mov	r1, r2
 800055c:	461a      	mov	r2, r3
 800055e:	f000 ff3f 	bl	80013e0 <USBD_LL_DataInStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)>
}
 8000562:	f107 0708 	add.w	r7, r7, #8
 8000566:	46bd      	mov	sp, r7
 8000568:	bd80      	pop	{r7, pc}
 800056a:	bf00      	nop

0800056c <HAL_PCD_SOFCallback>:
  * @brief  SOF callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
{
 800056c:	b580      	push	{r7, lr}
 800056e:	b082      	sub	sp, #8
 8000570:	af00      	add	r7, sp, #0
 8000572:	6078      	str	r0, [r7, #4]
  USBD_LL_SOF(hpcd->pData);
 8000574:	687b      	ldr	r3, [r7, #4]
 8000576:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 800057a:	4618      	mov	r0, r3
 800057c:	f001 f830 	bl	80015e0 <USBD_LL_SOF(_USBD_HandleTypeDef*)>
}
 8000580:	f107 0708 	add.w	r7, r7, #8
 8000584:	46bd      	mov	sp, r7
 8000586:	bd80      	pop	{r7, pc}

08000588 <HAL_PCD_ResetCallback>:
  * @brief  Reset callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{ 
 8000588:	b580      	push	{r7, lr}
 800058a:	b084      	sub	sp, #16
 800058c:	af00      	add	r7, sp, #0
 800058e:	6078      	str	r0, [r7, #4]
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;
 8000590:	f04f 0301 	mov.w	r3, #1
 8000594:	73fb      	strb	r3, [r7, #15]

  /*Set USB Current Speed*/
  switch (hpcd->Init.speed)
 8000596:	687b      	ldr	r3, [r7, #4]
 8000598:	689b      	ldr	r3, [r3, #8]
 800059a:	2b02      	cmp	r3, #2
 800059c:	d103      	bne.n	80005a6 <HAL_PCD_ResetCallback+0x1e>
  {
  case PCD_SPEED_FULL:
    speed = USBD_SPEED_FULL;    
 800059e:	f04f 0301 	mov.w	r3, #1
 80005a2:	73fb      	strb	r3, [r7, #15]
    break;
 80005a4:	e003      	b.n	80005ae <HAL_PCD_ResetCallback+0x26>
	
  default:
    speed = USBD_SPEED_FULL;    
 80005a6:	f04f 0301 	mov.w	r3, #1
 80005aa:	73fb      	strb	r3, [r7, #15]
    break;    
 80005ac:	bf00      	nop
  }
  USBD_LL_SetSpeed(hpcd->pData, speed);  
 80005ae:	687b      	ldr	r3, [r7, #4]
 80005b0:	f8d3 221c 	ldr.w	r2, [r3, #540]	; 0x21c
 80005b4:	7bfb      	ldrb	r3, [r7, #15]
 80005b6:	4610      	mov	r0, r2
 80005b8:	4619      	mov	r1, r3
 80005ba:	f000 ffd5 	bl	8001568 <USBD_LL_SetSpeed(_USBD_HandleTypeDef*, USBD_SpeedTypeDef)>
  
  /*Reset Device*/
  USBD_LL_Reset(hpcd->pData);
 80005be:	687b      	ldr	r3, [r7, #4]
 80005c0:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 80005c4:	4618      	mov	r0, r3
 80005c6:	f000 ff95 	bl	80014f4 <USBD_LL_Reset(_USBD_HandleTypeDef*)>
}
 80005ca:	f107 0710 	add.w	r7, r7, #16
 80005ce:	46bd      	mov	sp, r7
 80005d0:	bd80      	pop	{r7, pc}
 80005d2:	bf00      	nop

080005d4 <HAL_PCD_SuspendCallback>:
  * @brief  Suspend callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
{
 80005d4:	b580      	push	{r7, lr}
 80005d6:	b082      	sub	sp, #8
 80005d8:	af00      	add	r7, sp, #0
 80005da:	6078      	str	r0, [r7, #4]
  USBD_LL_Suspend(hpcd->pData);
 80005dc:	687b      	ldr	r3, [r7, #4]
 80005de:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 80005e2:	4618      	mov	r0, r3
 80005e4:	f000 ffd2 	bl	800158c <USBD_LL_Suspend(_USBD_HandleTypeDef*)>
  /*Enter in STOP mode */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 80005e8:	687b      	ldr	r3, [r7, #4]
 80005ea:	699b      	ldr	r3, [r3, #24]
 80005ec:	2b00      	cmp	r3, #0
 80005ee:	d00b      	beq.n	8000608 <HAL_PCD_SuspendCallback+0x34>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 80005f0:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 80005f4:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80005f8:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 80005fc:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8000600:	6912      	ldr	r2, [r2, #16]
 8000602:	f042 0206 	orr.w	r2, r2, #6
 8000606:	611a      	str	r2, [r3, #16]
  }
  /* USER CODE END 2 */
}
 8000608:	f107 0708 	add.w	r7, r7, #8
 800060c:	46bd      	mov	sp, r7
 800060e:	bd80      	pop	{r7, pc}

08000610 <HAL_PCD_ResumeCallback>:
  * @brief  Resume callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
{
 8000610:	b580      	push	{r7, lr}
 8000612:	b082      	sub	sp, #8
 8000614:	af00      	add	r7, sp, #0
 8000616:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN 3 */
  if ((hpcd->Init.low_power_enable)&&(remotewakeupon == 0))
 8000618:	687b      	ldr	r3, [r7, #4]
 800061a:	699b      	ldr	r3, [r3, #24]
 800061c:	2b00      	cmp	r3, #0
 800061e:	d009      	beq.n	8000634 <HAL_PCD_ResumeCallback+0x24>
 8000620:	f640 33c0 	movw	r3, #3008	; 0xbc0
 8000624:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000628:	681b      	ldr	r3, [r3, #0]
 800062a:	2b00      	cmp	r3, #0
 800062c:	d102      	bne.n	8000634 <HAL_PCD_ResumeCallback+0x24>
 800062e:	f04f 0301 	mov.w	r3, #1
 8000632:	e001      	b.n	8000638 <HAL_PCD_ResumeCallback+0x28>
 8000634:	f04f 0300 	mov.w	r3, #0
 8000638:	2b00      	cmp	r3, #0
 800063a:	d00d      	beq.n	8000658 <HAL_PCD_ResumeCallback+0x48>
  {
    SystemClockConfig_Resume();
 800063c:	f000 f9c6 	bl	80009cc <SystemClockConfig_Resume()>
    /* Reset SLEEPDEEP bit of Cortex System Control Register */
    SCB->SCR &= (uint32_t)~((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));    
 8000640:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8000644:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000648:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 800064c:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8000650:	6912      	ldr	r2, [r2, #16]
 8000652:	f022 0206 	bic.w	r2, r2, #6
 8000656:	611a      	str	r2, [r3, #16]
  }
  remotewakeupon=0;
 8000658:	f640 33c0 	movw	r3, #3008	; 0xbc0
 800065c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000660:	f04f 0200 	mov.w	r2, #0
 8000664:	601a      	str	r2, [r3, #0]
  /* USER CODE END 3 */
  USBD_LL_Resume(hpcd->pData);
 8000666:	687b      	ldr	r3, [r7, #4]
 8000668:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 800066c:	4618      	mov	r0, r3
 800066e:	f000 ffa5 	bl	80015bc <USBD_LL_Resume(_USBD_HandleTypeDef*)>
  
}
 8000672:	f107 0708 	add.w	r7, r7, #8
 8000676:	46bd      	mov	sp, r7
 8000678:	bd80      	pop	{r7, pc}
 800067a:	bf00      	nop

0800067c <USBD_LL_Init(_USBD_HandleTypeDef*)>:
  * @brief  Initializes the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev)
{ 
 800067c:	b580      	push	{r7, lr}
 800067e:	b082      	sub	sp, #8
 8000680:	af00      	add	r7, sp, #0
 8000682:	6078      	str	r0, [r7, #4]
  /* Init USB_IP */
  /* Link The driver to the stack */
  hpcd_USB_FS.pData = pdev;
 8000684:	f640 13a0 	movw	r3, #2464	; 0x9a0
 8000688:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800068c:	687a      	ldr	r2, [r7, #4]
 800068e:	f8c3 221c 	str.w	r2, [r3, #540]	; 0x21c
  pdev->pData = &hpcd_USB_FS;
 8000692:	687a      	ldr	r2, [r7, #4]
 8000694:	f640 13a0 	movw	r3, #2464	; 0x9a0
 8000698:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800069c:	f8c2 3220 	str.w	r3, [r2, #544]	; 0x220

  hpcd_USB_FS.Instance = USB;
 80006a0:	f640 13a0 	movw	r3, #2464	; 0x9a0
 80006a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80006a8:	f44f 42b8 	mov.w	r2, #23552	; 0x5c00
 80006ac:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80006b0:	601a      	str	r2, [r3, #0]
  hpcd_USB_FS.Init.dev_endpoints = 8;
 80006b2:	f640 13a0 	movw	r3, #2464	; 0x9a0
 80006b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80006ba:	f04f 0208 	mov.w	r2, #8
 80006be:	605a      	str	r2, [r3, #4]
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
 80006c0:	f640 13a0 	movw	r3, #2464	; 0x9a0
 80006c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80006c8:	f04f 0202 	mov.w	r2, #2
 80006cc:	609a      	str	r2, [r3, #8]
  hpcd_USB_FS.Init.ep0_mps = DEP0CTL_MPS_8;
 80006ce:	f640 13a0 	movw	r3, #2464	; 0x9a0
 80006d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80006d6:	f04f 0203 	mov.w	r2, #3
 80006da:	60da      	str	r2, [r3, #12]
  hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 80006dc:	f640 13a0 	movw	r3, #2464	; 0x9a0
 80006e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80006e4:	f04f 0202 	mov.w	r2, #2
 80006e8:	611a      	str	r2, [r3, #16]
  hpcd_USB_FS.Init.Sof_enable = DISABLE;
 80006ea:	f640 13a0 	movw	r3, #2464	; 0x9a0
 80006ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80006f2:	f04f 0200 	mov.w	r2, #0
 80006f6:	615a      	str	r2, [r3, #20]
  hpcd_USB_FS.Init.low_power_enable = DISABLE;
 80006f8:	f640 13a0 	movw	r3, #2464	; 0x9a0
 80006fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000700:	f04f 0200 	mov.w	r2, #0
 8000704:	619a      	str	r2, [r3, #24]
  hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
 8000706:	f640 13a0 	movw	r3, #2464	; 0x9a0
 800070a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800070e:	f04f 0200 	mov.w	r2, #0
 8000712:	621a      	str	r2, [r3, #32]
  HAL_PCD_Init(&hpcd_USB_FS);
 8000714:	f640 10a0 	movw	r0, #2464	; 0x9a0
 8000718:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800071c:	f001 fe32 	bl	8002384 <HAL_PCD_Init>

  HAL_PCDEx_PMAConfig(pdev->pData , 0x00 , PCD_SNG_BUF, 0x18);
 8000720:	687b      	ldr	r3, [r7, #4]
 8000722:	f8d3 3220 	ldr.w	r3, [r3, #544]	; 0x220
 8000726:	4618      	mov	r0, r3
 8000728:	f04f 0100 	mov.w	r1, #0
 800072c:	f04f 0200 	mov.w	r2, #0
 8000730:	f04f 0318 	mov.w	r3, #24
 8000734:	f003 ffac 	bl	8004690 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig(pdev->pData , 0x80 , PCD_SNG_BUF, 0x58);
 8000738:	687b      	ldr	r3, [r7, #4]
 800073a:	f8d3 3220 	ldr.w	r3, [r3, #544]	; 0x220
 800073e:	4618      	mov	r0, r3
 8000740:	f04f 0180 	mov.w	r1, #128	; 0x80
 8000744:	f04f 0200 	mov.w	r2, #0
 8000748:	f04f 0358 	mov.w	r3, #88	; 0x58
 800074c:	f003 ffa0 	bl	8004690 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig(pdev->pData , 0x81 , PCD_SNG_BUF, 0xC0);  
 8000750:	687b      	ldr	r3, [r7, #4]
 8000752:	f8d3 3220 	ldr.w	r3, [r3, #544]	; 0x220
 8000756:	4618      	mov	r0, r3
 8000758:	f04f 0181 	mov.w	r1, #129	; 0x81
 800075c:	f04f 0200 	mov.w	r2, #0
 8000760:	f04f 03c0 	mov.w	r3, #192	; 0xc0
 8000764:	f003 ff94 	bl	8004690 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig(pdev->pData , 0x01 , PCD_SNG_BUF, 0x110);
 8000768:	687b      	ldr	r3, [r7, #4]
 800076a:	f8d3 3220 	ldr.w	r3, [r3, #544]	; 0x220
 800076e:	4618      	mov	r0, r3
 8000770:	f04f 0101 	mov.w	r1, #1
 8000774:	f04f 0200 	mov.w	r2, #0
 8000778:	f44f 7388 	mov.w	r3, #272	; 0x110
 800077c:	f003 ff88 	bl	8004690 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig(pdev->pData , 0x82 , PCD_SNG_BUF, 0x100);  
 8000780:	687b      	ldr	r3, [r7, #4]
 8000782:	f8d3 3220 	ldr.w	r3, [r3, #544]	; 0x220
 8000786:	4618      	mov	r0, r3
 8000788:	f04f 0182 	mov.w	r1, #130	; 0x82
 800078c:	f04f 0200 	mov.w	r2, #0
 8000790:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000794:	f003 ff7c 	bl	8004690 <HAL_PCDEx_PMAConfig>
  return USBD_OK;
 8000798:	f04f 0300 	mov.w	r3, #0
}
 800079c:	4618      	mov	r0, r3
 800079e:	f107 0708 	add.w	r7, r7, #8
 80007a2:	46bd      	mov	sp, r7
 80007a4:	bd80      	pop	{r7, pc}
 80007a6:	bf00      	nop

080007a8 <USBD_LL_Start(_USBD_HandleTypeDef*)>:
  * @brief  Starts the Low Level portion of the Device driver. 
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 80007a8:	b580      	push	{r7, lr}
 80007aa:	b082      	sub	sp, #8
 80007ac:	af00      	add	r7, sp, #0
 80007ae:	6078      	str	r0, [r7, #4]
  HAL_PCD_Start(pdev->pData);
 80007b0:	687b      	ldr	r3, [r7, #4]
 80007b2:	f8d3 3220 	ldr.w	r3, [r3, #544]	; 0x220
 80007b6:	4618      	mov	r0, r3
 80007b8:	f001 fefc 	bl	80025b4 <HAL_PCD_Start>
  return USBD_OK; 
 80007bc:	f04f 0300 	mov.w	r3, #0
}
 80007c0:	4618      	mov	r0, r3
 80007c2:	f107 0708 	add.w	r7, r7, #8
 80007c6:	46bd      	mov	sp, r7
 80007c8:	bd80      	pop	{r7, pc}
 80007ca:	bf00      	nop

080007cc <USBD_LL_OpenEP(_USBD_HandleTypeDef*, unsigned char, unsigned char, unsigned short)>:
  */
USBD_StatusTypeDef  USBD_LL_OpenEP  (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  ep_type,
                                      uint16_t ep_mps)
{
 80007cc:	b580      	push	{r7, lr}
 80007ce:	b082      	sub	sp, #8
 80007d0:	af00      	add	r7, sp, #0
 80007d2:	6078      	str	r0, [r7, #4]
 80007d4:	70f9      	strb	r1, [r7, #3]
 80007d6:	70ba      	strb	r2, [r7, #2]
 80007d8:	803b      	strh	r3, [r7, #0]

  HAL_PCD_EP_Open(pdev->pData, 
                  ep_addr, 
                  ep_mps, 
                  ep_type);
 80007da:	687b      	ldr	r3, [r7, #4]
 80007dc:	f8d3 0220 	ldr.w	r0, [r3, #544]	; 0x220
 80007e0:	78f9      	ldrb	r1, [r7, #3]
 80007e2:	883a      	ldrh	r2, [r7, #0]
 80007e4:	78bb      	ldrb	r3, [r7, #2]
 80007e6:	f002 f83f 	bl	8002868 <HAL_PCD_EP_Open>
  
  return USBD_OK; 
 80007ea:	f04f 0300 	mov.w	r3, #0
}
 80007ee:	4618      	mov	r0, r3
 80007f0:	f107 0708 	add.w	r7, r7, #8
 80007f4:	46bd      	mov	sp, r7
 80007f6:	bd80      	pop	{r7, pc}

080007f8 <USBD_LL_CloseEP(_USBD_HandleTypeDef*, unsigned char)>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_CloseEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 80007f8:	b580      	push	{r7, lr}
 80007fa:	b082      	sub	sp, #8
 80007fc:	af00      	add	r7, sp, #0
 80007fe:	6078      	str	r0, [r7, #4]
 8000800:	460b      	mov	r3, r1
 8000802:	70fb      	strb	r3, [r7, #3]
  
  HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8000804:	687b      	ldr	r3, [r7, #4]
 8000806:	f8d3 2220 	ldr.w	r2, [r3, #544]	; 0x220
 800080a:	78fb      	ldrb	r3, [r7, #3]
 800080c:	4610      	mov	r0, r2
 800080e:	4619      	mov	r1, r3
 8000810:	f002 fc1a 	bl	8003048 <HAL_PCD_EP_Close>
  return USBD_OK; 
 8000814:	f04f 0300 	mov.w	r3, #0
}
 8000818:	4618      	mov	r0, r3
 800081a:	f107 0708 	add.w	r7, r7, #8
 800081e:	46bd      	mov	sp, r7
 8000820:	bd80      	pop	{r7, pc}
 8000822:	bf00      	nop

08000824 <USBD_LL_StallEP(_USBD_HandleTypeDef*, unsigned char)>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_StallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 8000824:	b580      	push	{r7, lr}
 8000826:	b082      	sub	sp, #8
 8000828:	af00      	add	r7, sp, #0
 800082a:	6078      	str	r0, [r7, #4]
 800082c:	460b      	mov	r3, r1
 800082e:	70fb      	strb	r3, [r7, #3]
  
  HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8000830:	687b      	ldr	r3, [r7, #4]
 8000832:	f8d3 2220 	ldr.w	r2, [r3, #544]	; 0x220
 8000836:	78fb      	ldrb	r3, [r7, #3]
 8000838:	4610      	mov	r0, r2
 800083a:	4619      	mov	r1, r3
 800083c:	f003 f934 	bl	8003aa8 <HAL_PCD_EP_SetStall>
  return USBD_OK; 
 8000840:	f04f 0300 	mov.w	r3, #0
}
 8000844:	4618      	mov	r0, r3
 8000846:	f107 0708 	add.w	r7, r7, #8
 800084a:	46bd      	mov	sp, r7
 800084c:	bd80      	pop	{r7, pc}
 800084e:	bf00      	nop

08000850 <USBD_LL_ClearStallEP(_USBD_HandleTypeDef*, unsigned char)>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_ClearStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 8000850:	b580      	push	{r7, lr}
 8000852:	b082      	sub	sp, #8
 8000854:	af00      	add	r7, sp, #0
 8000856:	6078      	str	r0, [r7, #4]
 8000858:	460b      	mov	r3, r1
 800085a:	70fb      	strb	r3, [r7, #3]
  
  HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);  
 800085c:	687b      	ldr	r3, [r7, #4]
 800085e:	f8d3 2220 	ldr.w	r2, [r3, #544]	; 0x220
 8000862:	78fb      	ldrb	r3, [r7, #3]
 8000864:	4610      	mov	r0, r2
 8000866:	4619      	mov	r1, r3
 8000868:	f003 f9dc 	bl	8003c24 <HAL_PCD_EP_ClrStall>
  return USBD_OK; 
 800086c:	f04f 0300 	mov.w	r3, #0
}
 8000870:	4618      	mov	r0, r3
 8000872:	f107 0708 	add.w	r7, r7, #8
 8000876:	46bd      	mov	sp, r7
 8000878:	bd80      	pop	{r7, pc}
 800087a:	bf00      	nop

0800087c <USBD_LL_IsStallEP(_USBD_HandleTypeDef*, unsigned char)>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 800087c:	b480      	push	{r7}
 800087e:	b085      	sub	sp, #20
 8000880:	af00      	add	r7, sp, #0
 8000882:	6078      	str	r0, [r7, #4]
 8000884:	460b      	mov	r3, r1
 8000886:	70fb      	strb	r3, [r7, #3]
  PCD_HandleTypeDef *hpcd = pdev->pData; 
 8000888:	687b      	ldr	r3, [r7, #4]
 800088a:	f8d3 3220 	ldr.w	r3, [r3, #544]	; 0x220
 800088e:	60fb      	str	r3, [r7, #12]
  
  if((ep_addr & 0x80) == 0x80)
 8000890:	78fb      	ldrb	r3, [r7, #3]
 8000892:	b25b      	sxtb	r3, r3
 8000894:	2b00      	cmp	r3, #0
 8000896:	da0e      	bge.n	80008b6 <USBD_LL_IsStallEP(_USBD_HandleTypeDef*, unsigned char)+0x3a>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 8000898:	78fb      	ldrb	r3, [r7, #3]
 800089a:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 800089e:	68f9      	ldr	r1, [r7, #12]
 80008a0:	4613      	mov	r3, r2
 80008a2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80008a6:	1a9b      	subs	r3, r3, r2
 80008a8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80008ac:	18cb      	adds	r3, r1, r3
 80008ae:	f103 0328 	add.w	r3, r3, #40	; 0x28
 80008b2:	789b      	ldrb	r3, [r3, #2]
 80008b4:	e00d      	b.n	80008d2 <USBD_LL_IsStallEP(_USBD_HandleTypeDef*, unsigned char)+0x56>
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 80008b6:	78fb      	ldrb	r3, [r7, #3]
 80008b8:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 80008bc:	68f9      	ldr	r1, [r7, #12]
 80008be:	4613      	mov	r3, r2
 80008c0:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80008c4:	1a9b      	subs	r3, r3, r2
 80008c6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80008ca:	18cb      	adds	r3, r1, r3
 80008cc:	f503 7384 	add.w	r3, r3, #264	; 0x108
 80008d0:	789b      	ldrb	r3, [r3, #2]
  }
}
 80008d2:	4618      	mov	r0, r3
 80008d4:	f107 0714 	add.w	r7, r7, #20
 80008d8:	46bd      	mov	sp, r7
 80008da:	bc80      	pop	{r7}
 80008dc:	4770      	bx	lr
 80008de:	bf00      	nop

080008e0 <USBD_LL_SetUSBAddress(_USBD_HandleTypeDef*, unsigned char)>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_SetUSBAddress (USBD_HandleTypeDef *pdev, uint8_t dev_addr)   
{
 80008e0:	b580      	push	{r7, lr}
 80008e2:	b082      	sub	sp, #8
 80008e4:	af00      	add	r7, sp, #0
 80008e6:	6078      	str	r0, [r7, #4]
 80008e8:	460b      	mov	r3, r1
 80008ea:	70fb      	strb	r3, [r7, #3]
  
  HAL_PCD_SetAddress(pdev->pData, dev_addr);
 80008ec:	687b      	ldr	r3, [r7, #4]
 80008ee:	f8d3 2220 	ldr.w	r2, [r3, #544]	; 0x220
 80008f2:	78fb      	ldrb	r3, [r7, #3]
 80008f4:	4610      	mov	r0, r2
 80008f6:	4619      	mov	r1, r3
 80008f8:	f001 ff88 	bl	800280c <HAL_PCD_SetAddress>
  return USBD_OK; 
 80008fc:	f04f 0300 	mov.w	r3, #0
}
 8000900:	4618      	mov	r0, r3
 8000902:	f107 0708 	add.w	r7, r7, #8
 8000906:	46bd      	mov	sp, r7
 8000908:	bd80      	pop	{r7, pc}
 800090a:	bf00      	nop

0800090c <USBD_LL_Transmit(_USBD_HandleTypeDef*, unsigned char, unsigned char*, unsigned short)>:
  */
USBD_StatusTypeDef  USBD_LL_Transmit (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  *pbuf,
                                      uint16_t  size)
{
 800090c:	b580      	push	{r7, lr}
 800090e:	b084      	sub	sp, #16
 8000910:	af00      	add	r7, sp, #0
 8000912:	60f8      	str	r0, [r7, #12]
 8000914:	607a      	str	r2, [r7, #4]
 8000916:	460a      	mov	r2, r1
 8000918:	72fa      	strb	r2, [r7, #11]
 800091a:	813b      	strh	r3, [r7, #8]

  HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 800091c:	68fb      	ldr	r3, [r7, #12]
 800091e:	f8d3 1220 	ldr.w	r1, [r3, #544]	; 0x220
 8000922:	893b      	ldrh	r3, [r7, #8]
 8000924:	7afa      	ldrb	r2, [r7, #11]
 8000926:	4608      	mov	r0, r1
 8000928:	4611      	mov	r1, r2
 800092a:	687a      	ldr	r2, [r7, #4]
 800092c:	f002 ff48 	bl	80037c0 <HAL_PCD_EP_Transmit>
  return USBD_OK;   
 8000930:	f04f 0300 	mov.w	r3, #0
}
 8000934:	4618      	mov	r0, r3
 8000936:	f107 0710 	add.w	r7, r7, #16
 800093a:	46bd      	mov	sp, r7
 800093c:	bd80      	pop	{r7, pc}
 800093e:	bf00      	nop

08000940 <USBD_LL_PrepareReceive(_USBD_HandleTypeDef*, unsigned char, unsigned char*, unsigned short)>:
  */
USBD_StatusTypeDef  USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, 
                                           uint8_t  ep_addr,                                      
                                           uint8_t  *pbuf,
                                           uint16_t  size)
{
 8000940:	b580      	push	{r7, lr}
 8000942:	b084      	sub	sp, #16
 8000944:	af00      	add	r7, sp, #0
 8000946:	60f8      	str	r0, [r7, #12]
 8000948:	607a      	str	r2, [r7, #4]
 800094a:	460a      	mov	r2, r1
 800094c:	72fa      	strb	r2, [r7, #11]
 800094e:	813b      	strh	r3, [r7, #8]

  HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8000950:	68fb      	ldr	r3, [r7, #12]
 8000952:	f8d3 1220 	ldr.w	r1, [r3, #544]	; 0x220
 8000956:	893b      	ldrh	r3, [r7, #8]
 8000958:	7afa      	ldrb	r2, [r7, #11]
 800095a:	4608      	mov	r0, r1
 800095c:	4611      	mov	r1, r2
 800095e:	687a      	ldr	r2, [r7, #4]
 8000960:	f002 fde0 	bl	8003524 <HAL_PCD_EP_Receive>
  return USBD_OK;   
 8000964:	f04f 0300 	mov.w	r3, #0
}
 8000968:	4618      	mov	r0, r3
 800096a:	f107 0710 	add.w	r7, r7, #16
 800096e:	46bd      	mov	sp, r7
 8000970:	bd80      	pop	{r7, pc}
 8000972:	bf00      	nop

08000974 <USBD_LL_GetRxDataSize(_USBD_HandleTypeDef*, unsigned char)>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval Recived Data Size
  */
uint32_t USBD_LL_GetRxDataSize  (USBD_HandleTypeDef *pdev, uint8_t  ep_addr)  
{
 8000974:	b580      	push	{r7, lr}
 8000976:	b082      	sub	sp, #8
 8000978:	af00      	add	r7, sp, #0
 800097a:	6078      	str	r0, [r7, #4]
 800097c:	460b      	mov	r3, r1
 800097e:	70fb      	strb	r3, [r7, #3]
  return HAL_PCD_EP_GetRxCount(pdev->pData, ep_addr);
 8000980:	687b      	ldr	r3, [r7, #4]
 8000982:	f8d3 2220 	ldr.w	r2, [r3, #544]	; 0x220
 8000986:	78fb      	ldrb	r3, [r7, #3]
 8000988:	4610      	mov	r0, r2
 800098a:	4619      	mov	r1, r3
 800098c:	f002 fefc 	bl	8003788 <HAL_PCD_EP_GetRxCount>
 8000990:	4603      	mov	r3, r0
}
 8000992:	4618      	mov	r0, r3
 8000994:	f107 0708 	add.w	r7, r7, #8
 8000998:	46bd      	mov	sp, r7
 800099a:	bd80      	pop	{r7, pc}

0800099c <USBD_static_malloc(unsigned long)>:
  * @brief  static single allocation.
  * @param  size: size of allocated memory
  * @retval None
  */
void *USBD_static_malloc(uint32_t size)
{
 800099c:	b480      	push	{r7}
 800099e:	b083      	sub	sp, #12
 80009a0:	af00      	add	r7, sp, #0
 80009a2:	6078      	str	r0, [r7, #4]
  static uint32_t mem[MAX_STATIC_ALLOC_SIZE];
  return mem;
 80009a4:	f640 33c4 	movw	r3, #3012	; 0xbc4
 80009a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
}
 80009ac:	4618      	mov	r0, r3
 80009ae:	f107 070c 	add.w	r7, r7, #12
 80009b2:	46bd      	mov	sp, r7
 80009b4:	bc80      	pop	{r7}
 80009b6:	4770      	bx	lr

080009b8 <USBD_static_free(void*)>:
  * @brief  Dummy memory free
  * @param  *p pointer to allocated  memory address
  * @retval None
  */
void USBD_static_free(void *p)
{
 80009b8:	b480      	push	{r7}
 80009ba:	b083      	sub	sp, #12
 80009bc:	af00      	add	r7, sp, #0
 80009be:	6078      	str	r0, [r7, #4]

}
 80009c0:	f107 070c 	add.w	r7, r7, #12
 80009c4:	46bd      	mov	sp, r7
 80009c6:	bc80      	pop	{r7}
 80009c8:	4770      	bx	lr
 80009ca:	bf00      	nop

080009cc <SystemClockConfig_Resume()>:
  *         enable HSI, PLL and select PLL as system clock source.
  * @param  None
  * @retval None
  */
static void SystemClockConfig_Resume(void)
{
 80009cc:	b580      	push	{r7, lr}
 80009ce:	af00      	add	r7, sp, #0
	SystemClock_Config2();
 80009d0:	f000 f82a 	bl	8000a28 <SystemClock_Config2()>
}
 80009d4:	bd80      	pop	{r7, pc}
 80009d6:	bf00      	nop

080009d8 <HAL_PCDEx_SetConnectionState>:
* @param hpcd: PCD handle
* @param state: connection state (0 : disconnected / 1: connected) 
* @retval None
*/
void HAL_PCDEx_SetConnectionState(PCD_HandleTypeDef *hpcd, uint8_t state)
{
 80009d8:	b480      	push	{r7}
 80009da:	b083      	sub	sp, #12
 80009dc:	af00      	add	r7, sp, #0
 80009de:	6078      	str	r0, [r7, #4]
 80009e0:	460b      	mov	r3, r1
 80009e2:	70fb      	strb	r3, [r7, #3]
/* USER CODE BEGIN 5 */
  if (state == 1)
 80009e4:	78fb      	ldrb	r3, [r7, #3]
 80009e6:	2b01      	cmp	r3, #1
 80009e8:	d10c      	bne.n	8000a04 <HAL_PCDEx_SetConnectionState+0x2c>
  {
    /* Configure Low Connection State */
	__HAL_SYSCFG_USBPULLUP_ENABLE();
 80009ea:	f04f 0300 	mov.w	r3, #0
 80009ee:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80009f2:	f04f 0200 	mov.w	r2, #0
 80009f6:	f2c4 0201 	movt	r2, #16385	; 0x4001
 80009fa:	6852      	ldr	r2, [r2, #4]
 80009fc:	f042 0201 	orr.w	r2, r2, #1
 8000a00:	605a      	str	r2, [r3, #4]
 8000a02:	e00b      	b.n	8000a1c <HAL_PCDEx_SetConnectionState+0x44>
  }
  else
  {
    /* Configure High Connection State */
    __HAL_SYSCFG_USBPULLUP_DISABLE();
 8000a04:	f04f 0300 	mov.w	r3, #0
 8000a08:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8000a0c:	f04f 0200 	mov.w	r2, #0
 8000a10:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8000a14:	6852      	ldr	r2, [r2, #4]
 8000a16:	f022 0201 	bic.w	r2, r2, #1
 8000a1a:	605a      	str	r2, [r3, #4]
  } 
/* USER CODE END 5 */
}
 8000a1c:	f107 070c 	add.w	r7, r7, #12
 8000a20:	46bd      	mov	sp, r7
 8000a22:	bc80      	pop	{r7}
 8000a24:	4770      	bx	lr
 8000a26:	bf00      	nop

08000a28 <SystemClock_Config2()>:

/** System Clock Configuration
*/
void SystemClock_Config2(void)
{
 8000a28:	b580      	push	{r7, lr}
 8000a2a:	b092      	sub	sp, #72	; 0x48
 8000a2c:	af00      	add	r7, sp, #0

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  __PWR_CLK_ENABLE();
 8000a2e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000a32:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000a36:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000a3a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000a3e:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8000a40:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000a44:	625a      	str	r2, [r3, #36]	; 0x24

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000a46:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8000a4a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8000a4e:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 8000a52:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8000a56:	6812      	ldr	r2, [r2, #0]
 8000a58:	f422 52c0 	bic.w	r2, r2, #6144	; 0x1800
 8000a5c:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8000a60:	601a      	str	r2, [r3, #0]

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8000a62:	f04f 0301 	mov.w	r3, #1
 8000a66:	603b      	str	r3, [r7, #0]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8000a68:	f04f 0301 	mov.w	r3, #1
 8000a6c:	607b      	str	r3, [r7, #4]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000a6e:	f04f 0302 	mov.w	r3, #2
 8000a72:	627b      	str	r3, [r7, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000a74:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000a78:	62bb      	str	r3, [r7, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL12;
 8000a7a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8000a7e:	62fb      	str	r3, [r7, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLDIV = RCC_PLL_DIV4;
 8000a80:	f44f 0340 	mov.w	r3, #12582912	; 0xc00000
 8000a84:	633b      	str	r3, [r7, #48]	; 0x30
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8000a86:	463b      	mov	r3, r7
 8000a88:	4618      	mov	r0, r3
 8000a8a:	f003 fe4d 	bl	8004728 <HAL_RCC_OscConfig>

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK;
 8000a8e:	f04f 0301 	mov.w	r3, #1
 8000a92:	637b      	str	r3, [r7, #52]	; 0x34
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000a94:	f04f 0303 	mov.w	r3, #3
 8000a98:	63bb      	str	r3, [r7, #56]	; 0x38
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000a9a:	f04f 0300 	mov.w	r3, #0
 8000a9e:	63fb      	str	r3, [r7, #60]	; 0x3c
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8000aa0:	f04f 0300 	mov.w	r3, #0
 8000aa4:	643b      	str	r3, [r7, #64]	; 0x40
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000aa6:	f04f 0300 	mov.w	r3, #0
 8000aaa:	647b      	str	r3, [r7, #68]	; 0x44
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1);
 8000aac:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8000ab0:	4618      	mov	r0, r3
 8000ab2:	f04f 0101 	mov.w	r1, #1
 8000ab6:	f005 facd 	bl	8006054 <HAL_RCC_ClockConfig>

  __SYSCFG_CLK_ENABLE();
 8000aba:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000abe:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000ac2:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000ac6:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000aca:	6a12      	ldr	r2, [r2, #32]
 8000acc:	f042 0201 	orr.w	r2, r2, #1
 8000ad0:	621a      	str	r2, [r3, #32]

}
 8000ad2:	f107 0748 	add.w	r7, r7, #72	; 0x48
 8000ad6:	46bd      	mov	sp, r7
 8000ad8:	bd80      	pop	{r7, pc}
 8000ada:	bf00      	nop

08000adc <USBD_FS_DeviceDescriptor(USBD_SpeedTypeDef, unsigned short*)>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_DeviceDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8000adc:	b480      	push	{r7}
 8000ade:	b083      	sub	sp, #12
 8000ae0:	af00      	add	r7, sp, #0
 8000ae2:	4603      	mov	r3, r0
 8000ae4:	6039      	str	r1, [r7, #0]
 8000ae6:	71fb      	strb	r3, [r7, #7]
  *length = sizeof(USBD_FS_DeviceDesc);
 8000ae8:	683b      	ldr	r3, [r7, #0]
 8000aea:	f04f 0212 	mov.w	r2, #18
 8000aee:	801a      	strh	r2, [r3, #0]
  return USBD_FS_DeviceDesc;
 8000af0:	f240 0330 	movw	r3, #48	; 0x30
 8000af4:	f2c2 0300 	movt	r3, #8192	; 0x2000
}
 8000af8:	4618      	mov	r0, r3
 8000afa:	f107 070c 	add.w	r7, r7, #12
 8000afe:	46bd      	mov	sp, r7
 8000b00:	bc80      	pop	{r7}
 8000b02:	4770      	bx	lr

08000b04 <USBD_FS_LangIDStrDescriptor(USBD_SpeedTypeDef, unsigned short*)>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_LangIDStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8000b04:	b480      	push	{r7}
 8000b06:	b083      	sub	sp, #12
 8000b08:	af00      	add	r7, sp, #0
 8000b0a:	4603      	mov	r3, r0
 8000b0c:	6039      	str	r1, [r7, #0]
 8000b0e:	71fb      	strb	r3, [r7, #7]
  *length =  sizeof(USBD_LangIDDesc);  
 8000b10:	683b      	ldr	r3, [r7, #0]
 8000b12:	f04f 0204 	mov.w	r2, #4
 8000b16:	801a      	strh	r2, [r3, #0]
  return USBD_LangIDDesc;
 8000b18:	f240 0344 	movw	r3, #68	; 0x44
 8000b1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
}
 8000b20:	4618      	mov	r0, r3
 8000b22:	f107 070c 	add.w	r7, r7, #12
 8000b26:	46bd      	mov	sp, r7
 8000b28:	bc80      	pop	{r7}
 8000b2a:	4770      	bx	lr

08000b2c <USBD_FS_ProductStrDescriptor(USBD_SpeedTypeDef, unsigned short*)>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ProductStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8000b2c:	b580      	push	{r7, lr}
 8000b2e:	b082      	sub	sp, #8
 8000b30:	af00      	add	r7, sp, #0
 8000b32:	4603      	mov	r3, r0
 8000b34:	6039      	str	r1, [r7, #0]
 8000b36:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 8000b38:	79fb      	ldrb	r3, [r7, #7]
 8000b3a:	2b00      	cmp	r3, #0
 8000b3c:	d10b      	bne.n	8000b56 <USBD_FS_ProductStrDescriptor(USBD_SpeedTypeDef, unsigned short*)+0x2a>
  {   
    USBD_GetString (USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 8000b3e:	f646 5088 	movw	r0, #28040	; 0x6d88
 8000b42:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000b46:	f641 3164 	movw	r1, #7012	; 0x1b64
 8000b4a:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000b4e:	683a      	ldr	r2, [r7, #0]
 8000b50:	f001 f9c2 	bl	8001ed8 <USBD_GetString(unsigned char*, unsigned char*, unsigned short*)>
 8000b54:	e00a      	b.n	8000b6c <USBD_FS_ProductStrDescriptor(USBD_SpeedTypeDef, unsigned short*)+0x40>
  }
  else
  {
    USBD_GetString (USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);    
 8000b56:	f646 5088 	movw	r0, #28040	; 0x6d88
 8000b5a:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000b5e:	f641 3164 	movw	r1, #7012	; 0x1b64
 8000b62:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000b66:	683a      	ldr	r2, [r7, #0]
 8000b68:	f001 f9b6 	bl	8001ed8 <USBD_GetString(unsigned char*, unsigned char*, unsigned short*)>
  }
  return USBD_StrDesc;
 8000b6c:	f641 3364 	movw	r3, #7012	; 0x1b64
 8000b70:	f2c2 0300 	movt	r3, #8192	; 0x2000
}
 8000b74:	4618      	mov	r0, r3
 8000b76:	f107 0708 	add.w	r7, r7, #8
 8000b7a:	46bd      	mov	sp, r7
 8000b7c:	bd80      	pop	{r7, pc}
 8000b7e:	bf00      	nop

08000b80 <USBD_FS_ManufacturerStrDescriptor(USBD_SpeedTypeDef, unsigned short*)>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ManufacturerStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8000b80:	b580      	push	{r7, lr}
 8000b82:	b082      	sub	sp, #8
 8000b84:	af00      	add	r7, sp, #0
 8000b86:	4603      	mov	r3, r0
 8000b88:	6039      	str	r1, [r7, #0]
 8000b8a:	71fb      	strb	r3, [r7, #7]
  USBD_GetString (USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8000b8c:	f646 50a0 	movw	r0, #28064	; 0x6da0
 8000b90:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000b94:	f641 3164 	movw	r1, #7012	; 0x1b64
 8000b98:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000b9c:	683a      	ldr	r2, [r7, #0]
 8000b9e:	f001 f99b 	bl	8001ed8 <USBD_GetString(unsigned char*, unsigned char*, unsigned short*)>
  return USBD_StrDesc;
 8000ba2:	f641 3364 	movw	r3, #7012	; 0x1b64
 8000ba6:	f2c2 0300 	movt	r3, #8192	; 0x2000
}
 8000baa:	4618      	mov	r0, r3
 8000bac:	f107 0708 	add.w	r7, r7, #8
 8000bb0:	46bd      	mov	sp, r7
 8000bb2:	bd80      	pop	{r7, pc}

08000bb4 <USBD_FS_SerialStrDescriptor(USBD_SpeedTypeDef, unsigned short*)>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_SerialStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8000bb4:	b580      	push	{r7, lr}
 8000bb6:	b082      	sub	sp, #8
 8000bb8:	af00      	add	r7, sp, #0
 8000bba:	4603      	mov	r3, r0
 8000bbc:	6039      	str	r1, [r7, #0]
 8000bbe:	71fb      	strb	r3, [r7, #7]
  if(speed  == USBD_SPEED_HIGH)
 8000bc0:	79fb      	ldrb	r3, [r7, #7]
 8000bc2:	2b00      	cmp	r3, #0
 8000bc4:	d10b      	bne.n	8000bde <USBD_FS_SerialStrDescriptor(USBD_SpeedTypeDef, unsigned short*)+0x2a>
  {    
    USBD_GetString (USBD_SERIALNUMBER_STRING_FS, USBD_StrDesc, length);
 8000bc6:	f646 50b4 	movw	r0, #28084	; 0x6db4
 8000bca:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000bce:	f641 3164 	movw	r1, #7012	; 0x1b64
 8000bd2:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000bd6:	683a      	ldr	r2, [r7, #0]
 8000bd8:	f001 f97e 	bl	8001ed8 <USBD_GetString(unsigned char*, unsigned char*, unsigned short*)>
 8000bdc:	e00a      	b.n	8000bf4 <USBD_FS_SerialStrDescriptor(USBD_SpeedTypeDef, unsigned short*)+0x40>
  }
  else
  {
    USBD_GetString (USBD_SERIALNUMBER_STRING_FS, USBD_StrDesc, length);    
 8000bde:	f646 50b4 	movw	r0, #28084	; 0x6db4
 8000be2:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000be6:	f641 3164 	movw	r1, #7012	; 0x1b64
 8000bea:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000bee:	683a      	ldr	r2, [r7, #0]
 8000bf0:	f001 f972 	bl	8001ed8 <USBD_GetString(unsigned char*, unsigned char*, unsigned short*)>
  }
  return USBD_StrDesc;
 8000bf4:	f641 3364 	movw	r3, #7012	; 0x1b64
 8000bf8:	f2c2 0300 	movt	r3, #8192	; 0x2000
}
 8000bfc:	4618      	mov	r0, r3
 8000bfe:	f107 0708 	add.w	r7, r7, #8
 8000c02:	46bd      	mov	sp, r7
 8000c04:	bd80      	pop	{r7, pc}
 8000c06:	bf00      	nop

08000c08 <USBD_FS_ConfigStrDescriptor(USBD_SpeedTypeDef, unsigned short*)>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ConfigStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8000c08:	b580      	push	{r7, lr}
 8000c0a:	b082      	sub	sp, #8
 8000c0c:	af00      	add	r7, sp, #0
 8000c0e:	4603      	mov	r3, r0
 8000c10:	6039      	str	r1, [r7, #0]
 8000c12:	71fb      	strb	r3, [r7, #7]
  if(speed  == USBD_SPEED_HIGH)
 8000c14:	79fb      	ldrb	r3, [r7, #7]
 8000c16:	2b00      	cmp	r3, #0
 8000c18:	d10b      	bne.n	8000c32 <USBD_FS_ConfigStrDescriptor(USBD_SpeedTypeDef, unsigned short*)+0x2a>
  {  
    USBD_GetString (USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8000c1a:	f646 50c4 	movw	r0, #28100	; 0x6dc4
 8000c1e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000c22:	f641 3164 	movw	r1, #7012	; 0x1b64
 8000c26:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000c2a:	683a      	ldr	r2, [r7, #0]
 8000c2c:	f001 f954 	bl	8001ed8 <USBD_GetString(unsigned char*, unsigned char*, unsigned short*)>
 8000c30:	e00a      	b.n	8000c48 <USBD_FS_ConfigStrDescriptor(USBD_SpeedTypeDef, unsigned short*)+0x40>
  }
  else
  {
    USBD_GetString (USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length); 
 8000c32:	f646 50c4 	movw	r0, #28100	; 0x6dc4
 8000c36:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000c3a:	f641 3164 	movw	r1, #7012	; 0x1b64
 8000c3e:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000c42:	683a      	ldr	r2, [r7, #0]
 8000c44:	f001 f948 	bl	8001ed8 <USBD_GetString(unsigned char*, unsigned char*, unsigned short*)>
  }
  return USBD_StrDesc;  
 8000c48:	f641 3364 	movw	r3, #7012	; 0x1b64
 8000c4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
}
 8000c50:	4618      	mov	r0, r3
 8000c52:	f107 0708 	add.w	r7, r7, #8
 8000c56:	46bd      	mov	sp, r7
 8000c58:	bd80      	pop	{r7, pc}
 8000c5a:	bf00      	nop

08000c5c <USBD_FS_InterfaceStrDescriptor(USBD_SpeedTypeDef, unsigned short*)>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_InterfaceStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8000c5c:	b580      	push	{r7, lr}
 8000c5e:	b082      	sub	sp, #8
 8000c60:	af00      	add	r7, sp, #0
 8000c62:	4603      	mov	r3, r0
 8000c64:	6039      	str	r1, [r7, #0]
 8000c66:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 8000c68:	79fb      	ldrb	r3, [r7, #7]
 8000c6a:	2b00      	cmp	r3, #0
 8000c6c:	d10b      	bne.n	8000c86 <USBD_FS_InterfaceStrDescriptor(USBD_SpeedTypeDef, unsigned short*)+0x2a>
  {
    USBD_GetString (USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 8000c6e:	f646 50d0 	movw	r0, #28112	; 0x6dd0
 8000c72:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000c76:	f641 3164 	movw	r1, #7012	; 0x1b64
 8000c7a:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000c7e:	683a      	ldr	r2, [r7, #0]
 8000c80:	f001 f92a 	bl	8001ed8 <USBD_GetString(unsigned char*, unsigned char*, unsigned short*)>
 8000c84:	e00a      	b.n	8000c9c <USBD_FS_InterfaceStrDescriptor(USBD_SpeedTypeDef, unsigned short*)+0x40>
  }
  else
  {
    USBD_GetString (USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 8000c86:	f646 50d0 	movw	r0, #28112	; 0x6dd0
 8000c8a:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000c8e:	f641 3164 	movw	r1, #7012	; 0x1b64
 8000c92:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000c96:	683a      	ldr	r2, [r7, #0]
 8000c98:	f001 f91e 	bl	8001ed8 <USBD_GetString(unsigned char*, unsigned char*, unsigned short*)>
  }
  return USBD_StrDesc;  
 8000c9c:	f641 3364 	movw	r3, #7012	; 0x1b64
 8000ca0:	f2c2 0300 	movt	r3, #8192	; 0x2000
}
 8000ca4:	4618      	mov	r0, r3
 8000ca6:	f107 0708 	add.w	r7, r7, #8
 8000caa:	46bd      	mov	sp, r7
 8000cac:	bd80      	pop	{r7, pc}
 8000cae:	bf00      	nop

08000cb0 <MX_USB_DEVICE_Init>:
/* USB Device Core handle declaration */
USBD_HandleTypeDef hUsbDeviceFS;

/* init function */				        
void MX_USB_DEVICE_Init(void)
{
 8000cb0:	b580      	push	{r7, lr}
 8000cb2:	af00      	add	r7, sp, #0
  /* Init Device Library,Add Supported Class and Start the library*/
  USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS);
 8000cb4:	f641 5064 	movw	r0, #7524	; 0x1d64
 8000cb8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000cbc:	f240 0114 	movw	r1, #20
 8000cc0:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000cc4:	f04f 0200 	mov.w	r2, #0
 8000cc8:	f000 fa34 	bl	8001134 <USBD_Init(_USBD_HandleTypeDef*, USBD_DescriptorsTypeDef*, unsigned char)>

  USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC);
 8000ccc:	f641 5064 	movw	r0, #7524	; 0x1d64
 8000cd0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000cd4:	f240 0154 	movw	r1, #84	; 0x54
 8000cd8:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000cdc:	f000 fa5a 	bl	8001194 <USBD_RegisterClass(_USBD_HandleTypeDef*, _Device_cb*)>

  USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS);
 8000ce0:	f641 5064 	movw	r0, #7524	; 0x1d64
 8000ce4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000ce8:	f240 0104 	movw	r1, #4
 8000cec:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000cf0:	f000 f9d4 	bl	800109c <USBD_CDC_RegisterInterface(_USBD_HandleTypeDef*, _USBD_CDC_Itf*)>

  USBD_Start(&hUsbDeviceFS);
 8000cf4:	f641 5064 	movw	r0, #7524	; 0x1d64
 8000cf8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000cfc:	f000 fa68 	bl	80011d0 <USBD_Start(_USBD_HandleTypeDef*)>

}
 8000d00:	bd80      	pop	{r7, pc}
 8000d02:	bf00      	nop

08000d04 <USBD_CDC_Init(_USBD_HandleTypeDef*, unsigned char)>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  USBD_CDC_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
 8000d04:	b580      	push	{r7, lr}
 8000d06:	b084      	sub	sp, #16
 8000d08:	af00      	add	r7, sp, #0
 8000d0a:	6078      	str	r0, [r7, #4]
 8000d0c:	460b      	mov	r3, r1
 8000d0e:	70fb      	strb	r3, [r7, #3]
  uint8_t ret = 0;
 8000d10:	f04f 0300 	mov.w	r3, #0
 8000d14:	73fb      	strb	r3, [r7, #15]
  USBD_CDC_HandleTypeDef   *hcdc;
  
  if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8000d16:	687b      	ldr	r3, [r7, #4]
 8000d18:	7c1b      	ldrb	r3, [r3, #16]
 8000d1a:	2b00      	cmp	r3, #0
 8000d1c:	d112      	bne.n	8000d44 <USBD_CDC_Init(_USBD_HandleTypeDef*, unsigned char)+0x40>
  {  
    /* Open EP IN */
    USBD_LL_OpenEP(pdev,
                   CDC_IN_EP,
                   USBD_EP_TYPE_BULK,
                   CDC_DATA_HS_IN_PACKET_SIZE);
 8000d1e:	6878      	ldr	r0, [r7, #4]
 8000d20:	f04f 0181 	mov.w	r1, #129	; 0x81
 8000d24:	f04f 0202 	mov.w	r2, #2
 8000d28:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000d2c:	f7ff fd4e 	bl	80007cc <USBD_LL_OpenEP(_USBD_HandleTypeDef*, unsigned char, unsigned char, unsigned short)>
    
    /* Open EP OUT */
    USBD_LL_OpenEP(pdev,
                   CDC_OUT_EP,
                   USBD_EP_TYPE_BULK,
                   CDC_DATA_HS_OUT_PACKET_SIZE);
 8000d30:	6878      	ldr	r0, [r7, #4]
 8000d32:	f04f 0101 	mov.w	r1, #1
 8000d36:	f04f 0202 	mov.w	r2, #2
 8000d3a:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000d3e:	f7ff fd45 	bl	80007cc <USBD_LL_OpenEP(_USBD_HandleTypeDef*, unsigned char, unsigned char, unsigned short)>
 8000d42:	e011      	b.n	8000d68 <USBD_CDC_Init(_USBD_HandleTypeDef*, unsigned char)+0x64>
  {
    /* Open EP IN */
    USBD_LL_OpenEP(pdev,
                   CDC_IN_EP,
                   USBD_EP_TYPE_BULK,
                   CDC_DATA_FS_IN_PACKET_SIZE);
 8000d44:	6878      	ldr	r0, [r7, #4]
 8000d46:	f04f 0181 	mov.w	r1, #129	; 0x81
 8000d4a:	f04f 0202 	mov.w	r2, #2
 8000d4e:	f04f 0340 	mov.w	r3, #64	; 0x40
 8000d52:	f7ff fd3b 	bl	80007cc <USBD_LL_OpenEP(_USBD_HandleTypeDef*, unsigned char, unsigned char, unsigned short)>
    
    /* Open EP OUT */
    USBD_LL_OpenEP(pdev,
                   CDC_OUT_EP,
                   USBD_EP_TYPE_BULK,
                   CDC_DATA_FS_OUT_PACKET_SIZE);
 8000d56:	6878      	ldr	r0, [r7, #4]
 8000d58:	f04f 0101 	mov.w	r1, #1
 8000d5c:	f04f 0202 	mov.w	r2, #2
 8000d60:	f04f 0340 	mov.w	r3, #64	; 0x40
 8000d64:	f7ff fd32 	bl	80007cc <USBD_LL_OpenEP(_USBD_HandleTypeDef*, unsigned char, unsigned char, unsigned short)>
  }
  /* Open Command IN EP */
  USBD_LL_OpenEP(pdev,
                 CDC_CMD_EP,
                 USBD_EP_TYPE_INTR,
                 CDC_CMD_PACKET_SIZE);
 8000d68:	6878      	ldr	r0, [r7, #4]
 8000d6a:	f04f 0182 	mov.w	r1, #130	; 0x82
 8000d6e:	f04f 0203 	mov.w	r2, #3
 8000d72:	f04f 0308 	mov.w	r3, #8
 8000d76:	f7ff fd29 	bl	80007cc <USBD_LL_OpenEP(_USBD_HandleTypeDef*, unsigned char, unsigned char, unsigned short)>
  
    
  pdev->pClassData = USBD_malloc(sizeof (USBD_CDC_HandleTypeDef));
 8000d7a:	f44f 7007 	mov.w	r0, #540	; 0x21c
 8000d7e:	f7ff fe0d 	bl	800099c <USBD_static_malloc(unsigned long)>
 8000d82:	4602      	mov	r2, r0
 8000d84:	687b      	ldr	r3, [r7, #4]
 8000d86:	f8c3 2218 	str.w	r2, [r3, #536]	; 0x218
  
  if(pdev->pClassData == NULL)
 8000d8a:	687b      	ldr	r3, [r7, #4]
 8000d8c:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8000d90:	2b00      	cmp	r3, #0
 8000d92:	d103      	bne.n	8000d9c <USBD_CDC_Init(_USBD_HandleTypeDef*, unsigned char)+0x98>
  {
    ret = 1; 
 8000d94:	f04f 0301 	mov.w	r3, #1
 8000d98:	73fb      	strb	r3, [r7, #15]
 8000d9a:	e02d      	b.n	8000df8 <USBD_CDC_Init(_USBD_HandleTypeDef*, unsigned char)+0xf4>
  }
  else
  {
    hcdc = pdev->pClassData;
 8000d9c:	687b      	ldr	r3, [r7, #4]
 8000d9e:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8000da2:	60bb      	str	r3, [r7, #8]
    
    /* Init  physical Interface components */
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Init();
 8000da4:	687b      	ldr	r3, [r7, #4]
 8000da6:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 8000daa:	681b      	ldr	r3, [r3, #0]
 8000dac:	4798      	blx	r3
    
    /* Init Xfer states */
    hcdc->TxState =0;
 8000dae:	68bb      	ldr	r3, [r7, #8]
 8000db0:	f04f 0200 	mov.w	r2, #0
 8000db4:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
    hcdc->RxState =0;
 8000db8:	68bb      	ldr	r3, [r7, #8]
 8000dba:	f04f 0200 	mov.w	r2, #0
 8000dbe:	f8c3 2218 	str.w	r2, [r3, #536]	; 0x218
       
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8000dc2:	687b      	ldr	r3, [r7, #4]
 8000dc4:	7c1b      	ldrb	r3, [r3, #16]
 8000dc6:	2b00      	cmp	r3, #0
 8000dc8:	d10b      	bne.n	8000de2 <USBD_CDC_Init(_USBD_HandleTypeDef*, unsigned char)+0xde>
    {      
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
                             CDC_OUT_EP,
                             hcdc->RxBuffer,
                             CDC_DATA_HS_OUT_PACKET_SIZE);
 8000dca:	68bb      	ldr	r3, [r7, #8]
 8000dcc:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
 8000dd0:	6878      	ldr	r0, [r7, #4]
 8000dd2:	f04f 0101 	mov.w	r1, #1
 8000dd6:	461a      	mov	r2, r3
 8000dd8:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000ddc:	f7ff fdb0 	bl	8000940 <USBD_LL_PrepareReceive(_USBD_HandleTypeDef*, unsigned char, unsigned char*, unsigned short)>
 8000de0:	e00a      	b.n	8000df8 <USBD_CDC_Init(_USBD_HandleTypeDef*, unsigned char)+0xf4>
    {
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
                             CDC_OUT_EP,
                             hcdc->RxBuffer,
                             CDC_DATA_FS_OUT_PACKET_SIZE);
 8000de2:	68bb      	ldr	r3, [r7, #8]
 8000de4:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
 8000de8:	6878      	ldr	r0, [r7, #4]
 8000dea:	f04f 0101 	mov.w	r1, #1
 8000dee:	461a      	mov	r2, r3
 8000df0:	f04f 0340 	mov.w	r3, #64	; 0x40
 8000df4:	f7ff fda4 	bl	8000940 <USBD_LL_PrepareReceive(_USBD_HandleTypeDef*, unsigned char, unsigned char*, unsigned short)>
    }
    
    
  }
  return ret;
 8000df8:	7bfb      	ldrb	r3, [r7, #15]
}
 8000dfa:	4618      	mov	r0, r3
 8000dfc:	f107 0710 	add.w	r7, r7, #16
 8000e00:	46bd      	mov	sp, r7
 8000e02:	bd80      	pop	{r7, pc}

08000e04 <USBD_CDC_DeInit(_USBD_HandleTypeDef*, unsigned char)>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  USBD_CDC_DeInit (USBD_HandleTypeDef *pdev, 
                                 uint8_t cfgidx)
{
 8000e04:	b580      	push	{r7, lr}
 8000e06:	b084      	sub	sp, #16
 8000e08:	af00      	add	r7, sp, #0
 8000e0a:	6078      	str	r0, [r7, #4]
 8000e0c:	460b      	mov	r3, r1
 8000e0e:	70fb      	strb	r3, [r7, #3]
  uint8_t ret = 0;
 8000e10:	f04f 0300 	mov.w	r3, #0
 8000e14:	73fb      	strb	r3, [r7, #15]
  
  /* Open EP IN */
  USBD_LL_CloseEP(pdev,
              CDC_IN_EP);
 8000e16:	6878      	ldr	r0, [r7, #4]
 8000e18:	f04f 0181 	mov.w	r1, #129	; 0x81
 8000e1c:	f7ff fcec 	bl	80007f8 <USBD_LL_CloseEP(_USBD_HandleTypeDef*, unsigned char)>
  
  /* Open EP OUT */
  USBD_LL_CloseEP(pdev,
              CDC_OUT_EP);
 8000e20:	6878      	ldr	r0, [r7, #4]
 8000e22:	f04f 0101 	mov.w	r1, #1
 8000e26:	f7ff fce7 	bl	80007f8 <USBD_LL_CloseEP(_USBD_HandleTypeDef*, unsigned char)>
  
  /* Open Command IN EP */
  USBD_LL_CloseEP(pdev,
              CDC_CMD_EP);
 8000e2a:	6878      	ldr	r0, [r7, #4]
 8000e2c:	f04f 0182 	mov.w	r1, #130	; 0x82
 8000e30:	f7ff fce2 	bl	80007f8 <USBD_LL_CloseEP(_USBD_HandleTypeDef*, unsigned char)>
  
  
  /* DeInit  physical Interface components */
  if(pdev->pClassData != NULL)
 8000e34:	687b      	ldr	r3, [r7, #4]
 8000e36:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8000e3a:	2b00      	cmp	r3, #0
 8000e3c:	d00f      	beq.n	8000e5e <USBD_CDC_DeInit(_USBD_HandleTypeDef*, unsigned char)+0x5a>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->DeInit();
 8000e3e:	687b      	ldr	r3, [r7, #4]
 8000e40:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 8000e44:	685b      	ldr	r3, [r3, #4]
 8000e46:	4798      	blx	r3
    USBD_free(pdev->pClassData);
 8000e48:	687b      	ldr	r3, [r7, #4]
 8000e4a:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8000e4e:	4618      	mov	r0, r3
 8000e50:	f7ff fdb2 	bl	80009b8 <USBD_static_free(void*)>
    pdev->pClassData = NULL;
 8000e54:	687b      	ldr	r3, [r7, #4]
 8000e56:	f04f 0200 	mov.w	r2, #0
 8000e5a:	f8c3 2218 	str.w	r2, [r3, #536]	; 0x218
  }
  
  return ret;
 8000e5e:	7bfb      	ldrb	r3, [r7, #15]
}
 8000e60:	4618      	mov	r0, r3
 8000e62:	f107 0710 	add.w	r7, r7, #16
 8000e66:	46bd      	mov	sp, r7
 8000e68:	bd80      	pop	{r7, pc}
 8000e6a:	bf00      	nop

08000e6c <USBD_CDC_Setup(_USBD_HandleTypeDef*, usb_setup_req*)>:
  * @param  req: usb requests
  * @retval status
  */
static uint8_t  USBD_CDC_Setup (USBD_HandleTypeDef *pdev, 
                                USBD_SetupReqTypedef *req)
{
 8000e6c:	b580      	push	{r7, lr}
 8000e6e:	b084      	sub	sp, #16
 8000e70:	af00      	add	r7, sp, #0
 8000e72:	6078      	str	r0, [r7, #4]
 8000e74:	6039      	str	r1, [r7, #0]
  USBD_CDC_HandleTypeDef   *hcdc = pdev->pClassData;
 8000e76:	687b      	ldr	r3, [r7, #4]
 8000e78:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8000e7c:	60fb      	str	r3, [r7, #12]
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8000e7e:	683b      	ldr	r3, [r7, #0]
 8000e80:	781b      	ldrb	r3, [r3, #0]
 8000e82:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8000e86:	2b20      	cmp	r3, #32
 8000e88:	d13d      	bne.n	8000f06 <USBD_CDC_Setup(_USBD_HandleTypeDef*, usb_setup_req*)+0x9a>
  {
  case USB_REQ_TYPE_CLASS :
    if (req->wLength)
 8000e8a:	683b      	ldr	r3, [r7, #0]
 8000e8c:	88db      	ldrh	r3, [r3, #6]
 8000e8e:	2b00      	cmp	r3, #0
 8000e90:	d02c      	beq.n	8000eec <USBD_CDC_Setup(_USBD_HandleTypeDef*, usb_setup_req*)+0x80>
    {
      if (req->bmRequest & 0x80)
 8000e92:	683b      	ldr	r3, [r7, #0]
 8000e94:	781b      	ldrb	r3, [r3, #0]
 8000e96:	b2db      	uxtb	r3, r3
 8000e98:	b25b      	sxtb	r3, r3
 8000e9a:	2b00      	cmp	r3, #0
 8000e9c:	da12      	bge.n	8000ec4 <USBD_CDC_Setup(_USBD_HandleTypeDef*, usb_setup_req*)+0x58>
      {
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
                                                          (uint8_t *)hcdc->data,
                                                          req->wLength);
 8000e9e:	687b      	ldr	r3, [r7, #4]
 8000ea0:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 8000ea4:	689b      	ldr	r3, [r3, #8]
 8000ea6:	683a      	ldr	r2, [r7, #0]
 8000ea8:	7850      	ldrb	r0, [r2, #1]
 8000eaa:	68f9      	ldr	r1, [r7, #12]
 8000eac:	683a      	ldr	r2, [r7, #0]
 8000eae:	88d2      	ldrh	r2, [r2, #6]
 8000eb0:	4798      	blx	r3
          USBD_CtlSendData (pdev, 
                            (uint8_t *)hcdc->data,
                            req->wLength);
 8000eb2:	68fa      	ldr	r2, [r7, #12]
 8000eb4:	683b      	ldr	r3, [r7, #0]
 8000eb6:	88db      	ldrh	r3, [r3, #6]
 8000eb8:	6878      	ldr	r0, [r7, #4]
 8000eba:	4611      	mov	r1, r2
 8000ebc:	461a      	mov	r2, r3
 8000ebe:	f001 f87f 	bl	8001fc0 <USBD_CtlSendData(_USBD_HandleTypeDef*, unsigned char*, unsigned short)>
    {
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
                                                          NULL,
                                                          0);
    }
    break;
 8000ec2:	e021      	b.n	8000f08 <USBD_CDC_Setup(_USBD_HandleTypeDef*, usb_setup_req*)+0x9c>
                            (uint8_t *)hcdc->data,
                            req->wLength);
      }
      else
      {
        hcdc->CmdOpCode = req->bRequest;
 8000ec4:	683b      	ldr	r3, [r7, #0]
 8000ec6:	785a      	ldrb	r2, [r3, #1]
 8000ec8:	68fb      	ldr	r3, [r7, #12]
 8000eca:	f883 2200 	strb.w	r2, [r3, #512]	; 0x200
        hcdc->CmdLength = req->wLength;
 8000ece:	683b      	ldr	r3, [r7, #0]
 8000ed0:	88db      	ldrh	r3, [r3, #6]
 8000ed2:	b2da      	uxtb	r2, r3
 8000ed4:	68fb      	ldr	r3, [r7, #12]
 8000ed6:	f883 2201 	strb.w	r2, [r3, #513]	; 0x201
        
        USBD_CtlPrepareRx (pdev, 
                           (uint8_t *)hcdc->data,
                           req->wLength);
 8000eda:	68fa      	ldr	r2, [r7, #12]
 8000edc:	683b      	ldr	r3, [r7, #0]
 8000ede:	88db      	ldrh	r3, [r3, #6]
 8000ee0:	6878      	ldr	r0, [r7, #4]
 8000ee2:	4611      	mov	r1, r2
 8000ee4:	461a      	mov	r2, r3
 8000ee6:	f001 f8a1 	bl	800202c <USBD_CtlPrepareRx(_USBD_HandleTypeDef*, unsigned char*, unsigned short)>
    {
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
                                                          NULL,
                                                          0);
    }
    break;
 8000eea:	e00d      	b.n	8000f08 <USBD_CDC_Setup(_USBD_HandleTypeDef*, usb_setup_req*)+0x9c>
    }
    else
    {
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
                                                          NULL,
                                                          0);
 8000eec:	687b      	ldr	r3, [r7, #4]
 8000eee:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 8000ef2:	689b      	ldr	r3, [r3, #8]
 8000ef4:	683a      	ldr	r2, [r7, #0]
 8000ef6:	7852      	ldrb	r2, [r2, #1]
 8000ef8:	4610      	mov	r0, r2
 8000efa:	f04f 0100 	mov.w	r1, #0
 8000efe:	f04f 0200 	mov.w	r2, #0
 8000f02:	4798      	blx	r3
    }
    break;
 8000f04:	e000      	b.n	8000f08 <USBD_CDC_Setup(_USBD_HandleTypeDef*, usb_setup_req*)+0x9c>
 
  default: 
    break;
 8000f06:	bf00      	nop
  }
  return USBD_OK;
 8000f08:	f04f 0300 	mov.w	r3, #0
}
 8000f0c:	4618      	mov	r0, r3
 8000f0e:	f107 0710 	add.w	r7, r7, #16
 8000f12:	46bd      	mov	sp, r7
 8000f14:	bd80      	pop	{r7, pc}
 8000f16:	bf00      	nop

08000f18 <USBD_CDC_DataIn(_USBD_HandleTypeDef*, unsigned char)>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  USBD_CDC_DataIn (USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 8000f18:	b480      	push	{r7}
 8000f1a:	b085      	sub	sp, #20
 8000f1c:	af00      	add	r7, sp, #0
 8000f1e:	6078      	str	r0, [r7, #4]
 8000f20:	460b      	mov	r3, r1
 8000f22:	70fb      	strb	r3, [r7, #3]
  USBD_CDC_HandleTypeDef   *hcdc = pdev->pClassData;
 8000f24:	687b      	ldr	r3, [r7, #4]
 8000f26:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8000f2a:	60fb      	str	r3, [r7, #12]
  
  if(pdev->pClassData != NULL)
 8000f2c:	687b      	ldr	r3, [r7, #4]
 8000f2e:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8000f32:	2b00      	cmp	r3, #0
 8000f34:	d007      	beq.n	8000f46 <USBD_CDC_DataIn(_USBD_HandleTypeDef*, unsigned char)+0x2e>
  {
    
    hcdc->TxState = 0;
 8000f36:	68fb      	ldr	r3, [r7, #12]
 8000f38:	f04f 0200 	mov.w	r2, #0
 8000f3c:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214

    return USBD_OK;
 8000f40:	f04f 0300 	mov.w	r3, #0
 8000f44:	e001      	b.n	8000f4a <USBD_CDC_DataIn(_USBD_HandleTypeDef*, unsigned char)+0x32>
  }
  else
  {
    return USBD_FAIL;
 8000f46:	f04f 0302 	mov.w	r3, #2
  }
}
 8000f4a:	4618      	mov	r0, r3
 8000f4c:	f107 0714 	add.w	r7, r7, #20
 8000f50:	46bd      	mov	sp, r7
 8000f52:	bc80      	pop	{r7}
 8000f54:	4770      	bx	lr
 8000f56:	bf00      	nop

08000f58 <USBD_CDC_DataOut(_USBD_HandleTypeDef*, unsigned char)>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  USBD_CDC_DataOut (USBD_HandleTypeDef *pdev, uint8_t epnum)
{      
 8000f58:	b580      	push	{r7, lr}
 8000f5a:	b084      	sub	sp, #16
 8000f5c:	af00      	add	r7, sp, #0
 8000f5e:	6078      	str	r0, [r7, #4]
 8000f60:	460b      	mov	r3, r1
 8000f62:	70fb      	strb	r3, [r7, #3]
  USBD_CDC_HandleTypeDef   *hcdc = pdev->pClassData;
 8000f64:	687b      	ldr	r3, [r7, #4]
 8000f66:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8000f6a:	60fb      	str	r3, [r7, #12]
  
  /* Get the received data length */
  hcdc->RxLength = USBD_LL_GetRxDataSize (pdev, epnum);
 8000f6c:	78fb      	ldrb	r3, [r7, #3]
 8000f6e:	6878      	ldr	r0, [r7, #4]
 8000f70:	4619      	mov	r1, r3
 8000f72:	f7ff fcff 	bl	8000974 <USBD_LL_GetRxDataSize(_USBD_HandleTypeDef*, unsigned char)>
 8000f76:	4602      	mov	r2, r0
 8000f78:	68fb      	ldr	r3, [r7, #12]
 8000f7a:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c
  
  /* USB data will be immediately processed, this allow next USB traffic being 
  NAKed till the end of the application Xfer */
  if(pdev->pClassData != NULL)
 8000f7e:	687b      	ldr	r3, [r7, #4]
 8000f80:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8000f84:	2b00      	cmp	r3, #0
 8000f86:	d00f      	beq.n	8000fa8 <USBD_CDC_DataOut(_USBD_HandleTypeDef*, unsigned char)+0x50>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 8000f88:	687b      	ldr	r3, [r7, #4]
 8000f8a:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 8000f8e:	68db      	ldr	r3, [r3, #12]
 8000f90:	68fa      	ldr	r2, [r7, #12]
 8000f92:	f8d2 1204 	ldr.w	r1, [r2, #516]	; 0x204
 8000f96:	68fa      	ldr	r2, [r7, #12]
 8000f98:	f502 7203 	add.w	r2, r2, #524	; 0x20c
 8000f9c:	4608      	mov	r0, r1
 8000f9e:	4611      	mov	r1, r2
 8000fa0:	4798      	blx	r3

    return USBD_OK;
 8000fa2:	f04f 0300 	mov.w	r3, #0
 8000fa6:	e001      	b.n	8000fac <USBD_CDC_DataOut(_USBD_HandleTypeDef*, unsigned char)+0x54>
  }
  else
  {
    return USBD_FAIL;
 8000fa8:	f04f 0302 	mov.w	r3, #2
  }
}
 8000fac:	4618      	mov	r0, r3
 8000fae:	f107 0710 	add.w	r7, r7, #16
 8000fb2:	46bd      	mov	sp, r7
 8000fb4:	bd80      	pop	{r7, pc}
 8000fb6:	bf00      	nop

08000fb8 <USBD_CDC_EP0_RxReady(_USBD_HandleTypeDef*)>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  USBD_CDC_EP0_RxReady (USBD_HandleTypeDef *pdev)
{ 
 8000fb8:	b580      	push	{r7, lr}
 8000fba:	b084      	sub	sp, #16
 8000fbc:	af00      	add	r7, sp, #0
 8000fbe:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef   *hcdc = pdev->pClassData;
 8000fc0:	687b      	ldr	r3, [r7, #4]
 8000fc2:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8000fc6:	60fb      	str	r3, [r7, #12]
  
  if((pdev->pUserData != NULL) && (hcdc->CmdOpCode != 0xFF))
 8000fc8:	687b      	ldr	r3, [r7, #4]
 8000fca:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 8000fce:	2b00      	cmp	r3, #0
 8000fd0:	d015      	beq.n	8000ffe <USBD_CDC_EP0_RxReady(_USBD_HandleTypeDef*)+0x46>
 8000fd2:	68fb      	ldr	r3, [r7, #12]
 8000fd4:	f893 3200 	ldrb.w	r3, [r3, #512]	; 0x200
 8000fd8:	2bff      	cmp	r3, #255	; 0xff
 8000fda:	d010      	beq.n	8000ffe <USBD_CDC_EP0_RxReady(_USBD_HandleTypeDef*)+0x46>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(hcdc->CmdOpCode,
                                                      (uint8_t *)hcdc->data,
                                                      hcdc->CmdLength);
 8000fdc:	687b      	ldr	r3, [r7, #4]
 8000fde:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 8000fe2:	689b      	ldr	r3, [r3, #8]
 8000fe4:	68fa      	ldr	r2, [r7, #12]
 8000fe6:	f892 0200 	ldrb.w	r0, [r2, #512]	; 0x200
 8000fea:	68f9      	ldr	r1, [r7, #12]
 8000fec:	68fa      	ldr	r2, [r7, #12]
 8000fee:	f892 2201 	ldrb.w	r2, [r2, #513]	; 0x201
 8000ff2:	4798      	blx	r3
      hcdc->CmdOpCode = 0xFF; 
 8000ff4:	68fb      	ldr	r3, [r7, #12]
 8000ff6:	f04f 02ff 	mov.w	r2, #255	; 0xff
 8000ffa:	f883 2200 	strb.w	r2, [r3, #512]	; 0x200
      
  }
  return USBD_OK;
 8000ffe:	f04f 0300 	mov.w	r3, #0
}
 8001002:	4618      	mov	r0, r3
 8001004:	f107 0710 	add.w	r7, r7, #16
 8001008:	46bd      	mov	sp, r7
 800100a:	bd80      	pop	{r7, pc}

0800100c <USBD_CDC_GetFSCfgDesc(unsigned short*)>:
  * @param  speed : current device speed
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetFSCfgDesc (uint16_t *length)
{
 800100c:	b480      	push	{r7}
 800100e:	b083      	sub	sp, #12
 8001010:	af00      	add	r7, sp, #0
 8001012:	6078      	str	r0, [r7, #4]
  *length = sizeof (USBD_CDC_CfgFSDesc);
 8001014:	687b      	ldr	r3, [r7, #4]
 8001016:	f04f 0243 	mov.w	r2, #67	; 0x43
 800101a:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgFSDesc;
 800101c:	f240 03d0 	movw	r3, #208	; 0xd0
 8001020:	f2c2 0300 	movt	r3, #8192	; 0x2000
}
 8001024:	4618      	mov	r0, r3
 8001026:	f107 070c 	add.w	r7, r7, #12
 800102a:	46bd      	mov	sp, r7
 800102c:	bc80      	pop	{r7}
 800102e:	4770      	bx	lr

08001030 <USBD_CDC_GetHSCfgDesc(unsigned short*)>:
  * @param  speed : current device speed
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetHSCfgDesc (uint16_t *length)
{
 8001030:	b480      	push	{r7}
 8001032:	b083      	sub	sp, #12
 8001034:	af00      	add	r7, sp, #0
 8001036:	6078      	str	r0, [r7, #4]
  *length = sizeof (USBD_CDC_CfgHSDesc);
 8001038:	687b      	ldr	r3, [r7, #4]
 800103a:	f04f 0243 	mov.w	r2, #67	; 0x43
 800103e:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgHSDesc;
 8001040:	f240 038c 	movw	r3, #140	; 0x8c
 8001044:	f2c2 0300 	movt	r3, #8192	; 0x2000
}
 8001048:	4618      	mov	r0, r3
 800104a:	f107 070c 	add.w	r7, r7, #12
 800104e:	46bd      	mov	sp, r7
 8001050:	bc80      	pop	{r7}
 8001052:	4770      	bx	lr

08001054 <USBD_CDC_GetOtherSpeedCfgDesc(unsigned short*)>:
  * @param  speed : current device speed
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetOtherSpeedCfgDesc (uint16_t *length)
{
 8001054:	b480      	push	{r7}
 8001056:	b083      	sub	sp, #12
 8001058:	af00      	add	r7, sp, #0
 800105a:	6078      	str	r0, [r7, #4]
  *length = sizeof (USBD_CDC_OtherSpeedCfgDesc);
 800105c:	687b      	ldr	r3, [r7, #4]
 800105e:	f04f 0243 	mov.w	r2, #67	; 0x43
 8001062:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_OtherSpeedCfgDesc;
 8001064:	f240 1314 	movw	r3, #276	; 0x114
 8001068:	f2c2 0300 	movt	r3, #8192	; 0x2000
}
 800106c:	4618      	mov	r0, r3
 800106e:	f107 070c 	add.w	r7, r7, #12
 8001072:	46bd      	mov	sp, r7
 8001074:	bc80      	pop	{r7}
 8001076:	4770      	bx	lr

08001078 <USBD_CDC_GetDeviceQualifierDescriptor(unsigned short*)>:
*         return Device Qualifier descriptor
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_CDC_GetDeviceQualifierDescriptor (uint16_t *length)
{
 8001078:	b480      	push	{r7}
 800107a:	b083      	sub	sp, #12
 800107c:	af00      	add	r7, sp, #0
 800107e:	6078      	str	r0, [r7, #4]
  *length = sizeof (USBD_CDC_DeviceQualifierDesc);
 8001080:	687b      	ldr	r3, [r7, #4]
 8001082:	f04f 020a 	mov.w	r2, #10
 8001086:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_DeviceQualifierDesc;
 8001088:	f240 0348 	movw	r3, #72	; 0x48
 800108c:	f2c2 0300 	movt	r3, #8192	; 0x2000
}
 8001090:	4618      	mov	r0, r3
 8001092:	f107 070c 	add.w	r7, r7, #12
 8001096:	46bd      	mov	sp, r7
 8001098:	bc80      	pop	{r7}
 800109a:	4770      	bx	lr

0800109c <USBD_CDC_RegisterInterface(_USBD_HandleTypeDef*, _USBD_CDC_Itf*)>:
  * @param  fops: CD  Interface callback
  * @retval status
  */
uint8_t  USBD_CDC_RegisterInterface  (USBD_HandleTypeDef   *pdev, 
                                      USBD_CDC_ItfTypeDef *fops)
{
 800109c:	b480      	push	{r7}
 800109e:	b085      	sub	sp, #20
 80010a0:	af00      	add	r7, sp, #0
 80010a2:	6078      	str	r0, [r7, #4]
 80010a4:	6039      	str	r1, [r7, #0]
  uint8_t  ret = USBD_FAIL;
 80010a6:	f04f 0302 	mov.w	r3, #2
 80010aa:	73fb      	strb	r3, [r7, #15]
  
  if(fops != NULL)
 80010ac:	683b      	ldr	r3, [r7, #0]
 80010ae:	2b00      	cmp	r3, #0
 80010b0:	d006      	beq.n	80010c0 <USBD_CDC_RegisterInterface(_USBD_HandleTypeDef*, _USBD_CDC_Itf*)+0x24>
  {
    pdev->pUserData= fops;
 80010b2:	687b      	ldr	r3, [r7, #4]
 80010b4:	683a      	ldr	r2, [r7, #0]
 80010b6:	f8c3 221c 	str.w	r2, [r3, #540]	; 0x21c
    ret = USBD_OK;    
 80010ba:	f04f 0300 	mov.w	r3, #0
 80010be:	73fb      	strb	r3, [r7, #15]
  }
  
  return ret;
 80010c0:	7bfb      	ldrb	r3, [r7, #15]
}
 80010c2:	4618      	mov	r0, r3
 80010c4:	f107 0714 	add.w	r7, r7, #20
 80010c8:	46bd      	mov	sp, r7
 80010ca:	bc80      	pop	{r7}
 80010cc:	4770      	bx	lr
 80010ce:	bf00      	nop

080010d0 <USBD_CDC_SetTxBuffer(_USBD_HandleTypeDef*, unsigned char*, unsigned short)>:
  * @retval status
  */
uint8_t  USBD_CDC_SetTxBuffer  (USBD_HandleTypeDef   *pdev,
                                uint8_t  *pbuff,
                                uint16_t length)
{
 80010d0:	b480      	push	{r7}
 80010d2:	b087      	sub	sp, #28
 80010d4:	af00      	add	r7, sp, #0
 80010d6:	60f8      	str	r0, [r7, #12]
 80010d8:	60b9      	str	r1, [r7, #8]
 80010da:	4613      	mov	r3, r2
 80010dc:	80fb      	strh	r3, [r7, #6]
  USBD_CDC_HandleTypeDef   *hcdc = pdev->pClassData;
 80010de:	68fb      	ldr	r3, [r7, #12]
 80010e0:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 80010e4:	617b      	str	r3, [r7, #20]
  
  hcdc->TxBuffer = pbuff;
 80010e6:	697b      	ldr	r3, [r7, #20]
 80010e8:	68ba      	ldr	r2, [r7, #8]
 80010ea:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
  hcdc->TxLength = length;  
 80010ee:	88fa      	ldrh	r2, [r7, #6]
 80010f0:	697b      	ldr	r3, [r7, #20]
 80010f2:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
  
  return USBD_OK;  
 80010f6:	f04f 0300 	mov.w	r3, #0
}
 80010fa:	4618      	mov	r0, r3
 80010fc:	f107 071c 	add.w	r7, r7, #28
 8001100:	46bd      	mov	sp, r7
 8001102:	bc80      	pop	{r7}
 8001104:	4770      	bx	lr
 8001106:	bf00      	nop

08001108 <USBD_CDC_SetRxBuffer(_USBD_HandleTypeDef*, unsigned char*)>:
  * @param  pbuff: Rx Buffer
  * @retval status
  */
uint8_t  USBD_CDC_SetRxBuffer  (USBD_HandleTypeDef   *pdev,
                                   uint8_t  *pbuff)
{
 8001108:	b480      	push	{r7}
 800110a:	b085      	sub	sp, #20
 800110c:	af00      	add	r7, sp, #0
 800110e:	6078      	str	r0, [r7, #4]
 8001110:	6039      	str	r1, [r7, #0]
  USBD_CDC_HandleTypeDef   *hcdc = pdev->pClassData;
 8001112:	687b      	ldr	r3, [r7, #4]
 8001114:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8001118:	60fb      	str	r3, [r7, #12]
  
  hcdc->RxBuffer = pbuff;
 800111a:	68fb      	ldr	r3, [r7, #12]
 800111c:	683a      	ldr	r2, [r7, #0]
 800111e:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
  
  return USBD_OK;
 8001122:	f04f 0300 	mov.w	r3, #0
}
 8001126:	4618      	mov	r0, r3
 8001128:	f107 0714 	add.w	r7, r7, #20
 800112c:	46bd      	mov	sp, r7
 800112e:	bc80      	pop	{r7}
 8001130:	4770      	bx	lr
 8001132:	bf00      	nop

08001134 <USBD_Init(_USBD_HandleTypeDef*, USBD_DescriptorsTypeDef*, unsigned char)>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 8001134:	b580      	push	{r7, lr}
 8001136:	b084      	sub	sp, #16
 8001138:	af00      	add	r7, sp, #0
 800113a:	60f8      	str	r0, [r7, #12]
 800113c:	60b9      	str	r1, [r7, #8]
 800113e:	4613      	mov	r3, r2
 8001140:	71fb      	strb	r3, [r7, #7]
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
 8001142:	68fb      	ldr	r3, [r7, #12]
 8001144:	2b00      	cmp	r3, #0
 8001146:	d102      	bne.n	800114e <USBD_Init(_USBD_HandleTypeDef*, USBD_DescriptorsTypeDef*, unsigned char)+0x1a>
  {
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
 8001148:	f04f 0302 	mov.w	r3, #2
 800114c:	e01d      	b.n	800118a <USBD_Init(_USBD_HandleTypeDef*, USBD_DescriptorsTypeDef*, unsigned char)+0x56>
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
 800114e:	68fb      	ldr	r3, [r7, #12]
 8001150:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8001154:	2b00      	cmp	r3, #0
 8001156:	d004      	beq.n	8001162 <USBD_Init(_USBD_HandleTypeDef*, USBD_DescriptorsTypeDef*, unsigned char)+0x2e>
  {
    pdev->pClass = NULL;
 8001158:	68fb      	ldr	r3, [r7, #12]
 800115a:	f04f 0200 	mov.w	r2, #0
 800115e:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
 8001162:	68bb      	ldr	r3, [r7, #8]
 8001164:	2b00      	cmp	r3, #0
 8001166:	d003      	beq.n	8001170 <USBD_Init(_USBD_HandleTypeDef*, USBD_DescriptorsTypeDef*, unsigned char)+0x3c>
  {
    pdev->pDesc = pdesc;
 8001168:	68fb      	ldr	r3, [r7, #12]
 800116a:	68ba      	ldr	r2, [r7, #8]
 800116c:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
 8001170:	68fb      	ldr	r3, [r7, #12]
 8001172:	f04f 0201 	mov.w	r2, #1
 8001176:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
  pdev->id = id;
 800117a:	68fb      	ldr	r3, [r7, #12]
 800117c:	79fa      	ldrb	r2, [r7, #7]
 800117e:	701a      	strb	r2, [r3, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
 8001180:	68f8      	ldr	r0, [r7, #12]
 8001182:	f7ff fa7b 	bl	800067c <USBD_LL_Init(_USBD_HandleTypeDef*)>
  
  return USBD_OK; 
 8001186:	f04f 0300 	mov.w	r3, #0
}
 800118a:	4618      	mov	r0, r3
 800118c:	f107 0710 	add.w	r7, r7, #16
 8001190:	46bd      	mov	sp, r7
 8001192:	bd80      	pop	{r7, pc}

08001194 <USBD_RegisterClass(_USBD_HandleTypeDef*, _Device_cb*)>:
  * @param  pDevice : Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
 8001194:	b480      	push	{r7}
 8001196:	b085      	sub	sp, #20
 8001198:	af00      	add	r7, sp, #0
 800119a:	6078      	str	r0, [r7, #4]
 800119c:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef   status = USBD_OK;
 800119e:	f04f 0300 	mov.w	r3, #0
 80011a2:	73fb      	strb	r3, [r7, #15]
  if(pclass != 0)
 80011a4:	683b      	ldr	r3, [r7, #0]
 80011a6:	2b00      	cmp	r3, #0
 80011a8:	d007      	beq.n	80011ba <USBD_RegisterClass(_USBD_HandleTypeDef*, _Device_cb*)+0x26>
  {
    /* link the class tgo the USB Device handle */
    pdev->pClass = pclass;
 80011aa:	687b      	ldr	r3, [r7, #4]
 80011ac:	683a      	ldr	r2, [r7, #0]
 80011ae:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
    status = USBD_OK;
 80011b2:	f04f 0300 	mov.w	r3, #0
 80011b6:	73fb      	strb	r3, [r7, #15]
 80011b8:	e002      	b.n	80011c0 <USBD_RegisterClass(_USBD_HandleTypeDef*, _Device_cb*)+0x2c>
  }
  else
  {
    USBD_ErrLog("Invalid Class handle");
    status = USBD_FAIL; 
 80011ba:	f04f 0302 	mov.w	r3, #2
 80011be:	73fb      	strb	r3, [r7, #15]
  }
  
  return status;
 80011c0:	7bfb      	ldrb	r3, [r7, #15]
}
 80011c2:	4618      	mov	r0, r3
 80011c4:	f107 0714 	add.w	r7, r7, #20
 80011c8:	46bd      	mov	sp, r7
 80011ca:	bc80      	pop	{r7}
 80011cc:	4770      	bx	lr
 80011ce:	bf00      	nop

080011d0 <USBD_Start(_USBD_HandleTypeDef*)>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
 80011d0:	b580      	push	{r7, lr}
 80011d2:	b082      	sub	sp, #8
 80011d4:	af00      	add	r7, sp, #0
 80011d6:	6078      	str	r0, [r7, #4]
  
  /* Start the low level driver  */
  USBD_LL_Start(pdev); 
 80011d8:	6878      	ldr	r0, [r7, #4]
 80011da:	f7ff fae5 	bl	80007a8 <USBD_LL_Start(_USBD_HandleTypeDef*)>
  
  return USBD_OK;  
 80011de:	f04f 0300 	mov.w	r3, #0
}
 80011e2:	4618      	mov	r0, r3
 80011e4:	f107 0708 	add.w	r7, r7, #8
 80011e8:	46bd      	mov	sp, r7
 80011ea:	bd80      	pop	{r7, pc}

080011ec <USBD_RunTestMode(_USBD_HandleTypeDef*)>:
*         Launch test mode process
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_RunTestMode (USBD_HandleTypeDef  *pdev) 
{
 80011ec:	b480      	push	{r7}
 80011ee:	b083      	sub	sp, #12
 80011f0:	af00      	add	r7, sp, #0
 80011f2:	6078      	str	r0, [r7, #4]
  return USBD_OK;
 80011f4:	f04f 0300 	mov.w	r3, #0
}
 80011f8:	4618      	mov	r0, r3
 80011fa:	f107 070c 	add.w	r7, r7, #12
 80011fe:	46bd      	mov	sp, r7
 8001200:	bc80      	pop	{r7}
 8001202:	4770      	bx	lr

08001204 <USBD_SetClassConfig(_USBD_HandleTypeDef*, unsigned char)>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8001204:	b580      	push	{r7, lr}
 8001206:	b084      	sub	sp, #16
 8001208:	af00      	add	r7, sp, #0
 800120a:	6078      	str	r0, [r7, #4]
 800120c:	460b      	mov	r3, r1
 800120e:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef   ret = USBD_FAIL;
 8001210:	f04f 0302 	mov.w	r3, #2
 8001214:	73fb      	strb	r3, [r7, #15]
  
  if(pdev->pClass != NULL)
 8001216:	687b      	ldr	r3, [r7, #4]
 8001218:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 800121c:	2b00      	cmp	r3, #0
 800121e:	d012      	beq.n	8001246 <USBD_SetClassConfig(_USBD_HandleTypeDef*, unsigned char)+0x42>
  {
    /* Set configuration  and Start the Class*/
    if(pdev->pClass->Init(pdev, cfgidx) == 0)
 8001220:	687b      	ldr	r3, [r7, #4]
 8001222:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8001226:	681b      	ldr	r3, [r3, #0]
 8001228:	78fa      	ldrb	r2, [r7, #3]
 800122a:	6878      	ldr	r0, [r7, #4]
 800122c:	4611      	mov	r1, r2
 800122e:	4798      	blx	r3
 8001230:	4603      	mov	r3, r0
 8001232:	2b00      	cmp	r3, #0
 8001234:	bf14      	ite	ne
 8001236:	2300      	movne	r3, #0
 8001238:	2301      	moveq	r3, #1
 800123a:	b2db      	uxtb	r3, r3
 800123c:	2b00      	cmp	r3, #0
 800123e:	d002      	beq.n	8001246 <USBD_SetClassConfig(_USBD_HandleTypeDef*, unsigned char)+0x42>
    {
      ret = USBD_OK;
 8001240:	f04f 0300 	mov.w	r3, #0
 8001244:	73fb      	strb	r3, [r7, #15]
    }
  }
  return ret; 
 8001246:	7bfb      	ldrb	r3, [r7, #15]
}
 8001248:	4618      	mov	r0, r3
 800124a:	f107 0710 	add.w	r7, r7, #16
 800124e:	46bd      	mov	sp, r7
 8001250:	bd80      	pop	{r7, pc}
 8001252:	bf00      	nop

08001254 <USBD_ClrClassConfig(_USBD_HandleTypeDef*, unsigned char)>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8001254:	b580      	push	{r7, lr}
 8001256:	b082      	sub	sp, #8
 8001258:	af00      	add	r7, sp, #0
 800125a:	6078      	str	r0, [r7, #4]
 800125c:	460b      	mov	r3, r1
 800125e:	70fb      	strb	r3, [r7, #3]
  /* Clear configuration  and Deinitialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);  
 8001260:	687b      	ldr	r3, [r7, #4]
 8001262:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8001266:	685b      	ldr	r3, [r3, #4]
 8001268:	78fa      	ldrb	r2, [r7, #3]
 800126a:	6878      	ldr	r0, [r7, #4]
 800126c:	4611      	mov	r1, r2
 800126e:	4798      	blx	r3
  return USBD_OK;
 8001270:	f04f 0300 	mov.w	r3, #0
}
 8001274:	4618      	mov	r0, r3
 8001276:	f107 0708 	add.w	r7, r7, #8
 800127a:	46bd      	mov	sp, r7
 800127c:	bd80      	pop	{r7, pc}
 800127e:	bf00      	nop

08001280 <USBD_LL_SetupStage(_USBD_HandleTypeDef*, unsigned char*)>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 8001280:	b580      	push	{r7, lr}
 8001282:	b082      	sub	sp, #8
 8001284:	af00      	add	r7, sp, #0
 8001286:	6078      	str	r0, [r7, #4]
 8001288:	6039      	str	r1, [r7, #0]

  USBD_ParseSetupRequest(&pdev->request, psetup);
 800128a:	687b      	ldr	r3, [r7, #4]
 800128c:	f503 7302 	add.w	r3, r3, #520	; 0x208
 8001290:	4618      	mov	r0, r3
 8001292:	6839      	ldr	r1, [r7, #0]
 8001294:	f000 fdca 	bl	8001e2c <USBD_ParseSetupRequest(usb_setup_req*, unsigned char*)>
  
  pdev->ep0_state = USBD_EP0_SETUP;
 8001298:	687b      	ldr	r3, [r7, #4]
 800129a:	f04f 0201 	mov.w	r2, #1
 800129e:	f8c3 21f4 	str.w	r2, [r3, #500]	; 0x1f4
  pdev->ep0_data_len = pdev->request.wLength;
 80012a2:	687b      	ldr	r3, [r7, #4]
 80012a4:	f8b3 320e 	ldrh.w	r3, [r3, #526]	; 0x20e
 80012a8:	461a      	mov	r2, r3
 80012aa:	687b      	ldr	r3, [r7, #4]
 80012ac:	f8c3 21f8 	str.w	r2, [r3, #504]	; 0x1f8
  
  switch (pdev->request.bmRequest & 0x1F) 
 80012b0:	687b      	ldr	r3, [r7, #4]
 80012b2:	f893 3208 	ldrb.w	r3, [r3, #520]	; 0x208
 80012b6:	f003 031f 	and.w	r3, r3, #31
 80012ba:	2b01      	cmp	r3, #1
 80012bc:	d00b      	beq.n	80012d6 <USBD_LL_SetupStage(_USBD_HandleTypeDef*, unsigned char*)+0x56>
 80012be:	2b02      	cmp	r3, #2
 80012c0:	d011      	beq.n	80012e6 <USBD_LL_SetupStage(_USBD_HandleTypeDef*, unsigned char*)+0x66>
 80012c2:	2b00      	cmp	r3, #0
 80012c4:	d117      	bne.n	80012f6 <USBD_LL_SetupStage(_USBD_HandleTypeDef*, unsigned char*)+0x76>
  {
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &pdev->request);
 80012c6:	687b      	ldr	r3, [r7, #4]
 80012c8:	f503 7302 	add.w	r3, r3, #520	; 0x208
 80012cc:	6878      	ldr	r0, [r7, #4]
 80012ce:	4619      	mov	r1, r3
 80012d0:	f000 f9a2 	bl	8001618 <USBD_StdDevReq(_USBD_HandleTypeDef*, usb_setup_req*)>
    break;
 80012d4:	e01a      	b.n	800130c <USBD_LL_SetupStage(_USBD_HandleTypeDef*, unsigned char*)+0x8c>
    
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &pdev->request);
 80012d6:	687b      	ldr	r3, [r7, #4]
 80012d8:	f503 7302 	add.w	r3, r3, #520	; 0x208
 80012dc:	6878      	ldr	r0, [r7, #4]
 80012de:	4619      	mov	r1, r3
 80012e0:	f000 f9ec 	bl	80016bc <USBD_StdItfReq(_USBD_HandleTypeDef*, usb_setup_req*)>
    break;
 80012e4:	e012      	b.n	800130c <USBD_LL_SetupStage(_USBD_HandleTypeDef*, unsigned char*)+0x8c>
    
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
 80012e6:	687b      	ldr	r3, [r7, #4]
 80012e8:	f503 7302 	add.w	r3, r3, #520	; 0x208
 80012ec:	6878      	ldr	r0, [r7, #4]
 80012ee:	4619      	mov	r1, r3
 80012f0:	f000 fa1a 	bl	8001728 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)>
    break;
 80012f4:	e00a      	b.n	800130c <USBD_LL_SetupStage(_USBD_HandleTypeDef*, unsigned char*)+0x8c>
    
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
 80012f6:	687b      	ldr	r3, [r7, #4]
 80012f8:	f893 3208 	ldrb.w	r3, [r3, #520]	; 0x208
 80012fc:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8001300:	b2db      	uxtb	r3, r3
 8001302:	6878      	ldr	r0, [r7, #4]
 8001304:	4619      	mov	r1, r3
 8001306:	f7ff fa8d 	bl	8000824 <USBD_LL_StallEP(_USBD_HandleTypeDef*, unsigned char)>
    break;
 800130a:	bf00      	nop
  }  
  return USBD_OK;  
 800130c:	f04f 0300 	mov.w	r3, #0
}
 8001310:	4618      	mov	r0, r3
 8001312:	f107 0708 	add.w	r7, r7, #8
 8001316:	46bd      	mov	sp, r7
 8001318:	bd80      	pop	{r7, pc}
 800131a:	bf00      	nop

0800131c <USBD_LL_DataOutStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)
{
 800131c:	b580      	push	{r7, lr}
 800131e:	b086      	sub	sp, #24
 8001320:	af00      	add	r7, sp, #0
 8001322:	60f8      	str	r0, [r7, #12]
 8001324:	460b      	mov	r3, r1
 8001326:	607a      	str	r2, [r7, #4]
 8001328:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef    *pep;
  
  if(epnum == 0) 
 800132a:	7afb      	ldrb	r3, [r7, #11]
 800132c:	2b00      	cmp	r3, #0
 800132e:	d13d      	bne.n	80013ac <USBD_LL_DataOutStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0x90>
  {
    pep = &pdev->ep_out[0];
 8001330:	68fb      	ldr	r3, [r7, #12]
 8001332:	f503 7382 	add.w	r3, r3, #260	; 0x104
 8001336:	617b      	str	r3, [r7, #20]
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
 8001338:	68fb      	ldr	r3, [r7, #12]
 800133a:	f8d3 31f4 	ldr.w	r3, [r3, #500]	; 0x1f4
 800133e:	2b03      	cmp	r3, #3
 8001340:	d147      	bne.n	80013d2 <USBD_LL_DataOutStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0xb6>
    {
      if(pep->rem_length > pep->maxpacket)
 8001342:	697b      	ldr	r3, [r7, #20]
 8001344:	689a      	ldr	r2, [r3, #8]
 8001346:	697b      	ldr	r3, [r7, #20]
 8001348:	68db      	ldr	r3, [r3, #12]
 800134a:	429a      	cmp	r2, r3
 800134c:	d919      	bls.n	8001382 <USBD_LL_DataOutStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0x66>
      {
        pep->rem_length -=  pep->maxpacket;
 800134e:	697b      	ldr	r3, [r7, #20]
 8001350:	689a      	ldr	r2, [r3, #8]
 8001352:	697b      	ldr	r3, [r7, #20]
 8001354:	68db      	ldr	r3, [r3, #12]
 8001356:	1ad2      	subs	r2, r2, r3
 8001358:	697b      	ldr	r3, [r7, #20]
 800135a:	609a      	str	r2, [r3, #8]
       
        USBD_CtlContinueRx (pdev, 
                            pdata,
                            MIN(pep->rem_length ,pep->maxpacket));
 800135c:	697b      	ldr	r3, [r7, #20]
 800135e:	689a      	ldr	r2, [r3, #8]
 8001360:	697b      	ldr	r3, [r7, #20]
 8001362:	68db      	ldr	r3, [r3, #12]
 8001364:	429a      	cmp	r2, r3
 8001366:	d203      	bcs.n	8001370 <USBD_LL_DataOutStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0x54>
 8001368:	697b      	ldr	r3, [r7, #20]
 800136a:	689b      	ldr	r3, [r3, #8]
 800136c:	b29b      	uxth	r3, r3
 800136e:	e002      	b.n	8001376 <USBD_LL_DataOutStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0x5a>
 8001370:	697b      	ldr	r3, [r7, #20]
 8001372:	68db      	ldr	r3, [r3, #12]
 8001374:	b29b      	uxth	r3, r3
 8001376:	68f8      	ldr	r0, [r7, #12]
 8001378:	6879      	ldr	r1, [r7, #4]
 800137a:	461a      	mov	r2, r3
 800137c:	f000 fe78 	bl	8002070 <USBD_CtlContinueRx(_USBD_HandleTypeDef*, unsigned char*, unsigned short)>
 8001380:	e027      	b.n	80013d2 <USBD_LL_DataOutStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0xb6>
      }
      else
      {
        if((pdev->pClass->EP0_RxReady != NULL)&&
 8001382:	68fb      	ldr	r3, [r7, #12]
 8001384:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8001388:	691b      	ldr	r3, [r3, #16]
 800138a:	2b00      	cmp	r3, #0
 800138c:	d00a      	beq.n	80013a4 <USBD_LL_DataOutStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0x88>
 800138e:	68fb      	ldr	r3, [r7, #12]
 8001390:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 8001394:	2b03      	cmp	r3, #3
 8001396:	d105      	bne.n	80013a4 <USBD_LL_DataOutStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0x88>
           (pdev->dev_state == USBD_STATE_CONFIGURED))
        {
          pdev->pClass->EP0_RxReady(pdev); 
 8001398:	68fb      	ldr	r3, [r7, #12]
 800139a:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 800139e:	691b      	ldr	r3, [r3, #16]
 80013a0:	68f8      	ldr	r0, [r7, #12]
 80013a2:	4798      	blx	r3
        }
        USBD_CtlSendStatus(pdev);
 80013a4:	68f8      	ldr	r0, [r7, #12]
 80013a6:	f000 fe79 	bl	800209c <USBD_CtlSendStatus(_USBD_HandleTypeDef*)>
 80013aa:	e012      	b.n	80013d2 <USBD_LL_DataOutStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0xb6>
      }
    }
  }
  else if((pdev->pClass->DataOut != NULL)&&
 80013ac:	68fb      	ldr	r3, [r7, #12]
 80013ae:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 80013b2:	699b      	ldr	r3, [r3, #24]
 80013b4:	2b00      	cmp	r3, #0
 80013b6:	d00c      	beq.n	80013d2 <USBD_LL_DataOutStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0xb6>
 80013b8:	68fb      	ldr	r3, [r7, #12]
 80013ba:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 80013be:	2b03      	cmp	r3, #3
 80013c0:	d107      	bne.n	80013d2 <USBD_LL_DataOutStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0xb6>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataOut(pdev, epnum); 
 80013c2:	68fb      	ldr	r3, [r7, #12]
 80013c4:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 80013c8:	699b      	ldr	r3, [r3, #24]
 80013ca:	7afa      	ldrb	r2, [r7, #11]
 80013cc:	68f8      	ldr	r0, [r7, #12]
 80013ce:	4611      	mov	r1, r2
 80013d0:	4798      	blx	r3
  }  
  return USBD_OK;
 80013d2:	f04f 0300 	mov.w	r3, #0
}
 80013d6:	4618      	mov	r0, r3
 80013d8:	f107 0718 	add.w	r7, r7, #24
 80013dc:	46bd      	mov	sp, r7
 80013de:	bd80      	pop	{r7, pc}

080013e0 <USBD_LL_DataInStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
{
 80013e0:	b580      	push	{r7, lr}
 80013e2:	b086      	sub	sp, #24
 80013e4:	af00      	add	r7, sp, #0
 80013e6:	60f8      	str	r0, [r7, #12]
 80013e8:	460b      	mov	r3, r1
 80013ea:	607a      	str	r2, [r7, #4]
 80013ec:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef    *pep;
    
  if(epnum == 0) 
 80013ee:	7afb      	ldrb	r3, [r7, #11]
 80013f0:	2b00      	cmp	r3, #0
 80013f2:	d165      	bne.n	80014c0 <USBD_LL_DataInStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0xe0>
  {
    pep = &pdev->ep_in[0];
 80013f4:	68fb      	ldr	r3, [r7, #12]
 80013f6:	f103 0314 	add.w	r3, r3, #20
 80013fa:	617b      	str	r3, [r7, #20]
    
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
 80013fc:	68fb      	ldr	r3, [r7, #12]
 80013fe:	f8d3 31f4 	ldr.w	r3, [r3, #500]	; 0x1f4
 8001402:	2b02      	cmp	r3, #2
 8001404:	d14e      	bne.n	80014a4 <USBD_LL_DataInStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0xc4>
    {
      if(pep->rem_length > pep->maxpacket)
 8001406:	697b      	ldr	r3, [r7, #20]
 8001408:	689a      	ldr	r2, [r3, #8]
 800140a:	697b      	ldr	r3, [r7, #20]
 800140c:	68db      	ldr	r3, [r3, #12]
 800140e:	429a      	cmp	r2, r3
 8001410:	d90f      	bls.n	8001432 <USBD_LL_DataInStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0x52>
      {
        pep->rem_length -=  pep->maxpacket;
 8001412:	697b      	ldr	r3, [r7, #20]
 8001414:	689a      	ldr	r2, [r3, #8]
 8001416:	697b      	ldr	r3, [r7, #20]
 8001418:	68db      	ldr	r3, [r3, #12]
 800141a:	1ad2      	subs	r2, r2, r3
 800141c:	697b      	ldr	r3, [r7, #20]
 800141e:	609a      	str	r2, [r3, #8]
        
        USBD_CtlContinueSendData (pdev, 
                                  pdata, 
                                  pep->rem_length);
 8001420:	697b      	ldr	r3, [r7, #20]
 8001422:	689b      	ldr	r3, [r3, #8]
 8001424:	b29b      	uxth	r3, r3
 8001426:	68f8      	ldr	r0, [r7, #12]
 8001428:	6879      	ldr	r1, [r7, #4]
 800142a:	461a      	mov	r2, r3
 800142c:	f000 fde8 	bl	8002000 <USBD_CtlContinueSendData(_USBD_HandleTypeDef*, unsigned char*, unsigned short)>
 8001430:	e038      	b.n	80014a4 <USBD_LL_DataInStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0xc4>
      }
      else
      { /* last packet is MPS multiple, so send ZLP packet */
        if((pep->total_length % pep->maxpacket == 0) &&
 8001432:	697b      	ldr	r3, [r7, #20]
 8001434:	685b      	ldr	r3, [r3, #4]
 8001436:	697a      	ldr	r2, [r7, #20]
 8001438:	68d2      	ldr	r2, [r2, #12]
 800143a:	fbb3 f1f2 	udiv	r1, r3, r2
 800143e:	fb02 f201 	mul.w	r2, r2, r1
 8001442:	1a9b      	subs	r3, r3, r2
 8001444:	2b00      	cmp	r3, #0
 8001446:	d119      	bne.n	800147c <USBD_LL_DataInStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0x9c>
 8001448:	697b      	ldr	r3, [r7, #20]
 800144a:	685a      	ldr	r2, [r3, #4]
 800144c:	697b      	ldr	r3, [r7, #20]
 800144e:	68db      	ldr	r3, [r3, #12]
 8001450:	429a      	cmp	r2, r3
 8001452:	d313      	bcc.n	800147c <USBD_LL_DataInStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0x9c>
 8001454:	697b      	ldr	r3, [r7, #20]
 8001456:	685a      	ldr	r2, [r3, #4]
 8001458:	68fb      	ldr	r3, [r7, #12]
 800145a:	f8d3 31f8 	ldr.w	r3, [r3, #504]	; 0x1f8
 800145e:	429a      	cmp	r2, r3
 8001460:	d20c      	bcs.n	800147c <USBD_LL_DataInStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0x9c>
           (pep->total_length >= pep->maxpacket) &&
             (pep->total_length < pdev->ep0_data_len ))
        {
          
          USBD_CtlContinueSendData(pdev , NULL, 0);
 8001462:	68f8      	ldr	r0, [r7, #12]
 8001464:	f04f 0100 	mov.w	r1, #0
 8001468:	f04f 0200 	mov.w	r2, #0
 800146c:	f000 fdc8 	bl	8002000 <USBD_CtlContinueSendData(_USBD_HandleTypeDef*, unsigned char*, unsigned short)>
          pdev->ep0_data_len = 0;
 8001470:	68fb      	ldr	r3, [r7, #12]
 8001472:	f04f 0200 	mov.w	r2, #0
 8001476:	f8c3 21f8 	str.w	r2, [r3, #504]	; 0x1f8
 800147a:	e013      	b.n	80014a4 <USBD_LL_DataInStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0xc4>
        }
        else
        {
          if((pdev->pClass->EP0_TxSent != NULL)&&
 800147c:	68fb      	ldr	r3, [r7, #12]
 800147e:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8001482:	68db      	ldr	r3, [r3, #12]
 8001484:	2b00      	cmp	r3, #0
 8001486:	d00a      	beq.n	800149e <USBD_LL_DataInStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0xbe>
 8001488:	68fb      	ldr	r3, [r7, #12]
 800148a:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 800148e:	2b03      	cmp	r3, #3
 8001490:	d105      	bne.n	800149e <USBD_LL_DataInStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0xbe>
             (pdev->dev_state == USBD_STATE_CONFIGURED))
          {
            pdev->pClass->EP0_TxSent(pdev); 
 8001492:	68fb      	ldr	r3, [r7, #12]
 8001494:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8001498:	68db      	ldr	r3, [r3, #12]
 800149a:	68f8      	ldr	r0, [r7, #12]
 800149c:	4798      	blx	r3
          }          
          USBD_CtlReceiveStatus(pdev);
 800149e:	68f8      	ldr	r0, [r7, #12]
 80014a0:	f000 fe16 	bl	80020d0 <USBD_CtlReceiveStatus(_USBD_HandleTypeDef*)>
        }
      }
    }
    if (pdev->dev_test_mode == 1)
 80014a4:	68fb      	ldr	r3, [r7, #12]
 80014a6:	f893 3200 	ldrb.w	r3, [r3, #512]	; 0x200
 80014aa:	2b01      	cmp	r3, #1
 80014ac:	d11b      	bne.n	80014e6 <USBD_LL_DataInStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0x106>
    {
      USBD_RunTestMode(pdev); 
 80014ae:	68f8      	ldr	r0, [r7, #12]
 80014b0:	f7ff fe9c 	bl	80011ec <USBD_RunTestMode(_USBD_HandleTypeDef*)>
      pdev->dev_test_mode = 0;
 80014b4:	68fb      	ldr	r3, [r7, #12]
 80014b6:	f04f 0200 	mov.w	r2, #0
 80014ba:	f883 2200 	strb.w	r2, [r3, #512]	; 0x200
 80014be:	e012      	b.n	80014e6 <USBD_LL_DataInStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0x106>
    }
  }
  else if((pdev->pClass->DataIn != NULL)&& 
 80014c0:	68fb      	ldr	r3, [r7, #12]
 80014c2:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 80014c6:	695b      	ldr	r3, [r3, #20]
 80014c8:	2b00      	cmp	r3, #0
 80014ca:	d00c      	beq.n	80014e6 <USBD_LL_DataInStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0x106>
 80014cc:	68fb      	ldr	r3, [r7, #12]
 80014ce:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 80014d2:	2b03      	cmp	r3, #3
 80014d4:	d107      	bne.n	80014e6 <USBD_LL_DataInStage(_USBD_HandleTypeDef*, unsigned char, unsigned char*)+0x106>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataIn(pdev, epnum); 
 80014d6:	68fb      	ldr	r3, [r7, #12]
 80014d8:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 80014dc:	695b      	ldr	r3, [r3, #20]
 80014de:	7afa      	ldrb	r2, [r7, #11]
 80014e0:	68f8      	ldr	r0, [r7, #12]
 80014e2:	4611      	mov	r1, r2
 80014e4:	4798      	blx	r3
  }  
  return USBD_OK;
 80014e6:	f04f 0300 	mov.w	r3, #0
}
 80014ea:	4618      	mov	r0, r3
 80014ec:	f107 0718 	add.w	r7, r7, #24
 80014f0:	46bd      	mov	sp, r7
 80014f2:	bd80      	pop	{r7, pc}

080014f4 <USBD_LL_Reset(_USBD_HandleTypeDef*)>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 80014f4:	b580      	push	{r7, lr}
 80014f6:	b082      	sub	sp, #8
 80014f8:	af00      	add	r7, sp, #0
 80014fa:	6078      	str	r0, [r7, #4]
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
              0x00,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
 80014fc:	6878      	ldr	r0, [r7, #4]
 80014fe:	f04f 0100 	mov.w	r1, #0
 8001502:	f04f 0200 	mov.w	r2, #0
 8001506:	f04f 0340 	mov.w	r3, #64	; 0x40
 800150a:	f7ff f95f 	bl	80007cc <USBD_LL_OpenEP(_USBD_HandleTypeDef*, unsigned char, unsigned char, unsigned short)>
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 800150e:	687b      	ldr	r3, [r7, #4]
 8001510:	f04f 0240 	mov.w	r2, #64	; 0x40
 8001514:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
  
  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev,
              0x80,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
 8001518:	6878      	ldr	r0, [r7, #4]
 800151a:	f04f 0180 	mov.w	r1, #128	; 0x80
 800151e:	f04f 0200 	mov.w	r2, #0
 8001522:	f04f 0340 	mov.w	r3, #64	; 0x40
 8001526:	f7ff f951 	bl	80007cc <USBD_LL_OpenEP(_USBD_HandleTypeDef*, unsigned char, unsigned char, unsigned short)>
  
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 800152a:	687b      	ldr	r3, [r7, #4]
 800152c:	f04f 0240 	mov.w	r2, #64	; 0x40
 8001530:	621a      	str	r2, [r3, #32]
  /* Upon Reset call usr call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8001532:	687b      	ldr	r3, [r7, #4]
 8001534:	f04f 0201 	mov.w	r2, #1
 8001538:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
  
  if (pdev->pClassData) 
 800153c:	687b      	ldr	r3, [r7, #4]
 800153e:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8001542:	2b00      	cmp	r3, #0
 8001544:	d009      	beq.n	800155a <USBD_LL_Reset(_USBD_HandleTypeDef*)+0x66>
    pdev->pClass->DeInit(pdev, pdev->dev_config);  
 8001546:	687b      	ldr	r3, [r7, #4]
 8001548:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 800154c:	685b      	ldr	r3, [r3, #4]
 800154e:	687a      	ldr	r2, [r7, #4]
 8001550:	6852      	ldr	r2, [r2, #4]
 8001552:	b2d2      	uxtb	r2, r2
 8001554:	6878      	ldr	r0, [r7, #4]
 8001556:	4611      	mov	r1, r2
 8001558:	4798      	blx	r3
 
  
  return USBD_OK;
 800155a:	f04f 0300 	mov.w	r3, #0
}
 800155e:	4618      	mov	r0, r3
 8001560:	f107 0708 	add.w	r7, r7, #8
 8001564:	46bd      	mov	sp, r7
 8001566:	bd80      	pop	{r7, pc}

08001568 <USBD_LL_SetSpeed(_USBD_HandleTypeDef*, USBD_SpeedTypeDef)>:
*         Handle Reset event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
 8001568:	b480      	push	{r7}
 800156a:	b083      	sub	sp, #12
 800156c:	af00      	add	r7, sp, #0
 800156e:	6078      	str	r0, [r7, #4]
 8001570:	460b      	mov	r3, r1
 8001572:	70fb      	strb	r3, [r7, #3]
  pdev->dev_speed = speed;
 8001574:	687b      	ldr	r3, [r7, #4]
 8001576:	78fa      	ldrb	r2, [r7, #3]
 8001578:	741a      	strb	r2, [r3, #16]
  return USBD_OK;
 800157a:	f04f 0300 	mov.w	r3, #0
}
 800157e:	4618      	mov	r0, r3
 8001580:	f107 070c 	add.w	r7, r7, #12
 8001584:	46bd      	mov	sp, r7
 8001586:	bc80      	pop	{r7}
 8001588:	4770      	bx	lr
 800158a:	bf00      	nop

0800158c <USBD_LL_Suspend(_USBD_HandleTypeDef*)>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
 800158c:	b480      	push	{r7}
 800158e:	b083      	sub	sp, #12
 8001590:	af00      	add	r7, sp, #0
 8001592:	6078      	str	r0, [r7, #4]
  pdev->dev_old_state =  pdev->dev_state;
 8001594:	687b      	ldr	r3, [r7, #4]
 8001596:	f893 21fc 	ldrb.w	r2, [r3, #508]	; 0x1fc
 800159a:	687b      	ldr	r3, [r7, #4]
 800159c:	f883 21fd 	strb.w	r2, [r3, #509]	; 0x1fd
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 80015a0:	687b      	ldr	r3, [r7, #4]
 80015a2:	f04f 0204 	mov.w	r2, #4
 80015a6:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
  return USBD_OK;
 80015aa:	f04f 0300 	mov.w	r3, #0
}
 80015ae:	4618      	mov	r0, r3
 80015b0:	f107 070c 	add.w	r7, r7, #12
 80015b4:	46bd      	mov	sp, r7
 80015b6:	bc80      	pop	{r7}
 80015b8:	4770      	bx	lr
 80015ba:	bf00      	nop

080015bc <USBD_LL_Resume(_USBD_HandleTypeDef*)>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
 80015bc:	b480      	push	{r7}
 80015be:	b083      	sub	sp, #12
 80015c0:	af00      	add	r7, sp, #0
 80015c2:	6078      	str	r0, [r7, #4]
  pdev->dev_state = pdev->dev_old_state;  
 80015c4:	687b      	ldr	r3, [r7, #4]
 80015c6:	f893 21fd 	ldrb.w	r2, [r3, #509]	; 0x1fd
 80015ca:	687b      	ldr	r3, [r7, #4]
 80015cc:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
  return USBD_OK;
 80015d0:	f04f 0300 	mov.w	r3, #0
}
 80015d4:	4618      	mov	r0, r3
 80015d6:	f107 070c 	add.w	r7, r7, #12
 80015da:	46bd      	mov	sp, r7
 80015dc:	bc80      	pop	{r7}
 80015de:	4770      	bx	lr

080015e0 <USBD_LL_SOF(_USBD_HandleTypeDef*)>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
 80015e0:	b580      	push	{r7, lr}
 80015e2:	b082      	sub	sp, #8
 80015e4:	af00      	add	r7, sp, #0
 80015e6:	6078      	str	r0, [r7, #4]
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
 80015e8:	687b      	ldr	r3, [r7, #4]
 80015ea:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 80015ee:	2b03      	cmp	r3, #3
 80015f0:	d10b      	bne.n	800160a <USBD_LL_SOF(_USBD_HandleTypeDef*)+0x2a>
  {
    if(pdev->pClass->SOF != NULL)
 80015f2:	687b      	ldr	r3, [r7, #4]
 80015f4:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 80015f8:	69db      	ldr	r3, [r3, #28]
 80015fa:	2b00      	cmp	r3, #0
 80015fc:	d005      	beq.n	800160a <USBD_LL_SOF(_USBD_HandleTypeDef*)+0x2a>
    {
      pdev->pClass->SOF(pdev);
 80015fe:	687b      	ldr	r3, [r7, #4]
 8001600:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8001604:	69db      	ldr	r3, [r3, #28]
 8001606:	6878      	ldr	r0, [r7, #4]
 8001608:	4798      	blx	r3
    }
  }
  return USBD_OK;
 800160a:	f04f 0300 	mov.w	r3, #0
}
 800160e:	4618      	mov	r0, r3
 8001610:	f107 0708 	add.w	r7, r7, #8
 8001614:	46bd      	mov	sp, r7
 8001616:	bd80      	pop	{r7, pc}

08001618 <USBD_StdDevReq(_USBD_HandleTypeDef*, usb_setup_req*)>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 8001618:	b580      	push	{r7, lr}
 800161a:	b084      	sub	sp, #16
 800161c:	af00      	add	r7, sp, #0
 800161e:	6078      	str	r0, [r7, #4]
 8001620:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;  
 8001622:	f04f 0300 	mov.w	r3, #0
 8001626:	73fb      	strb	r3, [r7, #15]
  
  switch (req->bRequest) 
 8001628:	683b      	ldr	r3, [r7, #0]
 800162a:	785b      	ldrb	r3, [r3, #1]
 800162c:	2b09      	cmp	r3, #9
 800162e:	d83a      	bhi.n	80016a6 <USBD_StdDevReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x8e>
 8001630:	a201      	add	r2, pc, #4	; (adr r2, 8001638 <USBD_StdDevReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x20>)
 8001632:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8001636:	bf00      	nop
 8001638:	08001689 	.word	0x08001689
 800163c:	0800169d 	.word	0x0800169d
 8001640:	080016a7 	.word	0x080016a7
 8001644:	08001693 	.word	0x08001693
 8001648:	080016a7 	.word	0x080016a7
 800164c:	0800166b 	.word	0x0800166b
 8001650:	08001661 	.word	0x08001661
 8001654:	080016a7 	.word	0x080016a7
 8001658:	0800167f 	.word	0x0800167f
 800165c:	08001675 	.word	0x08001675
  {
  case USB_REQ_GET_DESCRIPTOR: 
    
    USBD_GetDescriptor (pdev, req) ;
 8001660:	6878      	ldr	r0, [r7, #4]
 8001662:	6839      	ldr	r1, [r7, #0]
 8001664:	f000 f93a 	bl	80018dc <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)>
    break;
 8001668:	e022      	b.n	80016b0 <USBD_StdDevReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x98>
    
  case USB_REQ_SET_ADDRESS:                      
    USBD_SetAddress(pdev, req);
 800166a:	6878      	ldr	r0, [r7, #4]
 800166c:	6839      	ldr	r1, [r7, #0]
 800166e:	f000 fa3b 	bl	8001ae8 <USBD_SetAddress(_USBD_HandleTypeDef*, usb_setup_req*)>
    break;
 8001672:	e01d      	b.n	80016b0 <USBD_StdDevReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x98>
    
  case USB_REQ_SET_CONFIGURATION:                    
    USBD_SetConfig (pdev , req);
 8001674:	6878      	ldr	r0, [r7, #4]
 8001676:	6839      	ldr	r1, [r7, #0]
 8001678:	f000 fa76 	bl	8001b68 <USBD_SetConfig(_USBD_HandleTypeDef*, usb_setup_req*)>
    break;
 800167c:	e018      	b.n	80016b0 <USBD_StdDevReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x98>
    
  case USB_REQ_GET_CONFIGURATION:                 
    USBD_GetConfig (pdev , req);
 800167e:	6878      	ldr	r0, [r7, #4]
 8001680:	6839      	ldr	r1, [r7, #0]
 8001682:	f000 fb25 	bl	8001cd0 <USBD_GetConfig(_USBD_HandleTypeDef*, usb_setup_req*)>
    break;
 8001686:	e013      	b.n	80016b0 <USBD_StdDevReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x98>
    
  case USB_REQ_GET_STATUS:                                  
    USBD_GetStatus (pdev , req);
 8001688:	6878      	ldr	r0, [r7, #4]
 800168a:	6839      	ldr	r1, [r7, #0]
 800168c:	f000 fb58 	bl	8001d40 <USBD_GetStatus(_USBD_HandleTypeDef*, usb_setup_req*)>
    break;
 8001690:	e00e      	b.n	80016b0 <USBD_StdDevReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x98>
    
    
  case USB_REQ_SET_FEATURE:   
    USBD_SetFeature (pdev , req);    
 8001692:	6878      	ldr	r0, [r7, #4]
 8001694:	6839      	ldr	r1, [r7, #0]
 8001696:	f000 fb81 	bl	8001d9c <USBD_SetFeature(_USBD_HandleTypeDef*, usb_setup_req*)>
    break;
 800169a:	e009      	b.n	80016b0 <USBD_StdDevReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x98>
    
  case USB_REQ_CLEAR_FEATURE:                                   
    USBD_ClrFeature (pdev , req);
 800169c:	6878      	ldr	r0, [r7, #4]
 800169e:	6839      	ldr	r1, [r7, #0]
 80016a0:	f000 fb98 	bl	8001dd4 <USBD_ClrFeature(_USBD_HandleTypeDef*, usb_setup_req*)>
    break;
 80016a4:	e004      	b.n	80016b0 <USBD_StdDevReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x98>
    
  default:  
    USBD_CtlError(pdev , req);
 80016a6:	6878      	ldr	r0, [r7, #4]
 80016a8:	6839      	ldr	r1, [r7, #0]
 80016aa:	f000 fc01 	bl	8001eb0 <USBD_CtlError(_USBD_HandleTypeDef*, usb_setup_req*)>
    break;
 80016ae:	bf00      	nop
  }
  
  return ret;
 80016b0:	7bfb      	ldrb	r3, [r7, #15]
}
 80016b2:	4618      	mov	r0, r3
 80016b4:	f107 0710 	add.w	r7, r7, #16
 80016b8:	46bd      	mov	sp, r7
 80016ba:	bd80      	pop	{r7, pc}

080016bc <USBD_StdItfReq(_USBD_HandleTypeDef*, usb_setup_req*)>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdItfReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 80016bc:	b580      	push	{r7, lr}
 80016be:	b084      	sub	sp, #16
 80016c0:	af00      	add	r7, sp, #0
 80016c2:	6078      	str	r0, [r7, #4]
 80016c4:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK; 
 80016c6:	f04f 0300 	mov.w	r3, #0
 80016ca:	73fb      	strb	r3, [r7, #15]
  
  switch (pdev->dev_state) 
 80016cc:	687b      	ldr	r3, [r7, #4]
 80016ce:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 80016d2:	2b03      	cmp	r3, #3
 80016d4:	d11b      	bne.n	800170e <USBD_StdItfReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x52>
  {
  case USBD_STATE_CONFIGURED:
    
    if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES) 
 80016d6:	683b      	ldr	r3, [r7, #0]
 80016d8:	889b      	ldrh	r3, [r3, #4]
 80016da:	b2db      	uxtb	r3, r3
 80016dc:	2b01      	cmp	r3, #1
 80016de:	d811      	bhi.n	8001704 <USBD_StdItfReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x48>
    {
      pdev->pClass->Setup (pdev, req); 
 80016e0:	687b      	ldr	r3, [r7, #4]
 80016e2:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 80016e6:	689b      	ldr	r3, [r3, #8]
 80016e8:	6878      	ldr	r0, [r7, #4]
 80016ea:	6839      	ldr	r1, [r7, #0]
 80016ec:	4798      	blx	r3
      
      if((req->wLength == 0)&& (ret == USBD_OK))
 80016ee:	683b      	ldr	r3, [r7, #0]
 80016f0:	88db      	ldrh	r3, [r3, #6]
 80016f2:	2b00      	cmp	r3, #0
 80016f4:	d110      	bne.n	8001718 <USBD_StdItfReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x5c>
 80016f6:	7bfb      	ldrb	r3, [r7, #15]
 80016f8:	2b00      	cmp	r3, #0
 80016fa:	d10d      	bne.n	8001718 <USBD_StdItfReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x5c>
      {
         USBD_CtlSendStatus(pdev);
 80016fc:	6878      	ldr	r0, [r7, #4]
 80016fe:	f000 fccd 	bl	800209c <USBD_CtlSendStatus(_USBD_HandleTypeDef*)>
    } 
    else 
    {                                               
       USBD_CtlError(pdev , req);
    }
    break;
 8001702:	e009      	b.n	8001718 <USBD_StdItfReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x5c>
         USBD_CtlSendStatus(pdev);
      }
    } 
    else 
    {                                               
       USBD_CtlError(pdev , req);
 8001704:	6878      	ldr	r0, [r7, #4]
 8001706:	6839      	ldr	r1, [r7, #0]
 8001708:	f000 fbd2 	bl	8001eb0 <USBD_CtlError(_USBD_HandleTypeDef*, usb_setup_req*)>
    }
    break;
 800170c:	e004      	b.n	8001718 <USBD_StdItfReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x5c>
    
  default:
     USBD_CtlError(pdev , req);
 800170e:	6878      	ldr	r0, [r7, #4]
 8001710:	6839      	ldr	r1, [r7, #0]
 8001712:	f000 fbcd 	bl	8001eb0 <USBD_CtlError(_USBD_HandleTypeDef*, usb_setup_req*)>
    break;
 8001716:	e000      	b.n	800171a <USBD_StdItfReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x5e>
    } 
    else 
    {                                               
       USBD_CtlError(pdev , req);
    }
    break;
 8001718:	bf00      	nop
    
  default:
     USBD_CtlError(pdev , req);
    break;
  }
  return USBD_OK;
 800171a:	f04f 0300 	mov.w	r3, #0
}
 800171e:	4618      	mov	r0, r3
 8001720:	f107 0710 	add.w	r7, r7, #16
 8001724:	46bd      	mov	sp, r7
 8001726:	bd80      	pop	{r7, pc}

08001728 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdEPReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 8001728:	b580      	push	{r7, lr}
 800172a:	b084      	sub	sp, #16
 800172c:	af00      	add	r7, sp, #0
 800172e:	6078      	str	r0, [r7, #4]
 8001730:	6039      	str	r1, [r7, #0]
  
  uint8_t   ep_addr;
  USBD_StatusTypeDef ret = USBD_OK; 
 8001732:	f04f 0300 	mov.w	r3, #0
 8001736:	73fb      	strb	r3, [r7, #15]
  USBD_EndpointTypeDef   *pep;
  ep_addr  = LOBYTE(req->wIndex);   
 8001738:	683b      	ldr	r3, [r7, #0]
 800173a:	889b      	ldrh	r3, [r3, #4]
 800173c:	73bb      	strb	r3, [r7, #14]
  
  switch (req->bRequest) 
 800173e:	683b      	ldr	r3, [r7, #0]
 8001740:	785b      	ldrb	r3, [r3, #1]
 8001742:	2b01      	cmp	r3, #1
 8001744:	d039      	beq.n	80017ba <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x92>
 8001746:	2b03      	cmp	r3, #3
 8001748:	d002      	beq.n	8001750 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x28>
 800174a:	2b00      	cmp	r3, #0
 800174c:	d06b      	beq.n	8001826 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0xfe>
 800174e:	e0be      	b.n	80018ce <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x1a6>
  {
    
  case USB_REQ_SET_FEATURE :
    
    switch (pdev->dev_state) 
 8001750:	687b      	ldr	r3, [r7, #4]
 8001752:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 8001756:	2b02      	cmp	r3, #2
 8001758:	d002      	beq.n	8001760 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x38>
 800175a:	2b03      	cmp	r3, #3
 800175c:	d00c      	beq.n	8001778 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x50>
 800175e:	e025      	b.n	80017ac <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x84>
    {
    case USBD_STATE_ADDRESSED:          
      if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 8001760:	7bbb      	ldrb	r3, [r7, #14]
 8001762:	2b00      	cmp	r3, #0
 8001764:	d027      	beq.n	80017b6 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x8e>
 8001766:	7bbb      	ldrb	r3, [r7, #14]
 8001768:	2b80      	cmp	r3, #128	; 0x80
 800176a:	d024      	beq.n	80017b6 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x8e>
      {
        USBD_LL_StallEP(pdev , ep_addr);
 800176c:	7bbb      	ldrb	r3, [r7, #14]
 800176e:	6878      	ldr	r0, [r7, #4]
 8001770:	4619      	mov	r1, r3
 8001772:	f7ff f857 	bl	8000824 <USBD_LL_StallEP(_USBD_HandleTypeDef*, unsigned char)>
      }
      break;	
 8001776:	e01e      	b.n	80017b6 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x8e>
      
    case USBD_STATE_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 8001778:	683b      	ldr	r3, [r7, #0]
 800177a:	885b      	ldrh	r3, [r3, #2]
 800177c:	2b00      	cmp	r3, #0
 800177e:	d10a      	bne.n	8001796 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x6e>
      {
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 8001780:	7bbb      	ldrb	r3, [r7, #14]
 8001782:	2b00      	cmp	r3, #0
 8001784:	d007      	beq.n	8001796 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x6e>
 8001786:	7bbb      	ldrb	r3, [r7, #14]
 8001788:	2b80      	cmp	r3, #128	; 0x80
 800178a:	d004      	beq.n	8001796 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x6e>
        { 
          USBD_LL_StallEP(pdev , ep_addr);
 800178c:	7bbb      	ldrb	r3, [r7, #14]
 800178e:	6878      	ldr	r0, [r7, #4]
 8001790:	4619      	mov	r1, r3
 8001792:	f7ff f847 	bl	8000824 <USBD_LL_StallEP(_USBD_HandleTypeDef*, unsigned char)>
          
        }
      }
      pdev->pClass->Setup (pdev, req);   
 8001796:	687b      	ldr	r3, [r7, #4]
 8001798:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 800179c:	689b      	ldr	r3, [r3, #8]
 800179e:	6878      	ldr	r0, [r7, #4]
 80017a0:	6839      	ldr	r1, [r7, #0]
 80017a2:	4798      	blx	r3
      USBD_CtlSendStatus(pdev);
 80017a4:	6878      	ldr	r0, [r7, #4]
 80017a6:	f000 fc79 	bl	800209c <USBD_CtlSendStatus(_USBD_HandleTypeDef*)>
      
      break;
 80017aa:	e005      	b.n	80017b8 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x90>
      
    default:                         
      USBD_CtlError(pdev , req);
 80017ac:	6878      	ldr	r0, [r7, #4]
 80017ae:	6839      	ldr	r1, [r7, #0]
 80017b0:	f000 fb7e 	bl	8001eb0 <USBD_CtlError(_USBD_HandleTypeDef*, usb_setup_req*)>
      break;    
 80017b4:	e000      	b.n	80017b8 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x90>
    case USBD_STATE_ADDRESSED:          
      if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
      {
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
 80017b6:	bf00      	nop
      
    default:                         
      USBD_CtlError(pdev , req);
      break;    
    }
    break;
 80017b8:	e08a      	b.n	80018d0 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x1a8>
    
  case USB_REQ_CLEAR_FEATURE :
    
    switch (pdev->dev_state) 
 80017ba:	687b      	ldr	r3, [r7, #4]
 80017bc:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 80017c0:	2b02      	cmp	r3, #2
 80017c2:	d002      	beq.n	80017ca <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0xa2>
 80017c4:	2b03      	cmp	r3, #3
 80017c6:	d00c      	beq.n	80017e2 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0xba>
 80017c8:	e024      	b.n	8001814 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0xec>
    {
    case USBD_STATE_ADDRESSED:          
      if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 80017ca:	7bbb      	ldrb	r3, [r7, #14]
 80017cc:	2b00      	cmp	r3, #0
 80017ce:	d026      	beq.n	800181e <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0xf6>
 80017d0:	7bbb      	ldrb	r3, [r7, #14]
 80017d2:	2b80      	cmp	r3, #128	; 0x80
 80017d4:	d023      	beq.n	800181e <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0xf6>
      {
        USBD_LL_StallEP(pdev , ep_addr);
 80017d6:	7bbb      	ldrb	r3, [r7, #14]
 80017d8:	6878      	ldr	r0, [r7, #4]
 80017da:	4619      	mov	r1, r3
 80017dc:	f7ff f822 	bl	8000824 <USBD_LL_StallEP(_USBD_HandleTypeDef*, unsigned char)>
      }
      break;	
 80017e0:	e01d      	b.n	800181e <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0xf6>
      
    case USBD_STATE_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 80017e2:	683b      	ldr	r3, [r7, #0]
 80017e4:	885b      	ldrh	r3, [r3, #2]
 80017e6:	2b00      	cmp	r3, #0
 80017e8:	d11b      	bne.n	8001822 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0xfa>
      {
        if ((ep_addr & 0x7F) != 0x00) 
 80017ea:	7bbb      	ldrb	r3, [r7, #14]
 80017ec:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80017f0:	2b00      	cmp	r3, #0
 80017f2:	d00b      	beq.n	800180c <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0xe4>
        {        
          USBD_LL_ClearStallEP(pdev , ep_addr);
 80017f4:	7bbb      	ldrb	r3, [r7, #14]
 80017f6:	6878      	ldr	r0, [r7, #4]
 80017f8:	4619      	mov	r1, r3
 80017fa:	f7ff f829 	bl	8000850 <USBD_LL_ClearStallEP(_USBD_HandleTypeDef*, unsigned char)>
          pdev->pClass->Setup (pdev, req);
 80017fe:	687b      	ldr	r3, [r7, #4]
 8001800:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8001804:	689b      	ldr	r3, [r3, #8]
 8001806:	6878      	ldr	r0, [r7, #4]
 8001808:	6839      	ldr	r1, [r7, #0]
 800180a:	4798      	blx	r3
        }
        USBD_CtlSendStatus(pdev);
 800180c:	6878      	ldr	r0, [r7, #4]
 800180e:	f000 fc45 	bl	800209c <USBD_CtlSendStatus(_USBD_HandleTypeDef*)>
      }
      break;
 8001812:	e006      	b.n	8001822 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0xfa>
      
    default:                         
      USBD_CtlError(pdev , req);
 8001814:	6878      	ldr	r0, [r7, #4]
 8001816:	6839      	ldr	r1, [r7, #0]
 8001818:	f000 fb4a 	bl	8001eb0 <USBD_CtlError(_USBD_HandleTypeDef*, usb_setup_req*)>
      break;    
 800181c:	e002      	b.n	8001824 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0xfc>
    case USBD_STATE_ADDRESSED:          
      if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
      {
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
 800181e:	bf00      	nop
 8001820:	e000      	b.n	8001824 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0xfc>
          USBD_LL_ClearStallEP(pdev , ep_addr);
          pdev->pClass->Setup (pdev, req);
        }
        USBD_CtlSendStatus(pdev);
      }
      break;
 8001822:	bf00      	nop
      
    default:                         
      USBD_CtlError(pdev , req);
      break;    
    }
    break;
 8001824:	e054      	b.n	80018d0 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x1a8>
    
  case USB_REQ_GET_STATUS:                  
    switch (pdev->dev_state) 
 8001826:	687b      	ldr	r3, [r7, #4]
 8001828:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 800182c:	2b02      	cmp	r3, #2
 800182e:	d002      	beq.n	8001836 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x10e>
 8001830:	2b03      	cmp	r3, #3
 8001832:	d00b      	beq.n	800184c <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x124>
 8001834:	e044      	b.n	80018c0 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x198>
    {
    case USBD_STATE_ADDRESSED:          
      if ((ep_addr & 0x7F) != 0x00) 
 8001836:	7bbb      	ldrb	r3, [r7, #14]
 8001838:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800183c:	2b00      	cmp	r3, #0
 800183e:	d044      	beq.n	80018ca <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x1a2>
      {
        USBD_LL_StallEP(pdev , ep_addr);
 8001840:	7bbb      	ldrb	r3, [r7, #14]
 8001842:	6878      	ldr	r0, [r7, #4]
 8001844:	4619      	mov	r1, r3
 8001846:	f7fe ffed 	bl	8000824 <USBD_LL_StallEP(_USBD_HandleTypeDef*, unsigned char)>
      }
      break;	
 800184a:	e03e      	b.n	80018ca <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x1a2>
      
    case USBD_STATE_CONFIGURED:
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
                                         &pdev->ep_out[ep_addr & 0x7F];
 800184c:	7bbb      	ldrb	r3, [r7, #14]
 800184e:	b25b      	sxtb	r3, r3
 8001850:	2b00      	cmp	r3, #0
 8001852:	da0b      	bge.n	800186c <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x144>
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 8001854:	7bbb      	ldrb	r3, [r7, #14]
 8001856:	f003 037f 	and.w	r3, r3, #127	; 0x7f
                                         &pdev->ep_out[ep_addr & 0x7F];
 800185a:	f103 0301 	add.w	r3, r3, #1
 800185e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8001862:	687a      	ldr	r2, [r7, #4]
 8001864:	18d3      	adds	r3, r2, r3
 8001866:	f103 0304 	add.w	r3, r3, #4
 800186a:	e00a      	b.n	8001882 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x15a>
 800186c:	7bbb      	ldrb	r3, [r7, #14]
 800186e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8001872:	f103 0310 	add.w	r3, r3, #16
 8001876:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800187a:	687a      	ldr	r2, [r7, #4]
 800187c:	18d3      	adds	r3, r2, r3
 800187e:	f103 0304 	add.w	r3, r3, #4
 8001882:	60bb      	str	r3, [r7, #8]
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 8001884:	7bbb      	ldrb	r3, [r7, #14]
 8001886:	6878      	ldr	r0, [r7, #4]
 8001888:	4619      	mov	r1, r3
 800188a:	f7fe fff7 	bl	800087c <USBD_LL_IsStallEP(_USBD_HandleTypeDef*, unsigned char)>
 800188e:	4603      	mov	r3, r0
 8001890:	2b00      	cmp	r3, #0
 8001892:	bf0c      	ite	eq
 8001894:	2300      	moveq	r3, #0
 8001896:	2301      	movne	r3, #1
 8001898:	b2db      	uxtb	r3, r3
 800189a:	2b00      	cmp	r3, #0
 800189c:	d004      	beq.n	80018a8 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x180>
      {
        pep->status = 0x0001;     
 800189e:	68bb      	ldr	r3, [r7, #8]
 80018a0:	f04f 0201 	mov.w	r2, #1
 80018a4:	601a      	str	r2, [r3, #0]
 80018a6:	e003      	b.n	80018b0 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x188>
      }
      else
      {
        pep->status = 0x0000;  
 80018a8:	68bb      	ldr	r3, [r7, #8]
 80018aa:	f04f 0200 	mov.w	r2, #0
 80018ae:	601a      	str	r2, [r3, #0]
      }
      
      USBD_CtlSendData (pdev,
                        (uint8_t *)&pep->status,
                        2);
 80018b0:	68bb      	ldr	r3, [r7, #8]
 80018b2:	6878      	ldr	r0, [r7, #4]
 80018b4:	4619      	mov	r1, r3
 80018b6:	f04f 0202 	mov.w	r2, #2
 80018ba:	f000 fb81 	bl	8001fc0 <USBD_CtlSendData(_USBD_HandleTypeDef*, unsigned char*, unsigned short)>
      break;
 80018be:	e005      	b.n	80018cc <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x1a4>
      
    default:                         
      USBD_CtlError(pdev , req);
 80018c0:	6878      	ldr	r0, [r7, #4]
 80018c2:	6839      	ldr	r1, [r7, #0]
 80018c4:	f000 faf4 	bl	8001eb0 <USBD_CtlError(_USBD_HandleTypeDef*, usb_setup_req*)>
      break;
 80018c8:	e000      	b.n	80018cc <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x1a4>
    case USBD_STATE_ADDRESSED:          
      if ((ep_addr & 0x7F) != 0x00) 
      {
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
 80018ca:	bf00      	nop
      
    default:                         
      USBD_CtlError(pdev , req);
      break;
    }
    break;
 80018cc:	e000      	b.n	80018d0 <USBD_StdEPReq(_USBD_HandleTypeDef*, usb_setup_req*)+0x1a8>
    
  default:
    break;
 80018ce:	bf00      	nop
  }
  return ret;
 80018d0:	7bfb      	ldrb	r3, [r7, #15]
}
 80018d2:	4618      	mov	r0, r3
 80018d4:	f107 0710 	add.w	r7, r7, #16
 80018d8:	46bd      	mov	sp, r7
 80018da:	bd80      	pop	{r7, pc}

080018dc <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)>:
* @param  req: usb request
* @retval status
*/
static void USBD_GetDescriptor(USBD_HandleTypeDef *pdev , 
                               USBD_SetupReqTypedef *req)
{
 80018dc:	b580      	push	{r7, lr}
 80018de:	b084      	sub	sp, #16
 80018e0:	af00      	add	r7, sp, #0
 80018e2:	6078      	str	r0, [r7, #4]
 80018e4:	6039      	str	r1, [r7, #0]
  uint16_t len;
  uint8_t *pbuf;
  
    
  switch (req->wValue >> 8)
 80018e6:	683b      	ldr	r3, [r7, #0]
 80018e8:	885b      	ldrh	r3, [r3, #2]
 80018ea:	ea4f 2323 	mov.w	r3, r3, asr #8
 80018ee:	f103 33ff 	add.w	r3, r3, #4294967295
 80018f2:	2b06      	cmp	r3, #6
 80018f4:	f200 80d8 	bhi.w	8001aa8 <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x1cc>
 80018f8:	a201      	add	r2, pc, #4	; (adr r2, 8001900 <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x24>)
 80018fa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80018fe:	bf00      	nop
 8001900:	0800191d 	.word	0x0800191d
 8001904:	08001937 	.word	0x08001937
 8001908:	0800197f 	.word	0x0800197f
 800190c:	08001aa9 	.word	0x08001aa9
 8001910:	08001aa9 	.word	0x08001aa9
 8001914:	08001a51 	.word	0x08001a51
 8001918:	08001a77 	.word	0x08001a77
  {
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 800191c:	687b      	ldr	r3, [r7, #4]
 800191e:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
 8001922:	681b      	ldr	r3, [r3, #0]
 8001924:	687a      	ldr	r2, [r7, #4]
 8001926:	7c11      	ldrb	r1, [r2, #16]
 8001928:	f107 020a 	add.w	r2, r7, #10
 800192c:	4608      	mov	r0, r1
 800192e:	4611      	mov	r1, r2
 8001930:	4798      	blx	r3
 8001932:	60f8      	str	r0, [r7, #12]
    break;
 8001934:	e0bd      	b.n	8001ab2 <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x1d6>
    
  case USB_DESC_TYPE_CONFIGURATION:     
    if(pdev->dev_speed == USBD_SPEED_HIGH )   
 8001936:	687b      	ldr	r3, [r7, #4]
 8001938:	7c1b      	ldrb	r3, [r3, #16]
 800193a:	2b00      	cmp	r3, #0
 800193c:	d10f      	bne.n	800195e <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x82>
    {
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
 800193e:	687b      	ldr	r3, [r7, #4]
 8001940:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8001944:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001946:	f107 020a 	add.w	r2, r7, #10
 800194a:	4610      	mov	r0, r2
 800194c:	4798      	blx	r3
 800194e:	60f8      	str	r0, [r7, #12]
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8001950:	68fb      	ldr	r3, [r7, #12]
 8001952:	f103 0301 	add.w	r3, r3, #1
 8001956:	f04f 0202 	mov.w	r2, #2
 800195a:	701a      	strb	r2, [r3, #0]
    else
    {
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    }
    break;
 800195c:	e0a9      	b.n	8001ab2 <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x1d6>
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    }
    else
    {
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 800195e:	687b      	ldr	r3, [r7, #4]
 8001960:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8001964:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001966:	f107 020a 	add.w	r2, r7, #10
 800196a:	4610      	mov	r0, r2
 800196c:	4798      	blx	r3
 800196e:	60f8      	str	r0, [r7, #12]
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8001970:	68fb      	ldr	r3, [r7, #12]
 8001972:	f103 0301 	add.w	r3, r3, #1
 8001976:	f04f 0202 	mov.w	r2, #2
 800197a:	701a      	strb	r2, [r3, #0]
    }
    break;
 800197c:	e099      	b.n	8001ab2 <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x1d6>
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
 800197e:	683b      	ldr	r3, [r7, #0]
 8001980:	885b      	ldrh	r3, [r3, #2]
 8001982:	b2db      	uxtb	r3, r3
 8001984:	2b05      	cmp	r3, #5
 8001986:	d85d      	bhi.n	8001a44 <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x168>
 8001988:	a201      	add	r2, pc, #4	; (adr r2, 8001990 <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0xb4>)
 800198a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800198e:	bf00      	nop
 8001990:	080019a9 	.word	0x080019a9
 8001994:	080019c3 	.word	0x080019c3
 8001998:	080019dd 	.word	0x080019dd
 800199c:	080019f7 	.word	0x080019f7
 80019a0:	08001a11 	.word	0x08001a11
 80019a4:	08001a2b 	.word	0x08001a2b
    {
    case USBD_IDX_LANGID_STR:
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
 80019a8:	687b      	ldr	r3, [r7, #4]
 80019aa:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
 80019ae:	685b      	ldr	r3, [r3, #4]
 80019b0:	687a      	ldr	r2, [r7, #4]
 80019b2:	7c11      	ldrb	r1, [r2, #16]
 80019b4:	f107 020a 	add.w	r2, r7, #10
 80019b8:	4608      	mov	r0, r1
 80019ba:	4611      	mov	r1, r2
 80019bc:	4798      	blx	r3
 80019be:	60f8      	str	r0, [r7, #12]
      break;
 80019c0:	e045      	b.n	8001a4e <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x172>
      
    case USBD_IDX_MFC_STR:
      pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 80019c2:	687b      	ldr	r3, [r7, #4]
 80019c4:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
 80019c8:	689b      	ldr	r3, [r3, #8]
 80019ca:	687a      	ldr	r2, [r7, #4]
 80019cc:	7c11      	ldrb	r1, [r2, #16]
 80019ce:	f107 020a 	add.w	r2, r7, #10
 80019d2:	4608      	mov	r0, r1
 80019d4:	4611      	mov	r1, r2
 80019d6:	4798      	blx	r3
 80019d8:	60f8      	str	r0, [r7, #12]
      break;
 80019da:	e038      	b.n	8001a4e <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x172>
      
    case USBD_IDX_PRODUCT_STR:
      pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 80019dc:	687b      	ldr	r3, [r7, #4]
 80019de:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
 80019e2:	68db      	ldr	r3, [r3, #12]
 80019e4:	687a      	ldr	r2, [r7, #4]
 80019e6:	7c11      	ldrb	r1, [r2, #16]
 80019e8:	f107 020a 	add.w	r2, r7, #10
 80019ec:	4608      	mov	r0, r1
 80019ee:	4611      	mov	r1, r2
 80019f0:	4798      	blx	r3
 80019f2:	60f8      	str	r0, [r7, #12]
      break;
 80019f4:	e02b      	b.n	8001a4e <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x172>
      
    case USBD_IDX_SERIAL_STR:
      pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 80019f6:	687b      	ldr	r3, [r7, #4]
 80019f8:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
 80019fc:	691b      	ldr	r3, [r3, #16]
 80019fe:	687a      	ldr	r2, [r7, #4]
 8001a00:	7c11      	ldrb	r1, [r2, #16]
 8001a02:	f107 020a 	add.w	r2, r7, #10
 8001a06:	4608      	mov	r0, r1
 8001a08:	4611      	mov	r1, r2
 8001a0a:	4798      	blx	r3
 8001a0c:	60f8      	str	r0, [r7, #12]
      break;
 8001a0e:	e01e      	b.n	8001a4e <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x172>
      
    case USBD_IDX_CONFIG_STR:
      pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8001a10:	687b      	ldr	r3, [r7, #4]
 8001a12:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
 8001a16:	695b      	ldr	r3, [r3, #20]
 8001a18:	687a      	ldr	r2, [r7, #4]
 8001a1a:	7c11      	ldrb	r1, [r2, #16]
 8001a1c:	f107 020a 	add.w	r2, r7, #10
 8001a20:	4608      	mov	r0, r1
 8001a22:	4611      	mov	r1, r2
 8001a24:	4798      	blx	r3
 8001a26:	60f8      	str	r0, [r7, #12]
      break;
 8001a28:	e011      	b.n	8001a4e <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x172>
      
    case USBD_IDX_INTERFACE_STR:
      pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8001a2a:	687b      	ldr	r3, [r7, #4]
 8001a2c:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
 8001a30:	699b      	ldr	r3, [r3, #24]
 8001a32:	687a      	ldr	r2, [r7, #4]
 8001a34:	7c11      	ldrb	r1, [r2, #16]
 8001a36:	f107 020a 	add.w	r2, r7, #10
 8001a3a:	4608      	mov	r0, r1
 8001a3c:	4611      	mov	r1, r2
 8001a3e:	4798      	blx	r3
 8001a40:	60f8      	str	r0, [r7, #12]
      break;
 8001a42:	e004      	b.n	8001a4e <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x172>
    default:
#if (USBD_SUPPORT_USER_STRING == 1)
      pbuf = pdev->pClass->GetUsrStrDescriptor(pdev, (req->wValue) , &len);
      break;
#else      
       USBD_CtlError(pdev , req);
 8001a44:	6878      	ldr	r0, [r7, #4]
 8001a46:	6839      	ldr	r1, [r7, #0]
 8001a48:	f000 fa32 	bl	8001eb0 <USBD_CtlError(_USBD_HandleTypeDef*, usb_setup_req*)>
 8001a4c:	e048      	b.n	8001ae0 <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x204>
      return;
#endif   
    }
    break;
 8001a4e:	e030      	b.n	8001ab2 <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x1d6>
  case USB_DESC_TYPE_DEVICE_QUALIFIER:                   

    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 8001a50:	687b      	ldr	r3, [r7, #4]
 8001a52:	7c1b      	ldrb	r3, [r3, #16]
 8001a54:	2b00      	cmp	r3, #0
 8001a56:	d109      	bne.n	8001a6c <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x190>
    {
      pbuf   = (uint8_t *)pdev->pClass->GetDeviceQualifierDescriptor(&len);
 8001a58:	687b      	ldr	r3, [r7, #4]
 8001a5a:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8001a5e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001a60:	f107 020a 	add.w	r2, r7, #10
 8001a64:	4610      	mov	r0, r2
 8001a66:	4798      	blx	r3
 8001a68:	60f8      	str	r0, [r7, #12]
      break;
 8001a6a:	e022      	b.n	8001ab2 <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x1d6>
    }
    else
    {
      USBD_CtlError(pdev , req);
 8001a6c:	6878      	ldr	r0, [r7, #4]
 8001a6e:	6839      	ldr	r1, [r7, #0]
 8001a70:	f000 fa1e 	bl	8001eb0 <USBD_CtlError(_USBD_HandleTypeDef*, usb_setup_req*)>
 8001a74:	e034      	b.n	8001ae0 <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x204>
      return;
    } 

  case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 8001a76:	687b      	ldr	r3, [r7, #4]
 8001a78:	7c1b      	ldrb	r3, [r3, #16]
 8001a7a:	2b00      	cmp	r3, #0
 8001a7c:	d10f      	bne.n	8001a9e <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x1c2>
    {
      pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 8001a7e:	687b      	ldr	r3, [r7, #4]
 8001a80:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8001a84:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001a86:	f107 020a 	add.w	r2, r7, #10
 8001a8a:	4610      	mov	r0, r2
 8001a8c:	4798      	blx	r3
 8001a8e:	60f8      	str	r0, [r7, #12]
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8001a90:	68fb      	ldr	r3, [r7, #12]
 8001a92:	f103 0301 	add.w	r3, r3, #1
 8001a96:	f04f 0207 	mov.w	r2, #7
 8001a9a:	701a      	strb	r2, [r3, #0]
      break; 
 8001a9c:	e009      	b.n	8001ab2 <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x1d6>
    }
    else
    {
      USBD_CtlError(pdev , req);
 8001a9e:	6878      	ldr	r0, [r7, #4]
 8001aa0:	6839      	ldr	r1, [r7, #0]
 8001aa2:	f000 fa05 	bl	8001eb0 <USBD_CtlError(_USBD_HandleTypeDef*, usb_setup_req*)>
 8001aa6:	e01b      	b.n	8001ae0 <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x204>
      return;
    }

  default: 
     USBD_CtlError(pdev , req);
 8001aa8:	6878      	ldr	r0, [r7, #4]
 8001aaa:	6839      	ldr	r1, [r7, #0]
 8001aac:	f000 fa00 	bl	8001eb0 <USBD_CtlError(_USBD_HandleTypeDef*, usb_setup_req*)>
 8001ab0:	e016      	b.n	8001ae0 <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x204>
    return;
  }
  
  if((len != 0)&& (req->wLength != 0))
 8001ab2:	897b      	ldrh	r3, [r7, #10]
 8001ab4:	2b00      	cmp	r3, #0
 8001ab6:	d013      	beq.n	8001ae0 <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x204>
 8001ab8:	683b      	ldr	r3, [r7, #0]
 8001aba:	88db      	ldrh	r3, [r3, #6]
 8001abc:	2b00      	cmp	r3, #0
 8001abe:	d00f      	beq.n	8001ae0 <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x204>
  {
    
    len = MIN(len , req->wLength);
 8001ac0:	683b      	ldr	r3, [r7, #0]
 8001ac2:	88da      	ldrh	r2, [r3, #6]
 8001ac4:	897b      	ldrh	r3, [r7, #10]
 8001ac6:	429a      	cmp	r2, r3
 8001ac8:	d802      	bhi.n	8001ad0 <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x1f4>
 8001aca:	683b      	ldr	r3, [r7, #0]
 8001acc:	88db      	ldrh	r3, [r3, #6]
 8001ace:	e000      	b.n	8001ad2 <USBD_GetDescriptor(_USBD_HandleTypeDef*, usb_setup_req*)+0x1f6>
 8001ad0:	897b      	ldrh	r3, [r7, #10]
 8001ad2:	817b      	strh	r3, [r7, #10]
    
    USBD_CtlSendData (pdev, 
                      pbuf,
                      len);
 8001ad4:	897b      	ldrh	r3, [r7, #10]
 8001ad6:	6878      	ldr	r0, [r7, #4]
 8001ad8:	68f9      	ldr	r1, [r7, #12]
 8001ada:	461a      	mov	r2, r3
 8001adc:	f000 fa70 	bl	8001fc0 <USBD_CtlSendData(_USBD_HandleTypeDef*, unsigned char*, unsigned short)>
  }
  
}
 8001ae0:	f107 0710 	add.w	r7, r7, #16
 8001ae4:	46bd      	mov	sp, r7
 8001ae6:	bd80      	pop	{r7, pc}

08001ae8 <USBD_SetAddress(_USBD_HandleTypeDef*, usb_setup_req*)>:
* @param  req: usb request
* @retval status
*/
static void USBD_SetAddress(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
 8001ae8:	b580      	push	{r7, lr}
 8001aea:	b084      	sub	sp, #16
 8001aec:	af00      	add	r7, sp, #0
 8001aee:	6078      	str	r0, [r7, #4]
 8001af0:	6039      	str	r1, [r7, #0]
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
 8001af2:	683b      	ldr	r3, [r7, #0]
 8001af4:	889b      	ldrh	r3, [r3, #4]
 8001af6:	2b00      	cmp	r3, #0
 8001af8:	d12e      	bne.n	8001b58 <USBD_SetAddress(_USBD_HandleTypeDef*, usb_setup_req*)+0x70>
 8001afa:	683b      	ldr	r3, [r7, #0]
 8001afc:	88db      	ldrh	r3, [r3, #6]
 8001afe:	2b00      	cmp	r3, #0
 8001b00:	d12a      	bne.n	8001b58 <USBD_SetAddress(_USBD_HandleTypeDef*, usb_setup_req*)+0x70>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8001b02:	683b      	ldr	r3, [r7, #0]
 8001b04:	885b      	ldrh	r3, [r3, #2]
 8001b06:	b2db      	uxtb	r3, r3
 8001b08:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8001b0c:	73fb      	strb	r3, [r7, #15]
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8001b0e:	687b      	ldr	r3, [r7, #4]
 8001b10:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 8001b14:	2b03      	cmp	r3, #3
 8001b16:	d104      	bne.n	8001b22 <USBD_SetAddress(_USBD_HandleTypeDef*, usb_setup_req*)+0x3a>
    {
      USBD_CtlError(pdev , req);
 8001b18:	6878      	ldr	r0, [r7, #4]
 8001b1a:	6839      	ldr	r1, [r7, #0]
 8001b1c:	f000 f9c8 	bl	8001eb0 <USBD_CtlError(_USBD_HandleTypeDef*, usb_setup_req*)>
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8001b20:	e01e      	b.n	8001b60 <USBD_SetAddress(_USBD_HandleTypeDef*, usb_setup_req*)+0x78>
    {
      USBD_CtlError(pdev , req);
    } 
    else 
    {
      pdev->dev_address = dev_addr;
 8001b22:	687b      	ldr	r3, [r7, #4]
 8001b24:	7bfa      	ldrb	r2, [r7, #15]
 8001b26:	f883 21fe 	strb.w	r2, [r3, #510]	; 0x1fe
      USBD_LL_SetUSBAddress(pdev, dev_addr);               
 8001b2a:	7bfb      	ldrb	r3, [r7, #15]
 8001b2c:	6878      	ldr	r0, [r7, #4]
 8001b2e:	4619      	mov	r1, r3
 8001b30:	f7fe fed6 	bl	80008e0 <USBD_LL_SetUSBAddress(_USBD_HandleTypeDef*, unsigned char)>
      USBD_CtlSendStatus(pdev);                         
 8001b34:	6878      	ldr	r0, [r7, #4]
 8001b36:	f000 fab1 	bl	800209c <USBD_CtlSendStatus(_USBD_HandleTypeDef*)>
      
      if (dev_addr != 0) 
 8001b3a:	7bfb      	ldrb	r3, [r7, #15]
 8001b3c:	2b00      	cmp	r3, #0
 8001b3e:	d005      	beq.n	8001b4c <USBD_SetAddress(_USBD_HandleTypeDef*, usb_setup_req*)+0x64>
      {
        pdev->dev_state  = USBD_STATE_ADDRESSED;
 8001b40:	687b      	ldr	r3, [r7, #4]
 8001b42:	f04f 0202 	mov.w	r2, #2
 8001b46:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8001b4a:	e009      	b.n	8001b60 <USBD_SetAddress(_USBD_HandleTypeDef*, usb_setup_req*)+0x78>
      {
        pdev->dev_state  = USBD_STATE_ADDRESSED;
      } 
      else 
      {
        pdev->dev_state  = USBD_STATE_DEFAULT; 
 8001b4c:	687b      	ldr	r3, [r7, #4]
 8001b4e:	f04f 0201 	mov.w	r2, #1
 8001b52:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8001b56:	e003      	b.n	8001b60 <USBD_SetAddress(_USBD_HandleTypeDef*, usb_setup_req*)+0x78>
      }
    }
  } 
  else 
  {
     USBD_CtlError(pdev , req);                        
 8001b58:	6878      	ldr	r0, [r7, #4]
 8001b5a:	6839      	ldr	r1, [r7, #0]
 8001b5c:	f000 f9a8 	bl	8001eb0 <USBD_CtlError(_USBD_HandleTypeDef*, usb_setup_req*)>
  } 
}
 8001b60:	f107 0710 	add.w	r7, r7, #16
 8001b64:	46bd      	mov	sp, r7
 8001b66:	bd80      	pop	{r7, pc}

08001b68 <USBD_SetConfig(_USBD_HandleTypeDef*, usb_setup_req*)>:
* @param  req: usb request
* @retval status
*/
static void USBD_SetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
 8001b68:	b580      	push	{r7, lr}
 8001b6a:	b082      	sub	sp, #8
 8001b6c:	af00      	add	r7, sp, #0
 8001b6e:	6078      	str	r0, [r7, #4]
 8001b70:	6039      	str	r1, [r7, #0]
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 8001b72:	683b      	ldr	r3, [r7, #0]
 8001b74:	885b      	ldrh	r3, [r3, #2]
 8001b76:	b2da      	uxtb	r2, r3
 8001b78:	f641 7388 	movw	r3, #8072	; 0x1f88
 8001b7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001b80:	701a      	strb	r2, [r3, #0]
  
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 8001b82:	f641 7388 	movw	r3, #8072	; 0x1f88
 8001b86:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001b8a:	781b      	ldrb	r3, [r3, #0]
 8001b8c:	2b01      	cmp	r3, #1
 8001b8e:	d904      	bls.n	8001b9a <USBD_SetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x32>
  {            
     USBD_CtlError(pdev , req);                              
 8001b90:	6878      	ldr	r0, [r7, #4]
 8001b92:	6839      	ldr	r1, [r7, #0]
 8001b94:	f000 f98c 	bl	8001eb0 <USBD_CtlError(_USBD_HandleTypeDef*, usb_setup_req*)>
 8001b98:	e096      	b.n	8001cc8 <USBD_SetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x160>
  } 
  else 
  {
    switch (pdev->dev_state) 
 8001b9a:	687b      	ldr	r3, [r7, #4]
 8001b9c:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 8001ba0:	2b02      	cmp	r3, #2
 8001ba2:	d002      	beq.n	8001baa <USBD_SetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x42>
 8001ba4:	2b03      	cmp	r3, #3
 8001ba6:	d032      	beq.n	8001c0e <USBD_SetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0xa6>
 8001ba8:	e089      	b.n	8001cbe <USBD_SetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x156>
    {
    case USBD_STATE_ADDRESSED:
      if (cfgidx) 
 8001baa:	f641 7388 	movw	r3, #8072	; 0x1f88
 8001bae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001bb2:	781b      	ldrb	r3, [r3, #0]
 8001bb4:	2b00      	cmp	r3, #0
 8001bb6:	d026      	beq.n	8001c06 <USBD_SetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x9e>
      {                                			   							   							   				
        pdev->dev_config = cfgidx;
 8001bb8:	f641 7388 	movw	r3, #8072	; 0x1f88
 8001bbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001bc0:	781b      	ldrb	r3, [r3, #0]
 8001bc2:	461a      	mov	r2, r3
 8001bc4:	687b      	ldr	r3, [r7, #4]
 8001bc6:	605a      	str	r2, [r3, #4]
        pdev->dev_state = USBD_STATE_CONFIGURED;
 8001bc8:	687b      	ldr	r3, [r7, #4]
 8001bca:	f04f 0203 	mov.w	r2, #3
 8001bce:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 8001bd2:	f641 7388 	movw	r3, #8072	; 0x1f88
 8001bd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001bda:	781b      	ldrb	r3, [r3, #0]
 8001bdc:	6878      	ldr	r0, [r7, #4]
 8001bde:	4619      	mov	r1, r3
 8001be0:	f7ff fb10 	bl	8001204 <USBD_SetClassConfig(_USBD_HandleTypeDef*, unsigned char)>
 8001be4:	4603      	mov	r3, r0
 8001be6:	2b02      	cmp	r3, #2
 8001be8:	bf14      	ite	ne
 8001bea:	2300      	movne	r3, #0
 8001bec:	2301      	moveq	r3, #1
 8001bee:	b2db      	uxtb	r3, r3
 8001bf0:	2b00      	cmp	r3, #0
 8001bf2:	d004      	beq.n	8001bfe <USBD_SetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x96>
        {
          USBD_CtlError(pdev , req);  
 8001bf4:	6878      	ldr	r0, [r7, #4]
 8001bf6:	6839      	ldr	r1, [r7, #0]
 8001bf8:	f000 f95a 	bl	8001eb0 <USBD_CtlError(_USBD_HandleTypeDef*, usb_setup_req*)>
          return;
 8001bfc:	e064      	b.n	8001cc8 <USBD_SetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x160>
        }
        USBD_CtlSendStatus(pdev);
 8001bfe:	6878      	ldr	r0, [r7, #4]
 8001c00:	f000 fa4c 	bl	800209c <USBD_CtlSendStatus(_USBD_HandleTypeDef*)>
      }
      else 
      {
         USBD_CtlSendStatus(pdev);
      }
      break;
 8001c04:	e060      	b.n	8001cc8 <USBD_SetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x160>
        }
        USBD_CtlSendStatus(pdev);
      }
      else 
      {
         USBD_CtlSendStatus(pdev);
 8001c06:	6878      	ldr	r0, [r7, #4]
 8001c08:	f000 fa48 	bl	800209c <USBD_CtlSendStatus(_USBD_HandleTypeDef*)>
      }
      break;
 8001c0c:	e05c      	b.n	8001cc8 <USBD_SetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x160>
      
    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0) 
 8001c0e:	f641 7388 	movw	r3, #8072	; 0x1f88
 8001c12:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001c16:	781b      	ldrb	r3, [r3, #0]
 8001c18:	2b00      	cmp	r3, #0
 8001c1a:	d119      	bne.n	8001c50 <USBD_SetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0xe8>
      {                           
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8001c1c:	687b      	ldr	r3, [r7, #4]
 8001c1e:	f04f 0202 	mov.w	r2, #2
 8001c22:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
        pdev->dev_config = cfgidx;          
 8001c26:	f641 7388 	movw	r3, #8072	; 0x1f88
 8001c2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001c2e:	781b      	ldrb	r3, [r3, #0]
 8001c30:	461a      	mov	r2, r3
 8001c32:	687b      	ldr	r3, [r7, #4]
 8001c34:	605a      	str	r2, [r3, #4]
        USBD_ClrClassConfig(pdev , cfgidx);
 8001c36:	f641 7388 	movw	r3, #8072	; 0x1f88
 8001c3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001c3e:	781b      	ldrb	r3, [r3, #0]
 8001c40:	6878      	ldr	r0, [r7, #4]
 8001c42:	4619      	mov	r1, r3
 8001c44:	f7ff fb06 	bl	8001254 <USBD_ClrClassConfig(_USBD_HandleTypeDef*, unsigned char)>
        USBD_CtlSendStatus(pdev);
 8001c48:	6878      	ldr	r0, [r7, #4]
 8001c4a:	f000 fa27 	bl	800209c <USBD_CtlSendStatus(_USBD_HandleTypeDef*)>
      }
      else
      {
        USBD_CtlSendStatus(pdev);
      }
      break;
 8001c4e:	e03b      	b.n	8001cc8 <USBD_SetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x160>
        pdev->dev_config = cfgidx;          
        USBD_ClrClassConfig(pdev , cfgidx);
        USBD_CtlSendStatus(pdev);
        
      } 
      else  if (cfgidx != pdev->dev_config) 
 8001c50:	f641 7388 	movw	r3, #8072	; 0x1f88
 8001c54:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001c58:	781b      	ldrb	r3, [r3, #0]
 8001c5a:	461a      	mov	r2, r3
 8001c5c:	687b      	ldr	r3, [r7, #4]
 8001c5e:	685b      	ldr	r3, [r3, #4]
 8001c60:	429a      	cmp	r2, r3
 8001c62:	d028      	beq.n	8001cb6 <USBD_SetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x14e>
      {
        /* Clear old configuration */
        USBD_ClrClassConfig(pdev , pdev->dev_config);
 8001c64:	687b      	ldr	r3, [r7, #4]
 8001c66:	685b      	ldr	r3, [r3, #4]
 8001c68:	b2db      	uxtb	r3, r3
 8001c6a:	6878      	ldr	r0, [r7, #4]
 8001c6c:	4619      	mov	r1, r3
 8001c6e:	f7ff faf1 	bl	8001254 <USBD_ClrClassConfig(_USBD_HandleTypeDef*, unsigned char)>
        
        /* set new configuration */
        pdev->dev_config = cfgidx;
 8001c72:	f641 7388 	movw	r3, #8072	; 0x1f88
 8001c76:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001c7a:	781b      	ldrb	r3, [r3, #0]
 8001c7c:	461a      	mov	r2, r3
 8001c7e:	687b      	ldr	r3, [r7, #4]
 8001c80:	605a      	str	r2, [r3, #4]
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 8001c82:	f641 7388 	movw	r3, #8072	; 0x1f88
 8001c86:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001c8a:	781b      	ldrb	r3, [r3, #0]
 8001c8c:	6878      	ldr	r0, [r7, #4]
 8001c8e:	4619      	mov	r1, r3
 8001c90:	f7ff fab8 	bl	8001204 <USBD_SetClassConfig(_USBD_HandleTypeDef*, unsigned char)>
 8001c94:	4603      	mov	r3, r0
 8001c96:	2b02      	cmp	r3, #2
 8001c98:	bf14      	ite	ne
 8001c9a:	2300      	movne	r3, #0
 8001c9c:	2301      	moveq	r3, #1
 8001c9e:	b2db      	uxtb	r3, r3
 8001ca0:	2b00      	cmp	r3, #0
 8001ca2:	d004      	beq.n	8001cae <USBD_SetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x146>
        {
          USBD_CtlError(pdev , req);  
 8001ca4:	6878      	ldr	r0, [r7, #4]
 8001ca6:	6839      	ldr	r1, [r7, #0]
 8001ca8:	f000 f902 	bl	8001eb0 <USBD_CtlError(_USBD_HandleTypeDef*, usb_setup_req*)>
          return;
 8001cac:	e00c      	b.n	8001cc8 <USBD_SetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x160>
        }
        USBD_CtlSendStatus(pdev);
 8001cae:	6878      	ldr	r0, [r7, #4]
 8001cb0:	f000 f9f4 	bl	800209c <USBD_CtlSendStatus(_USBD_HandleTypeDef*)>
      }
      else
      {
        USBD_CtlSendStatus(pdev);
      }
      break;
 8001cb4:	e008      	b.n	8001cc8 <USBD_SetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x160>
        }
        USBD_CtlSendStatus(pdev);
      }
      else
      {
        USBD_CtlSendStatus(pdev);
 8001cb6:	6878      	ldr	r0, [r7, #4]
 8001cb8:	f000 f9f0 	bl	800209c <USBD_CtlSendStatus(_USBD_HandleTypeDef*)>
      }
      break;
 8001cbc:	e004      	b.n	8001cc8 <USBD_SetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x160>
      
    default:					
       USBD_CtlError(pdev , req);                     
 8001cbe:	6878      	ldr	r0, [r7, #4]
 8001cc0:	6839      	ldr	r1, [r7, #0]
 8001cc2:	f000 f8f5 	bl	8001eb0 <USBD_CtlError(_USBD_HandleTypeDef*, usb_setup_req*)>
      break;
 8001cc6:	bf00      	nop
    }
  }
}
 8001cc8:	f107 0708 	add.w	r7, r7, #8
 8001ccc:	46bd      	mov	sp, r7
 8001cce:	bd80      	pop	{r7, pc}

08001cd0 <USBD_GetConfig(_USBD_HandleTypeDef*, usb_setup_req*)>:
* @param  req: usb request
* @retval status
*/
static void USBD_GetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
 8001cd0:	b580      	push	{r7, lr}
 8001cd2:	b082      	sub	sp, #8
 8001cd4:	af00      	add	r7, sp, #0
 8001cd6:	6078      	str	r0, [r7, #4]
 8001cd8:	6039      	str	r1, [r7, #0]

  if (req->wLength != 1) 
 8001cda:	683b      	ldr	r3, [r7, #0]
 8001cdc:	88db      	ldrh	r3, [r3, #6]
 8001cde:	2b01      	cmp	r3, #1
 8001ce0:	d004      	beq.n	8001cec <USBD_GetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x1c>
  {                   
     USBD_CtlError(pdev , req);
 8001ce2:	6878      	ldr	r0, [r7, #4]
 8001ce4:	6839      	ldr	r1, [r7, #0]
 8001ce6:	f000 f8e3 	bl	8001eb0 <USBD_CtlError(_USBD_HandleTypeDef*, usb_setup_req*)>
 8001cea:	e024      	b.n	8001d36 <USBD_GetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x66>
  }
  else 
  {
    switch (pdev->dev_state )  
 8001cec:	687b      	ldr	r3, [r7, #4]
 8001cee:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 8001cf2:	2b02      	cmp	r3, #2
 8001cf4:	d002      	beq.n	8001cfc <USBD_GetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x2c>
 8001cf6:	2b03      	cmp	r3, #3
 8001cf8:	d00e      	beq.n	8001d18 <USBD_GetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x48>
 8001cfa:	e017      	b.n	8001d2c <USBD_GetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x5c>
    {
    case USBD_STATE_ADDRESSED:                     
      pdev->dev_default_config = 0;
 8001cfc:	687b      	ldr	r3, [r7, #4]
 8001cfe:	f04f 0200 	mov.w	r2, #0
 8001d02:	609a      	str	r2, [r3, #8]
      USBD_CtlSendData (pdev, 
                        (uint8_t *)&pdev->dev_default_config,
                        1);
 8001d04:	687b      	ldr	r3, [r7, #4]
 8001d06:	f103 0308 	add.w	r3, r3, #8
 8001d0a:	6878      	ldr	r0, [r7, #4]
 8001d0c:	4619      	mov	r1, r3
 8001d0e:	f04f 0201 	mov.w	r2, #1
 8001d12:	f000 f955 	bl	8001fc0 <USBD_CtlSendData(_USBD_HandleTypeDef*, unsigned char*, unsigned short)>
      break;
 8001d16:	e00e      	b.n	8001d36 <USBD_GetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x66>
      
    case USBD_STATE_CONFIGURED:   
      
      USBD_CtlSendData (pdev, 
                        (uint8_t *)&pdev->dev_config,
                        1);
 8001d18:	687b      	ldr	r3, [r7, #4]
 8001d1a:	f103 0304 	add.w	r3, r3, #4
 8001d1e:	6878      	ldr	r0, [r7, #4]
 8001d20:	4619      	mov	r1, r3
 8001d22:	f04f 0201 	mov.w	r2, #1
 8001d26:	f000 f94b 	bl	8001fc0 <USBD_CtlSendData(_USBD_HandleTypeDef*, unsigned char*, unsigned short)>
      break;
 8001d2a:	e004      	b.n	8001d36 <USBD_GetConfig(_USBD_HandleTypeDef*, usb_setup_req*)+0x66>
      
    default:
       USBD_CtlError(pdev , req);
 8001d2c:	6878      	ldr	r0, [r7, #4]
 8001d2e:	6839      	ldr	r1, [r7, #0]
 8001d30:	f000 f8be 	bl	8001eb0 <USBD_CtlError(_USBD_HandleTypeDef*, usb_setup_req*)>
      break;
 8001d34:	bf00      	nop
    }
  }
}
 8001d36:	f107 0708 	add.w	r7, r7, #8
 8001d3a:	46bd      	mov	sp, r7
 8001d3c:	bd80      	pop	{r7, pc}
 8001d3e:	bf00      	nop

08001d40 <USBD_GetStatus(_USBD_HandleTypeDef*, usb_setup_req*)>:
* @param  req: usb request
* @retval status
*/
static void USBD_GetStatus(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
 8001d40:	b580      	push	{r7, lr}
 8001d42:	b082      	sub	sp, #8
 8001d44:	af00      	add	r7, sp, #0
 8001d46:	6078      	str	r0, [r7, #4]
 8001d48:	6039      	str	r1, [r7, #0]
  
    
  switch (pdev->dev_state) 
 8001d4a:	687b      	ldr	r3, [r7, #4]
 8001d4c:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 8001d50:	f1a3 0302 	sub.w	r3, r3, #2
 8001d54:	2b01      	cmp	r3, #1
 8001d56:	d818      	bhi.n	8001d8a <USBD_GetStatus(_USBD_HandleTypeDef*, usb_setup_req*)+0x4a>
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    
#if ( USBD_SELF_POWERED == 1)
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
 8001d58:	687b      	ldr	r3, [r7, #4]
 8001d5a:	f04f 0201 	mov.w	r2, #1
 8001d5e:	60da      	str	r2, [r3, #12]
#else
    pdev->dev_config_status = 0;                                   
#endif
                      
    if (pdev->dev_remote_wakeup) 
 8001d60:	687b      	ldr	r3, [r7, #4]
 8001d62:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
 8001d66:	2b00      	cmp	r3, #0
 8001d68:	d005      	beq.n	8001d76 <USBD_GetStatus(_USBD_HandleTypeDef*, usb_setup_req*)+0x36>
    {
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
 8001d6a:	687b      	ldr	r3, [r7, #4]
 8001d6c:	68db      	ldr	r3, [r3, #12]
 8001d6e:	f043 0202 	orr.w	r2, r3, #2
 8001d72:	687b      	ldr	r3, [r7, #4]
 8001d74:	60da      	str	r2, [r3, #12]
    }
    
    USBD_CtlSendData (pdev, 
                      (uint8_t *)& pdev->dev_config_status,
                      2);
 8001d76:	687b      	ldr	r3, [r7, #4]
 8001d78:	f103 030c 	add.w	r3, r3, #12
 8001d7c:	6878      	ldr	r0, [r7, #4]
 8001d7e:	4619      	mov	r1, r3
 8001d80:	f04f 0202 	mov.w	r2, #2
 8001d84:	f000 f91c 	bl	8001fc0 <USBD_CtlSendData(_USBD_HandleTypeDef*, unsigned char*, unsigned short)>
    break;
 8001d88:	e004      	b.n	8001d94 <USBD_GetStatus(_USBD_HandleTypeDef*, usb_setup_req*)+0x54>
    
  default :
    USBD_CtlError(pdev , req);                        
 8001d8a:	6878      	ldr	r0, [r7, #4]
 8001d8c:	6839      	ldr	r1, [r7, #0]
 8001d8e:	f000 f88f 	bl	8001eb0 <USBD_CtlError(_USBD_HandleTypeDef*, usb_setup_req*)>
    break;
 8001d92:	bf00      	nop
  }
}
 8001d94:	f107 0708 	add.w	r7, r7, #8
 8001d98:	46bd      	mov	sp, r7
 8001d9a:	bd80      	pop	{r7, pc}

08001d9c <USBD_SetFeature(_USBD_HandleTypeDef*, usb_setup_req*)>:
* @param  req: usb request
* @retval status
*/
static void USBD_SetFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
 8001d9c:	b580      	push	{r7, lr}
 8001d9e:	b082      	sub	sp, #8
 8001da0:	af00      	add	r7, sp, #0
 8001da2:	6078      	str	r0, [r7, #4]
 8001da4:	6039      	str	r1, [r7, #0]

  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8001da6:	683b      	ldr	r3, [r7, #0]
 8001da8:	885b      	ldrh	r3, [r3, #2]
 8001daa:	2b01      	cmp	r3, #1
 8001dac:	d10e      	bne.n	8001dcc <USBD_SetFeature(_USBD_HandleTypeDef*, usb_setup_req*)+0x30>
  {
    pdev->dev_remote_wakeup = 1;  
 8001dae:	687b      	ldr	r3, [r7, #4]
 8001db0:	f04f 0201 	mov.w	r2, #1
 8001db4:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
    pdev->pClass->Setup (pdev, req);   
 8001db8:	687b      	ldr	r3, [r7, #4]
 8001dba:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8001dbe:	689b      	ldr	r3, [r3, #8]
 8001dc0:	6878      	ldr	r0, [r7, #4]
 8001dc2:	6839      	ldr	r1, [r7, #0]
 8001dc4:	4798      	blx	r3
    USBD_CtlSendStatus(pdev);
 8001dc6:	6878      	ldr	r0, [r7, #4]
 8001dc8:	f000 f968 	bl	800209c <USBD_CtlSendStatus(_USBD_HandleTypeDef*)>
  }

}
 8001dcc:	f107 0708 	add.w	r7, r7, #8
 8001dd0:	46bd      	mov	sp, r7
 8001dd2:	bd80      	pop	{r7, pc}

08001dd4 <USBD_ClrFeature(_USBD_HandleTypeDef*, usb_setup_req*)>:
* @param  req: usb request
* @retval status
*/
static void USBD_ClrFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
 8001dd4:	b580      	push	{r7, lr}
 8001dd6:	b082      	sub	sp, #8
 8001dd8:	af00      	add	r7, sp, #0
 8001dda:	6078      	str	r0, [r7, #4]
 8001ddc:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 8001dde:	687b      	ldr	r3, [r7, #4]
 8001de0:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 8001de4:	f1a3 0302 	sub.w	r3, r3, #2
 8001de8:	2b01      	cmp	r3, #1
 8001dea:	d813      	bhi.n	8001e14 <USBD_ClrFeature(_USBD_HandleTypeDef*, usb_setup_req*)+0x40>
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
 8001dec:	683b      	ldr	r3, [r7, #0]
 8001dee:	885b      	ldrh	r3, [r3, #2]
 8001df0:	2b01      	cmp	r3, #1
 8001df2:	d115      	bne.n	8001e20 <USBD_ClrFeature(_USBD_HandleTypeDef*, usb_setup_req*)+0x4c>
    {
      pdev->dev_remote_wakeup = 0; 
 8001df4:	687b      	ldr	r3, [r7, #4]
 8001df6:	f04f 0200 	mov.w	r2, #0
 8001dfa:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
      pdev->pClass->Setup (pdev, req);   
 8001dfe:	687b      	ldr	r3, [r7, #4]
 8001e00:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8001e04:	689b      	ldr	r3, [r3, #8]
 8001e06:	6878      	ldr	r0, [r7, #4]
 8001e08:	6839      	ldr	r1, [r7, #0]
 8001e0a:	4798      	blx	r3
      USBD_CtlSendStatus(pdev);
 8001e0c:	6878      	ldr	r0, [r7, #4]
 8001e0e:	f000 f945 	bl	800209c <USBD_CtlSendStatus(_USBD_HandleTypeDef*)>
    }
    break;
 8001e12:	e005      	b.n	8001e20 <USBD_ClrFeature(_USBD_HandleTypeDef*, usb_setup_req*)+0x4c>
    
  default :
     USBD_CtlError(pdev , req);
 8001e14:	6878      	ldr	r0, [r7, #4]
 8001e16:	6839      	ldr	r1, [r7, #0]
 8001e18:	f000 f84a 	bl	8001eb0 <USBD_CtlError(_USBD_HandleTypeDef*, usb_setup_req*)>
    break;
 8001e1c:	bf00      	nop
 8001e1e:	e000      	b.n	8001e22 <USBD_ClrFeature(_USBD_HandleTypeDef*, usb_setup_req*)+0x4e>
    {
      pdev->dev_remote_wakeup = 0; 
      pdev->pClass->Setup (pdev, req);   
      USBD_CtlSendStatus(pdev);
    }
    break;
 8001e20:	bf00      	nop
    
  default :
     USBD_CtlError(pdev , req);
    break;
  }
}
 8001e22:	f107 0708 	add.w	r7, r7, #8
 8001e26:	46bd      	mov	sp, r7
 8001e28:	bd80      	pop	{r7, pc}
 8001e2a:	bf00      	nop

08001e2c <USBD_ParseSetupRequest(usb_setup_req*, unsigned char*)>:
* @param  req: usb request
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
 8001e2c:	b480      	push	{r7}
 8001e2e:	b083      	sub	sp, #12
 8001e30:	af00      	add	r7, sp, #0
 8001e32:	6078      	str	r0, [r7, #4]
 8001e34:	6039      	str	r1, [r7, #0]
  req->bmRequest     = *(uint8_t *)  (pdata);
 8001e36:	683b      	ldr	r3, [r7, #0]
 8001e38:	781a      	ldrb	r2, [r3, #0]
 8001e3a:	687b      	ldr	r3, [r7, #4]
 8001e3c:	701a      	strb	r2, [r3, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
 8001e3e:	683b      	ldr	r3, [r7, #0]
 8001e40:	785a      	ldrb	r2, [r3, #1]
 8001e42:	687b      	ldr	r3, [r7, #4]
 8001e44:	705a      	strb	r2, [r3, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
 8001e46:	683b      	ldr	r3, [r7, #0]
 8001e48:	f103 0302 	add.w	r3, r3, #2
 8001e4c:	781b      	ldrb	r3, [r3, #0]
 8001e4e:	461a      	mov	r2, r3
 8001e50:	683b      	ldr	r3, [r7, #0]
 8001e52:	f103 0303 	add.w	r3, r3, #3
 8001e56:	781b      	ldrb	r3, [r3, #0]
 8001e58:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8001e5c:	b29b      	uxth	r3, r3
 8001e5e:	18d3      	adds	r3, r2, r3
 8001e60:	b29a      	uxth	r2, r3
 8001e62:	687b      	ldr	r3, [r7, #4]
 8001e64:	805a      	strh	r2, [r3, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
 8001e66:	683b      	ldr	r3, [r7, #0]
 8001e68:	f103 0304 	add.w	r3, r3, #4
 8001e6c:	781b      	ldrb	r3, [r3, #0]
 8001e6e:	461a      	mov	r2, r3
 8001e70:	683b      	ldr	r3, [r7, #0]
 8001e72:	f103 0305 	add.w	r3, r3, #5
 8001e76:	781b      	ldrb	r3, [r3, #0]
 8001e78:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8001e7c:	b29b      	uxth	r3, r3
 8001e7e:	18d3      	adds	r3, r2, r3
 8001e80:	b29a      	uxth	r2, r3
 8001e82:	687b      	ldr	r3, [r7, #4]
 8001e84:	809a      	strh	r2, [r3, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
 8001e86:	683b      	ldr	r3, [r7, #0]
 8001e88:	f103 0306 	add.w	r3, r3, #6
 8001e8c:	781b      	ldrb	r3, [r3, #0]
 8001e8e:	461a      	mov	r2, r3
 8001e90:	683b      	ldr	r3, [r7, #0]
 8001e92:	f103 0307 	add.w	r3, r3, #7
 8001e96:	781b      	ldrb	r3, [r3, #0]
 8001e98:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8001e9c:	b29b      	uxth	r3, r3
 8001e9e:	18d3      	adds	r3, r2, r3
 8001ea0:	b29a      	uxth	r2, r3
 8001ea2:	687b      	ldr	r3, [r7, #4]
 8001ea4:	80da      	strh	r2, [r3, #6]

}
 8001ea6:	f107 070c 	add.w	r7, r7, #12
 8001eaa:	46bd      	mov	sp, r7
 8001eac:	bc80      	pop	{r7}
 8001eae:	4770      	bx	lr

08001eb0 <USBD_CtlError(_USBD_HandleTypeDef*, usb_setup_req*)>:
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
 8001eb0:	b580      	push	{r7, lr}
 8001eb2:	b082      	sub	sp, #8
 8001eb4:	af00      	add	r7, sp, #0
 8001eb6:	6078      	str	r0, [r7, #4]
 8001eb8:	6039      	str	r1, [r7, #0]
  USBD_LL_StallEP(pdev , 0x80);
 8001eba:	6878      	ldr	r0, [r7, #4]
 8001ebc:	f04f 0180 	mov.w	r1, #128	; 0x80
 8001ec0:	f7fe fcb0 	bl	8000824 <USBD_LL_StallEP(_USBD_HandleTypeDef*, unsigned char)>
  USBD_LL_StallEP(pdev , 0);
 8001ec4:	6878      	ldr	r0, [r7, #4]
 8001ec6:	f04f 0100 	mov.w	r1, #0
 8001eca:	f7fe fcab 	bl	8000824 <USBD_LL_StallEP(_USBD_HandleTypeDef*, unsigned char)>
}
 8001ece:	f107 0708 	add.w	r7, r7, #8
 8001ed2:	46bd      	mov	sp, r7
 8001ed4:	bd80      	pop	{r7, pc}
 8001ed6:	bf00      	nop

08001ed8 <USBD_GetString(unsigned char*, unsigned char*, unsigned short*)>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 8001ed8:	b580      	push	{r7, lr}
 8001eda:	b086      	sub	sp, #24
 8001edc:	af00      	add	r7, sp, #0
 8001ede:	60f8      	str	r0, [r7, #12]
 8001ee0:	60b9      	str	r1, [r7, #8]
 8001ee2:	607a      	str	r2, [r7, #4]
  uint8_t idx = 0;
 8001ee4:	f04f 0300 	mov.w	r3, #0
 8001ee8:	75fb      	strb	r3, [r7, #23]
  
  if (desc != NULL) 
 8001eea:	68fb      	ldr	r3, [r7, #12]
 8001eec:	2b00      	cmp	r3, #0
 8001eee:	d042      	beq.n	8001f76 <USBD_GetString(unsigned char*, unsigned char*, unsigned short*)+0x9e>
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
 8001ef0:	68f8      	ldr	r0, [r7, #12]
 8001ef2:	f000 f845 	bl	8001f80 <USBD_GetLen(unsigned char*)>
 8001ef6:	4603      	mov	r3, r0
 8001ef8:	f103 0301 	add.w	r3, r3, #1
 8001efc:	b29b      	uxth	r3, r3
 8001efe:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8001f02:	b29a      	uxth	r2, r3
 8001f04:	687b      	ldr	r3, [r7, #4]
 8001f06:	801a      	strh	r2, [r3, #0]
    unicode[idx++] = *len;
 8001f08:	7dfb      	ldrb	r3, [r7, #23]
 8001f0a:	68ba      	ldr	r2, [r7, #8]
 8001f0c:	18d3      	adds	r3, r2, r3
 8001f0e:	687a      	ldr	r2, [r7, #4]
 8001f10:	8812      	ldrh	r2, [r2, #0]
 8001f12:	b2d2      	uxtb	r2, r2
 8001f14:	701a      	strb	r2, [r3, #0]
 8001f16:	7dfb      	ldrb	r3, [r7, #23]
 8001f18:	f103 0301 	add.w	r3, r3, #1
 8001f1c:	75fb      	strb	r3, [r7, #23]
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 8001f1e:	7dfb      	ldrb	r3, [r7, #23]
 8001f20:	68ba      	ldr	r2, [r7, #8]
 8001f22:	18d3      	adds	r3, r2, r3
 8001f24:	f04f 0203 	mov.w	r2, #3
 8001f28:	701a      	strb	r2, [r3, #0]
 8001f2a:	7dfb      	ldrb	r3, [r7, #23]
 8001f2c:	f103 0301 	add.w	r3, r3, #1
 8001f30:	75fb      	strb	r3, [r7, #23]
    
    while (*desc != '\0') 
 8001f32:	e017      	b.n	8001f64 <USBD_GetString(unsigned char*, unsigned char*, unsigned short*)+0x8c>
    {
      unicode[idx++] = *desc++;
 8001f34:	7dfb      	ldrb	r3, [r7, #23]
 8001f36:	68ba      	ldr	r2, [r7, #8]
 8001f38:	18d3      	adds	r3, r2, r3
 8001f3a:	68fa      	ldr	r2, [r7, #12]
 8001f3c:	7812      	ldrb	r2, [r2, #0]
 8001f3e:	701a      	strb	r2, [r3, #0]
 8001f40:	7dfb      	ldrb	r3, [r7, #23]
 8001f42:	f103 0301 	add.w	r3, r3, #1
 8001f46:	75fb      	strb	r3, [r7, #23]
 8001f48:	68fb      	ldr	r3, [r7, #12]
 8001f4a:	f103 0301 	add.w	r3, r3, #1
 8001f4e:	60fb      	str	r3, [r7, #12]
      unicode[idx++] =  0x00;
 8001f50:	7dfb      	ldrb	r3, [r7, #23]
 8001f52:	68ba      	ldr	r2, [r7, #8]
 8001f54:	18d3      	adds	r3, r2, r3
 8001f56:	f04f 0200 	mov.w	r2, #0
 8001f5a:	701a      	strb	r2, [r3, #0]
 8001f5c:	7dfb      	ldrb	r3, [r7, #23]
 8001f5e:	f103 0301 	add.w	r3, r3, #1
 8001f62:	75fb      	strb	r3, [r7, #23]
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
    
    while (*desc != '\0') 
 8001f64:	68fb      	ldr	r3, [r7, #12]
 8001f66:	781b      	ldrb	r3, [r3, #0]
 8001f68:	2b00      	cmp	r3, #0
 8001f6a:	bf0c      	ite	eq
 8001f6c:	2300      	moveq	r3, #0
 8001f6e:	2301      	movne	r3, #1
 8001f70:	b2db      	uxtb	r3, r3
 8001f72:	2b00      	cmp	r3, #0
 8001f74:	d1de      	bne.n	8001f34 <USBD_GetString(unsigned char*, unsigned char*, unsigned short*)+0x5c>
    {
      unicode[idx++] = *desc++;
      unicode[idx++] =  0x00;
    }
  } 
}
 8001f76:	f107 0718 	add.w	r7, r7, #24
 8001f7a:	46bd      	mov	sp, r7
 8001f7c:	bd80      	pop	{r7, pc}
 8001f7e:	bf00      	nop

08001f80 <USBD_GetLen(unsigned char*)>:
  *         return the string length
   * @param  buf : pointer to the ascii string buffer
  * @retval string length
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
 8001f80:	b480      	push	{r7}
 8001f82:	b085      	sub	sp, #20
 8001f84:	af00      	add	r7, sp, #0
 8001f86:	6078      	str	r0, [r7, #4]
    uint8_t  len = 0;
 8001f88:	f04f 0300 	mov.w	r3, #0
 8001f8c:	73fb      	strb	r3, [r7, #15]

    while (*buf != '\0') 
 8001f8e:	e007      	b.n	8001fa0 <USBD_GetLen(unsigned char*)+0x20>
    {
        len++;
 8001f90:	7bfb      	ldrb	r3, [r7, #15]
 8001f92:	f103 0301 	add.w	r3, r3, #1
 8001f96:	73fb      	strb	r3, [r7, #15]
        buf++;
 8001f98:	687b      	ldr	r3, [r7, #4]
 8001f9a:	f103 0301 	add.w	r3, r3, #1
 8001f9e:	607b      	str	r3, [r7, #4]
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != '\0') 
 8001fa0:	687b      	ldr	r3, [r7, #4]
 8001fa2:	781b      	ldrb	r3, [r3, #0]
 8001fa4:	2b00      	cmp	r3, #0
 8001fa6:	bf0c      	ite	eq
 8001fa8:	2300      	moveq	r3, #0
 8001faa:	2301      	movne	r3, #1
 8001fac:	b2db      	uxtb	r3, r3
 8001fae:	2b00      	cmp	r3, #0
 8001fb0:	d1ee      	bne.n	8001f90 <USBD_GetLen(unsigned char*)+0x10>
    {
        len++;
        buf++;
    }

    return len;
 8001fb2:	7bfb      	ldrb	r3, [r7, #15]
}
 8001fb4:	4618      	mov	r0, r3
 8001fb6:	f107 0714 	add.w	r7, r7, #20
 8001fba:	46bd      	mov	sp, r7
 8001fbc:	bc80      	pop	{r7}
 8001fbe:	4770      	bx	lr

08001fc0 <USBD_CtlSendData(_USBD_HandleTypeDef*, unsigned char*, unsigned short)>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 8001fc0:	b580      	push	{r7, lr}
 8001fc2:	b084      	sub	sp, #16
 8001fc4:	af00      	add	r7, sp, #0
 8001fc6:	60f8      	str	r0, [r7, #12]
 8001fc8:	60b9      	str	r1, [r7, #8]
 8001fca:	4613      	mov	r3, r2
 8001fcc:	80fb      	strh	r3, [r7, #6]
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
 8001fce:	68fb      	ldr	r3, [r7, #12]
 8001fd0:	f04f 0202 	mov.w	r2, #2
 8001fd4:	f8c3 21f4 	str.w	r2, [r3, #500]	; 0x1f4
  pdev->ep_in[0].total_length = len;
 8001fd8:	88fa      	ldrh	r2, [r7, #6]
 8001fda:	68fb      	ldr	r3, [r7, #12]
 8001fdc:	619a      	str	r2, [r3, #24]
  pdev->ep_in[0].rem_length   = len;
 8001fde:	88fa      	ldrh	r2, [r7, #6]
 8001fe0:	68fb      	ldr	r3, [r7, #12]
 8001fe2:	61da      	str	r2, [r3, #28]
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 8001fe4:	88fb      	ldrh	r3, [r7, #6]
 8001fe6:	68f8      	ldr	r0, [r7, #12]
 8001fe8:	f04f 0100 	mov.w	r1, #0
 8001fec:	68ba      	ldr	r2, [r7, #8]
 8001fee:	f7fe fc8d 	bl	800090c <USBD_LL_Transmit(_USBD_HandleTypeDef*, unsigned char, unsigned char*, unsigned short)>
  
  return USBD_OK;
 8001ff2:	f04f 0300 	mov.w	r3, #0
}
 8001ff6:	4618      	mov	r0, r3
 8001ff8:	f107 0710 	add.w	r7, r7, #16
 8001ffc:	46bd      	mov	sp, r7
 8001ffe:	bd80      	pop	{r7, pc}

08002000 <USBD_CtlContinueSendData(_USBD_HandleTypeDef*, unsigned char*, unsigned short)>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueSendData (USBD_HandleTypeDef  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
 8002000:	b580      	push	{r7, lr}
 8002002:	b084      	sub	sp, #16
 8002004:	af00      	add	r7, sp, #0
 8002006:	60f8      	str	r0, [r7, #12]
 8002008:	60b9      	str	r1, [r7, #8]
 800200a:	4613      	mov	r3, r2
 800200c:	80fb      	strh	r3, [r7, #6]
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);   
 800200e:	88fb      	ldrh	r3, [r7, #6]
 8002010:	68f8      	ldr	r0, [r7, #12]
 8002012:	f04f 0100 	mov.w	r1, #0
 8002016:	68ba      	ldr	r2, [r7, #8]
 8002018:	f7fe fc78 	bl	800090c <USBD_LL_Transmit(_USBD_HandleTypeDef*, unsigned char, unsigned char*, unsigned short)>
  
  return USBD_OK;
 800201c:	f04f 0300 	mov.w	r3, #0
}
 8002020:	4618      	mov	r0, r3
 8002022:	f107 0710 	add.w	r7, r7, #16
 8002026:	46bd      	mov	sp, r7
 8002028:	bd80      	pop	{r7, pc}
 800202a:	bf00      	nop

0800202c <USBD_CtlPrepareRx(_USBD_HandleTypeDef*, unsigned char*, unsigned short)>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlPrepareRx (USBD_HandleTypeDef  *pdev,
                                  uint8_t *pbuf,                                  
                                  uint16_t len)
{
 800202c:	b580      	push	{r7, lr}
 800202e:	b084      	sub	sp, #16
 8002030:	af00      	add	r7, sp, #0
 8002032:	60f8      	str	r0, [r7, #12]
 8002034:	60b9      	str	r1, [r7, #8]
 8002036:	4613      	mov	r3, r2
 8002038:	80fb      	strh	r3, [r7, #6]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT; 
 800203a:	68fb      	ldr	r3, [r7, #12]
 800203c:	f04f 0203 	mov.w	r2, #3
 8002040:	f8c3 21f4 	str.w	r2, [r3, #500]	; 0x1f4
  pdev->ep_out[0].total_length = len;
 8002044:	88fa      	ldrh	r2, [r7, #6]
 8002046:	68fb      	ldr	r3, [r7, #12]
 8002048:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
  pdev->ep_out[0].rem_length   = len;
 800204c:	88fa      	ldrh	r2, [r7, #6]
 800204e:	68fb      	ldr	r3, [r7, #12]
 8002050:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
  /* Start the transfer */
  USBD_LL_PrepareReceive (pdev,
                          0,
                          pbuf,
                         len);
 8002054:	88fb      	ldrh	r3, [r7, #6]
 8002056:	68f8      	ldr	r0, [r7, #12]
 8002058:	f04f 0100 	mov.w	r1, #0
 800205c:	68ba      	ldr	r2, [r7, #8]
 800205e:	f7fe fc6f 	bl	8000940 <USBD_LL_PrepareReceive(_USBD_HandleTypeDef*, unsigned char, unsigned char*, unsigned short)>
  
  return USBD_OK;
 8002062:	f04f 0300 	mov.w	r3, #0
}
 8002066:	4618      	mov	r0, r3
 8002068:	f107 0710 	add.w	r7, r7, #16
 800206c:	46bd      	mov	sp, r7
 800206e:	bd80      	pop	{r7, pc}

08002070 <USBD_CtlContinueRx(_USBD_HandleTypeDef*, unsigned char*, unsigned short)>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueRx (USBD_HandleTypeDef  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
 8002070:	b580      	push	{r7, lr}
 8002072:	b084      	sub	sp, #16
 8002074:	af00      	add	r7, sp, #0
 8002076:	60f8      	str	r0, [r7, #12]
 8002078:	60b9      	str	r1, [r7, #8]
 800207a:	4613      	mov	r3, r2
 800207c:	80fb      	strh	r3, [r7, #6]

  USBD_LL_PrepareReceive (pdev,
                          0,                     
                          pbuf,                         
                          len);
 800207e:	88fb      	ldrh	r3, [r7, #6]
 8002080:	68f8      	ldr	r0, [r7, #12]
 8002082:	f04f 0100 	mov.w	r1, #0
 8002086:	68ba      	ldr	r2, [r7, #8]
 8002088:	f7fe fc5a 	bl	8000940 <USBD_LL_PrepareReceive(_USBD_HandleTypeDef*, unsigned char, unsigned char*, unsigned short)>
  return USBD_OK;
 800208c:	f04f 0300 	mov.w	r3, #0
}
 8002090:	4618      	mov	r0, r3
 8002092:	f107 0710 	add.w	r7, r7, #16
 8002096:	46bd      	mov	sp, r7
 8002098:	bd80      	pop	{r7, pc}
 800209a:	bf00      	nop

0800209c <USBD_CtlSendStatus(_USBD_HandleTypeDef*)>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev)
{
 800209c:	b580      	push	{r7, lr}
 800209e:	b082      	sub	sp, #8
 80020a0:	af00      	add	r7, sp, #0
 80020a2:	6078      	str	r0, [r7, #4]

  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 80020a4:	687b      	ldr	r3, [r7, #4]
 80020a6:	f04f 0204 	mov.w	r2, #4
 80020aa:	f8c3 21f4 	str.w	r2, [r3, #500]	; 0x1f4
  
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
 80020ae:	6878      	ldr	r0, [r7, #4]
 80020b0:	f04f 0100 	mov.w	r1, #0
 80020b4:	f04f 0200 	mov.w	r2, #0
 80020b8:	f04f 0300 	mov.w	r3, #0
 80020bc:	f7fe fc26 	bl	800090c <USBD_LL_Transmit(_USBD_HandleTypeDef*, unsigned char, unsigned char*, unsigned short)>
  
  return USBD_OK;
 80020c0:	f04f 0300 	mov.w	r3, #0
}
 80020c4:	4618      	mov	r0, r3
 80020c6:	f107 0708 	add.w	r7, r7, #8
 80020ca:	46bd      	mov	sp, r7
 80020cc:	bd80      	pop	{r7, pc}
 80020ce:	bf00      	nop

080020d0 <USBD_CtlReceiveStatus(_USBD_HandleTypeDef*)>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev)
{
 80020d0:	b580      	push	{r7, lr}
 80020d2:	b082      	sub	sp, #8
 80020d4:	af00      	add	r7, sp, #0
 80020d6:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
 80020d8:	687b      	ldr	r3, [r7, #4]
 80020da:	f04f 0205 	mov.w	r2, #5
 80020de:	f8c3 21f4 	str.w	r2, [r3, #500]	; 0x1f4
  
 /* Start the transfer */  
  USBD_LL_PrepareReceive ( pdev,
                    0,
                    NULL,
                    0);  
 80020e2:	6878      	ldr	r0, [r7, #4]
 80020e4:	f04f 0100 	mov.w	r1, #0
 80020e8:	f04f 0200 	mov.w	r2, #0
 80020ec:	f04f 0300 	mov.w	r3, #0
 80020f0:	f7fe fc26 	bl	8000940 <USBD_LL_PrepareReceive(_USBD_HandleTypeDef*, unsigned char, unsigned char*, unsigned short)>

  return USBD_OK;
 80020f4:	f04f 0300 	mov.w	r3, #0
}
 80020f8:	4618      	mov	r0, r3
 80020fa:	f107 0708 	add.w	r7, r7, #8
 80020fe:	46bd      	mov	sp, r7
 8002100:	bd80      	pop	{r7, pc}
 8002102:	bf00      	nop

08002104 <NVIC_GetPriorityGrouping>:
  The function reads the priority grouping field from the NVIC Interrupt Controller.

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
 8002104:	b480      	push	{r7}
 8002106:	af00      	add	r7, sp, #0
  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
 8002108:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800210c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002110:	68db      	ldr	r3, [r3, #12]
 8002112:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8002116:	ea4f 2313 	mov.w	r3, r3, lsr #8
}
 800211a:	4618      	mov	r0, r3
 800211c:	46bd      	mov	sp, r7
 800211e:	bc80      	pop	{r7}
 8002120:	4770      	bx	lr
 8002122:	bf00      	nop

08002124 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8002124:	b480      	push	{r7}
 8002126:	b083      	sub	sp, #12
 8002128:	af00      	add	r7, sp, #0
 800212a:	4603      	mov	r3, r0
 800212c:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
 800212e:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8002132:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002136:	f997 2007 	ldrsb.w	r2, [r7, #7]
 800213a:	ea4f 1252 	mov.w	r2, r2, lsr #5
 800213e:	79f9      	ldrb	r1, [r7, #7]
 8002140:	f001 011f 	and.w	r1, r1, #31
 8002144:	f04f 0001 	mov.w	r0, #1
 8002148:	fa00 f101 	lsl.w	r1, r0, r1
 800214c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8002150:	f107 070c 	add.w	r7, r7, #12
 8002154:	46bd      	mov	sp, r7
 8002156:	bc80      	pop	{r7}
 8002158:	4770      	bx	lr
 800215a:	bf00      	nop

0800215c <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800215c:	b480      	push	{r7}
 800215e:	b083      	sub	sp, #12
 8002160:	af00      	add	r7, sp, #0
 8002162:	4603      	mov	r3, r0
 8002164:	6039      	str	r1, [r7, #0]
 8002166:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
 8002168:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800216c:	2b00      	cmp	r3, #0
 800216e:	da10      	bge.n	8002192 <NVIC_SetPriority+0x36>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8002170:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8002174:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002178:	79fa      	ldrb	r2, [r7, #7]
 800217a:	f002 020f 	and.w	r2, r2, #15
 800217e:	f1a2 0104 	sub.w	r1, r2, #4
 8002182:	683a      	ldr	r2, [r7, #0]
 8002184:	b2d2      	uxtb	r2, r2
 8002186:	ea4f 1202 	mov.w	r2, r2, lsl #4
 800218a:	b2d2      	uxtb	r2, r2
 800218c:	185b      	adds	r3, r3, r1
 800218e:	761a      	strb	r2, [r3, #24]
 8002190:	e00d      	b.n	80021ae <NVIC_SetPriority+0x52>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 8002192:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8002196:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800219a:	f997 1007 	ldrsb.w	r1, [r7, #7]
 800219e:	683a      	ldr	r2, [r7, #0]
 80021a0:	b2d2      	uxtb	r2, r2
 80021a2:	ea4f 1202 	mov.w	r2, r2, lsl #4
 80021a6:	b2d2      	uxtb	r2, r2
 80021a8:	185b      	adds	r3, r3, r1
 80021aa:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 80021ae:	f107 070c 	add.w	r7, r7, #12
 80021b2:	46bd      	mov	sp, r7
 80021b4:	bc80      	pop	{r7}
 80021b6:	4770      	bx	lr

080021b8 <NVIC_EncodePriority>:
    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
    \param [in]       SubPriority  Subpriority value (starting from 0).
    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80021b8:	b480      	push	{r7}
 80021ba:	b089      	sub	sp, #36	; 0x24
 80021bc:	af00      	add	r7, sp, #0
 80021be:	60f8      	str	r0, [r7, #12]
 80021c0:	60b9      	str	r1, [r7, #8]
 80021c2:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
 80021c4:	68fb      	ldr	r3, [r7, #12]
 80021c6:	f003 0307 	and.w	r3, r3, #7
 80021ca:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
 80021cc:	69fb      	ldr	r3, [r7, #28]
 80021ce:	f1c3 0307 	rsb	r3, r3, #7
 80021d2:	2b04      	cmp	r3, #4
 80021d4:	bf28      	it	cs
 80021d6:	2304      	movcs	r3, #4
 80021d8:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
 80021da:	69fb      	ldr	r3, [r7, #28]
 80021dc:	f103 0304 	add.w	r3, r3, #4
 80021e0:	2b06      	cmp	r3, #6
 80021e2:	d903      	bls.n	80021ec <NVIC_EncodePriority+0x34>
 80021e4:	69fb      	ldr	r3, [r7, #28]
 80021e6:	f1a3 0303 	sub.w	r3, r3, #3
 80021ea:	e001      	b.n	80021f0 <NVIC_EncodePriority+0x38>
 80021ec:	f04f 0300 	mov.w	r3, #0
 80021f0:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
         );
 80021f2:	69bb      	ldr	r3, [r7, #24]
 80021f4:	f04f 0201 	mov.w	r2, #1
 80021f8:	fa02 f303 	lsl.w	r3, r2, r3
 80021fc:	f103 33ff 	add.w	r3, r3, #4294967295
 8002200:	461a      	mov	r2, r3
 8002202:	68bb      	ldr	r3, [r7, #8]
 8002204:	401a      	ands	r2, r3
 8002206:	697b      	ldr	r3, [r7, #20]
 8002208:	fa02 f203 	lsl.w	r2, r2, r3
 800220c:	697b      	ldr	r3, [r7, #20]
 800220e:	f04f 0101 	mov.w	r1, #1
 8002212:	fa01 f303 	lsl.w	r3, r1, r3
 8002216:	f103 33ff 	add.w	r3, r3, #4294967295
 800221a:	4619      	mov	r1, r3
 800221c:	687b      	ldr	r3, [r7, #4]
 800221e:	400b      	ands	r3, r1
 8002220:	4313      	orrs	r3, r2
}
 8002222:	4618      	mov	r0, r3
 8002224:	f107 0724 	add.w	r7, r7, #36	; 0x24
 8002228:	46bd      	mov	sp, r7
 800222a:	bc80      	pop	{r7}
 800222c:	4770      	bx	lr
 800222e:	bf00      	nop

08002230 <SysTick_Config>:
    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8002230:	b580      	push	{r7, lr}
 8002232:	b082      	sub	sp, #8
 8002234:	af00      	add	r7, sp, #0
 8002236:	6078      	str	r0, [r7, #4]
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
 8002238:	687b      	ldr	r3, [r7, #4]
 800223a:	f103 32ff 	add.w	r2, r3, #4294967295
 800223e:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8002242:	429a      	cmp	r2, r3
 8002244:	d902      	bls.n	800224c <SysTick_Config+0x1c>
 8002246:	f04f 0301 	mov.w	r3, #1
 800224a:	e01d      	b.n	8002288 <SysTick_Config+0x58>

  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
 800224c:	f24e 0310 	movw	r3, #57360	; 0xe010
 8002250:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002254:	687a      	ldr	r2, [r7, #4]
 8002256:	f102 32ff 	add.w	r2, r2, #4294967295
 800225a:	605a      	str	r2, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
 800225c:	f04f 30ff 	mov.w	r0, #4294967295
 8002260:	f04f 010f 	mov.w	r1, #15
 8002264:	f7ff ff7a 	bl	800215c <NVIC_SetPriority>
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 8002268:	f24e 0310 	movw	r3, #57360	; 0xe010
 800226c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002270:	f04f 0200 	mov.w	r2, #0
 8002274:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
 8002276:	f24e 0310 	movw	r3, #57360	; 0xe010
 800227a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800227e:	f04f 0207 	mov.w	r2, #7
 8002282:	601a      	str	r2, [r3, #0]
  return (0);                                                  /* Function successful */
 8002284:	f04f 0300 	mov.w	r3, #0
}
 8002288:	4618      	mov	r0, r3
 800228a:	f107 0708 	add.w	r7, r7, #8
 800228e:	46bd      	mov	sp, r7
 8002290:	bd80      	pop	{r7, pc}
 8002292:	bf00      	nop

08002294 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8002294:	b580      	push	{r7, lr}
 8002296:	b086      	sub	sp, #24
 8002298:	af00      	add	r7, sp, #0
 800229a:	4603      	mov	r3, r0
 800229c:	60b9      	str	r1, [r7, #8]
 800229e:	607a      	str	r2, [r7, #4]
 80022a0:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00;
 80022a2:	f04f 0300 	mov.w	r3, #0
 80022a6:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 80022a8:	f7ff ff2c 	bl	8002104 <NVIC_GetPriorityGrouping>
 80022ac:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 80022ae:	6978      	ldr	r0, [r7, #20]
 80022b0:	68b9      	ldr	r1, [r7, #8]
 80022b2:	687a      	ldr	r2, [r7, #4]
 80022b4:	f7ff ff80 	bl	80021b8 <NVIC_EncodePriority>
 80022b8:	4603      	mov	r3, r0
 80022ba:	f997 200f 	ldrsb.w	r2, [r7, #15]
 80022be:	4610      	mov	r0, r2
 80022c0:	4619      	mov	r1, r3
 80022c2:	f7ff ff4b 	bl	800215c <NVIC_SetPriority>
}
 80022c6:	f107 0718 	add.w	r7, r7, #24
 80022ca:	46bd      	mov	sp, r7
 80022cc:	bd80      	pop	{r7, pc}
 80022ce:	bf00      	nop

080022d0 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32l1xx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80022d0:	b580      	push	{r7, lr}
 80022d2:	b082      	sub	sp, #8
 80022d4:	af00      	add	r7, sp, #0
 80022d6:	4603      	mov	r3, r0
 80022d8:	71fb      	strb	r3, [r7, #7]
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 80022da:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80022de:	4618      	mov	r0, r3
 80022e0:	f7ff ff20 	bl	8002124 <NVIC_EnableIRQ>
}
 80022e4:	f107 0708 	add.w	r7, r7, #8
 80022e8:	46bd      	mov	sp, r7
 80022ea:	bd80      	pop	{r7, pc}

080022ec <HAL_SYSTICK_Config>:
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 80022ec:	b580      	push	{r7, lr}
 80022ee:	b082      	sub	sp, #8
 80022f0:	af00      	add	r7, sp, #0
 80022f2:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 80022f4:	6878      	ldr	r0, [r7, #4]
 80022f6:	f7ff ff9b 	bl	8002230 <SysTick_Config>
 80022fa:	4603      	mov	r3, r0
}
 80022fc:	4618      	mov	r0, r3
 80022fe:	f107 0708 	add.w	r7, r7, #8
 8002302:	46bd      	mov	sp, r7
 8002304:	bd80      	pop	{r7, pc}
 8002306:	bf00      	nop

08002308 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8002308:	b580      	push	{r7, lr}
 800230a:	b082      	sub	sp, #8
 800230c:	af00      	add	r7, sp, #0
 800230e:	6078      	str	r0, [r7, #4]
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8002310:	f004 fc2e 	bl	8006b70 <HAL_RCC_GetHCLKFreq>
 8002314:	4602      	mov	r2, r0
 8002316:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 800231a:	f2c1 0362 	movt	r3, #4194	; 0x1062
 800231e:	fba3 1302 	umull	r1, r3, r3, r2
 8002322:	ea4f 1393 	mov.w	r3, r3, lsr #6
 8002326:	4618      	mov	r0, r3
 8002328:	f7ff ffe0 	bl	80022ec <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 800232c:	f04f 30ff 	mov.w	r0, #4294967295
 8002330:	6879      	ldr	r1, [r7, #4]
 8002332:	f04f 0200 	mov.w	r2, #0
 8002336:	f7ff ffad 	bl	8002294 <HAL_NVIC_SetPriority>

   /* Return function status */
  return HAL_OK;
 800233a:	f04f 0300 	mov.w	r3, #0
}
 800233e:	4618      	mov	r0, r3
 8002340:	f107 0708 	add.w	r7, r7, #8
 8002344:	46bd      	mov	sp, r7
 8002346:	bd80      	pop	{r7, pc}

08002348 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8002348:	b480      	push	{r7}
 800234a:	af00      	add	r7, sp, #0
  uwTick++;
 800234c:	f641 738c 	movw	r3, #8076	; 0x1f8c
 8002350:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002354:	681b      	ldr	r3, [r3, #0]
 8002356:	f103 0201 	add.w	r2, r3, #1
 800235a:	f641 738c 	movw	r3, #8076	; 0x1f8c
 800235e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002362:	601a      	str	r2, [r3, #0]
}
 8002364:	46bd      	mov	sp, r7
 8002366:	bc80      	pop	{r7}
 8002368:	4770      	bx	lr
 800236a:	bf00      	nop

0800236c <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 800236c:	b480      	push	{r7}
 800236e:	af00      	add	r7, sp, #0
  return uwTick;
 8002370:	f641 738c 	movw	r3, #8076	; 0x1f8c
 8002374:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002378:	681b      	ldr	r3, [r3, #0]
}
 800237a:	4618      	mov	r0, r3
 800237c:	46bd      	mov	sp, r7
 800237e:	bc80      	pop	{r7}
 8002380:	4770      	bx	lr
 8002382:	bf00      	nop

08002384 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and create the associated handle.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{ 
 8002384:	b580      	push	{r7, lr}
 8002386:	b084      	sub	sp, #16
 8002388:	af00      	add	r7, sp, #0
 800238a:	6078      	str	r0, [r7, #4]
  uint32_t i = 0;
 800238c:	f04f 0300 	mov.w	r3, #0
 8002390:	60fb      	str	r3, [r7, #12]

  uint32_t wInterrupt_Mask = 0;
 8002392:	f04f 0300 	mov.w	r3, #0
 8002396:	60bb      	str	r3, [r7, #8]
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
 8002398:	687b      	ldr	r3, [r7, #4]
 800239a:	2b00      	cmp	r3, #0
 800239c:	d102      	bne.n	80023a4 <HAL_PCD_Init+0x20>
  {
    return HAL_ERROR;
 800239e:	f04f 0301 	mov.w	r3, #1
 80023a2:	e102      	b.n	80025aa <HAL_PCD_Init+0x226>
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  hpcd->State = PCD_BUSY;
 80023a4:	687b      	ldr	r3, [r7, #4]
 80023a6:	f04f 0202 	mov.w	r2, #2
 80023aa:	f883 21e9 	strb.w	r2, [r3, #489]	; 0x1e9
  
  /* Init the low level hardware : GPIO, CLOCK, NVIC... */
  HAL_PCD_MspInit(hpcd);
 80023ae:	6878      	ldr	r0, [r7, #4]
 80023b0:	f7fe f862 	bl	8000478 <HAL_PCD_MspInit>

 /* Init endpoints structures */
 for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
 80023b4:	f04f 0300 	mov.w	r3, #0
 80023b8:	60fb      	str	r3, [r7, #12]
 80023ba:	e058      	b.n	800246e <HAL_PCD_Init+0xea>
 {
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1;
 80023bc:	6879      	ldr	r1, [r7, #4]
 80023be:	68fa      	ldr	r2, [r7, #12]
 80023c0:	4613      	mov	r3, r2
 80023c2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80023c6:	1a9b      	subs	r3, r3, r2
 80023c8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80023cc:	18cb      	adds	r3, r1, r3
 80023ce:	f103 0328 	add.w	r3, r3, #40	; 0x28
 80023d2:	f04f 0201 	mov.w	r2, #1
 80023d6:	705a      	strb	r2, [r3, #1]
   hpcd->IN_ep[i].num = i;
 80023d8:	68fb      	ldr	r3, [r7, #12]
 80023da:	b2d9      	uxtb	r1, r3
 80023dc:	6878      	ldr	r0, [r7, #4]
 80023de:	68fa      	ldr	r2, [r7, #12]
 80023e0:	4613      	mov	r3, r2
 80023e2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80023e6:	1a9b      	subs	r3, r3, r2
 80023e8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80023ec:	18c3      	adds	r3, r0, r3
 80023ee:	f103 0328 	add.w	r3, r3, #40	; 0x28
 80023f2:	460a      	mov	r2, r1
 80023f4:	701a      	strb	r2, [r3, #0]
   /* Control until ep is actvated */
   hpcd->IN_ep[i].type = PCD_EP_TYPE_CTRL;
 80023f6:	6879      	ldr	r1, [r7, #4]
 80023f8:	68fa      	ldr	r2, [r7, #12]
 80023fa:	4613      	mov	r3, r2
 80023fc:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8002400:	1a9b      	subs	r3, r3, r2
 8002402:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002406:	18cb      	adds	r3, r1, r3
 8002408:	f103 0328 	add.w	r3, r3, #40	; 0x28
 800240c:	f04f 0200 	mov.w	r2, #0
 8002410:	70da      	strb	r2, [r3, #3]
   hpcd->IN_ep[i].maxpacket =  0;
 8002412:	6879      	ldr	r1, [r7, #4]
 8002414:	68fa      	ldr	r2, [r7, #12]
 8002416:	4613      	mov	r3, r2
 8002418:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800241c:	1a9b      	subs	r3, r3, r2
 800241e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002422:	18cb      	adds	r3, r1, r3
 8002424:	f103 0334 	add.w	r3, r3, #52	; 0x34
 8002428:	f04f 0200 	mov.w	r2, #0
 800242c:	601a      	str	r2, [r3, #0]
   hpcd->IN_ep[i].xfer_buff = 0;
 800242e:	6879      	ldr	r1, [r7, #4]
 8002430:	68fa      	ldr	r2, [r7, #12]
 8002432:	4613      	mov	r3, r2
 8002434:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8002438:	1a9b      	subs	r3, r3, r2
 800243a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800243e:	18cb      	adds	r3, r1, r3
 8002440:	f103 0338 	add.w	r3, r3, #56	; 0x38
 8002444:	f04f 0200 	mov.w	r2, #0
 8002448:	601a      	str	r2, [r3, #0]
   hpcd->IN_ep[i].xfer_len = 0;
 800244a:	6879      	ldr	r1, [r7, #4]
 800244c:	68fa      	ldr	r2, [r7, #12]
 800244e:	4613      	mov	r3, r2
 8002450:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8002454:	1a9b      	subs	r3, r3, r2
 8002456:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800245a:	18cb      	adds	r3, r1, r3
 800245c:	f103 033c 	add.w	r3, r3, #60	; 0x3c
 8002460:	f04f 0200 	mov.w	r2, #0
 8002464:	601a      	str	r2, [r3, #0]
  
  /* Init the low level hardware : GPIO, CLOCK, NVIC... */
  HAL_PCD_MspInit(hpcd);

 /* Init endpoints structures */
 for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
 8002466:	68fb      	ldr	r3, [r7, #12]
 8002468:	f103 0301 	add.w	r3, r3, #1
 800246c:	60fb      	str	r3, [r7, #12]
 800246e:	687b      	ldr	r3, [r7, #4]
 8002470:	685a      	ldr	r2, [r3, #4]
 8002472:	68fb      	ldr	r3, [r7, #12]
 8002474:	429a      	cmp	r2, r3
 8002476:	bf94      	ite	ls
 8002478:	2300      	movls	r3, #0
 800247a:	2301      	movhi	r3, #1
 800247c:	b2db      	uxtb	r3, r3
 800247e:	2b00      	cmp	r3, #0
 8002480:	d19c      	bne.n	80023bc <HAL_PCD_Init+0x38>
   hpcd->IN_ep[i].maxpacket =  0;
   hpcd->IN_ep[i].xfer_buff = 0;
   hpcd->IN_ep[i].xfer_len = 0;
 }
 
 for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
 8002482:	f04f 0300 	mov.w	r3, #0
 8002486:	60fb      	str	r3, [r7, #12]
 8002488:	e058      	b.n	800253c <HAL_PCD_Init+0x1b8>
 {
   hpcd->OUT_ep[i].is_in = 0;
 800248a:	6879      	ldr	r1, [r7, #4]
 800248c:	68fa      	ldr	r2, [r7, #12]
 800248e:	4613      	mov	r3, r2
 8002490:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8002494:	1a9b      	subs	r3, r3, r2
 8002496:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800249a:	18cb      	adds	r3, r1, r3
 800249c:	f503 7384 	add.w	r3, r3, #264	; 0x108
 80024a0:	f04f 0200 	mov.w	r2, #0
 80024a4:	705a      	strb	r2, [r3, #1]
   hpcd->OUT_ep[i].num = i;
 80024a6:	68fb      	ldr	r3, [r7, #12]
 80024a8:	b2d9      	uxtb	r1, r3
 80024aa:	6878      	ldr	r0, [r7, #4]
 80024ac:	68fa      	ldr	r2, [r7, #12]
 80024ae:	4613      	mov	r3, r2
 80024b0:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80024b4:	1a9b      	subs	r3, r3, r2
 80024b6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80024ba:	18c3      	adds	r3, r0, r3
 80024bc:	f503 7384 	add.w	r3, r3, #264	; 0x108
 80024c0:	460a      	mov	r2, r1
 80024c2:	701a      	strb	r2, [r3, #0]
   /* Control until ep is activated */
   hpcd->OUT_ep[i].type = PCD_EP_TYPE_CTRL;
 80024c4:	6879      	ldr	r1, [r7, #4]
 80024c6:	68fa      	ldr	r2, [r7, #12]
 80024c8:	4613      	mov	r3, r2
 80024ca:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80024ce:	1a9b      	subs	r3, r3, r2
 80024d0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80024d4:	18cb      	adds	r3, r1, r3
 80024d6:	f503 7384 	add.w	r3, r3, #264	; 0x108
 80024da:	f04f 0200 	mov.w	r2, #0
 80024de:	70da      	strb	r2, [r3, #3]
   hpcd->OUT_ep[i].maxpacket = 0;
 80024e0:	6879      	ldr	r1, [r7, #4]
 80024e2:	68fa      	ldr	r2, [r7, #12]
 80024e4:	4613      	mov	r3, r2
 80024e6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80024ea:	1a9b      	subs	r3, r3, r2
 80024ec:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80024f0:	18cb      	adds	r3, r1, r3
 80024f2:	f503 738a 	add.w	r3, r3, #276	; 0x114
 80024f6:	f04f 0200 	mov.w	r2, #0
 80024fa:	601a      	str	r2, [r3, #0]
   hpcd->OUT_ep[i].xfer_buff = 0;
 80024fc:	6879      	ldr	r1, [r7, #4]
 80024fe:	68fa      	ldr	r2, [r7, #12]
 8002500:	4613      	mov	r3, r2
 8002502:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8002506:	1a9b      	subs	r3, r3, r2
 8002508:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800250c:	18cb      	adds	r3, r1, r3
 800250e:	f503 738c 	add.w	r3, r3, #280	; 0x118
 8002512:	f04f 0200 	mov.w	r2, #0
 8002516:	601a      	str	r2, [r3, #0]
   hpcd->OUT_ep[i].xfer_len = 0;
 8002518:	6879      	ldr	r1, [r7, #4]
 800251a:	68fa      	ldr	r2, [r7, #12]
 800251c:	4613      	mov	r3, r2
 800251e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8002522:	1a9b      	subs	r3, r3, r2
 8002524:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002528:	18cb      	adds	r3, r1, r3
 800252a:	f503 738e 	add.w	r3, r3, #284	; 0x11c
 800252e:	f04f 0200 	mov.w	r2, #0
 8002532:	601a      	str	r2, [r3, #0]
   hpcd->IN_ep[i].maxpacket =  0;
   hpcd->IN_ep[i].xfer_buff = 0;
   hpcd->IN_ep[i].xfer_len = 0;
 }
 
 for (i = 0; i < hpcd->Init.dev_endpoints ; i++)
 8002534:	68fb      	ldr	r3, [r7, #12]
 8002536:	f103 0301 	add.w	r3, r3, #1
 800253a:	60fb      	str	r3, [r7, #12]
 800253c:	687b      	ldr	r3, [r7, #4]
 800253e:	685a      	ldr	r2, [r3, #4]
 8002540:	68fb      	ldr	r3, [r7, #12]
 8002542:	429a      	cmp	r2, r3
 8002544:	bf94      	ite	ls
 8002546:	2300      	movls	r3, #0
 8002548:	2301      	movhi	r3, #1
 800254a:	b2db      	uxtb	r3, r3
 800254c:	2b00      	cmp	r3, #0
 800254e:	d19c      	bne.n	800248a <HAL_PCD_Init+0x106>
   hpcd->OUT_ep[i].xfer_len = 0;
 }
  
 /* Init Device */
 /*CNTR_FRES = 1*/
 hpcd->Instance->CNTR = USB_CNTR_FRES;
 8002550:	687b      	ldr	r3, [r7, #4]
 8002552:	681b      	ldr	r3, [r3, #0]
 8002554:	f04f 0201 	mov.w	r2, #1
 8002558:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
 
 /*CNTR_FRES = 0*/
 hpcd->Instance->CNTR = 0;
 800255c:	687b      	ldr	r3, [r7, #4]
 800255e:	681b      	ldr	r3, [r3, #0]
 8002560:	f04f 0200 	mov.w	r2, #0
 8002564:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
 
 /*Clear pending interrupts*/
 hpcd->Instance->ISTR = 0;
 8002568:	687b      	ldr	r3, [r7, #4]
 800256a:	681b      	ldr	r3, [r3, #0]
 800256c:	f04f 0200 	mov.w	r2, #0
 8002570:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
 
  /*Set Btable Adress*/
 hpcd->Instance->BTABLE = BTABLE_ADDRESS;
 8002574:	687b      	ldr	r3, [r7, #4]
 8002576:	681b      	ldr	r3, [r3, #0]
 8002578:	f04f 0200 	mov.w	r2, #0
 800257c:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
  
  /*set wInterrupt_Mask global variable*/
  wInterrupt_Mask = USB_CNTR_CTRM  | USB_CNTR_WKUPM | USB_CNTR_SUSPM | USB_CNTR_ERRM \
    | USB_CNTR_ESOFM | USB_CNTR_RESETM;
 8002580:	f44f 433d 	mov.w	r3, #48384	; 0xbd00
 8002584:	60bb      	str	r3, [r7, #8]
  
  /*Set interrupt mask*/
  hpcd->Instance->CNTR = wInterrupt_Mask;
 8002586:	687b      	ldr	r3, [r7, #4]
 8002588:	681b      	ldr	r3, [r3, #0]
 800258a:	68ba      	ldr	r2, [r7, #8]
 800258c:	b292      	uxth	r2, r2
 800258e:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
  
  hpcd->USB_Address = 0;
 8002592:	687b      	ldr	r3, [r7, #4]
 8002594:	f04f 0200 	mov.w	r2, #0
 8002598:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  hpcd->State= PCD_READY;
 800259c:	687b      	ldr	r3, [r7, #4]
 800259e:	f04f 0200 	mov.w	r2, #0
 80025a2:	f883 21e9 	strb.w	r2, [r3, #489]	; 0x1e9

 return HAL_OK;
 80025a6:	f04f 0300 	mov.w	r3, #0
}
 80025aa:	4618      	mov	r0, r3
 80025ac:	f107 0710 	add.w	r7, r7, #16
 80025b0:	46bd      	mov	sp, r7
 80025b2:	bd80      	pop	{r7, pc}

080025b4 <HAL_PCD_Start>:
  * @brief  Start The USB OTG Device.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
 80025b4:	b580      	push	{r7, lr}
 80025b6:	b082      	sub	sp, #8
 80025b8:	af00      	add	r7, sp, #0
 80025ba:	6078      	str	r0, [r7, #4]
  HAL_PCDEx_SetConnectionState (hpcd, 1);
 80025bc:	6878      	ldr	r0, [r7, #4]
 80025be:	f04f 0101 	mov.w	r1, #1
 80025c2:	f7fe fa09 	bl	80009d8 <HAL_PCDEx_SetConnectionState>
  return HAL_OK;
 80025c6:	f04f 0300 	mov.w	r3, #0
}
 80025ca:	4618      	mov	r0, r3
 80025cc:	f107 0708 	add.w	r7, r7, #8
 80025d0:	46bd      	mov	sp, r7
 80025d2:	bd80      	pop	{r7, pc}

080025d4 <HAL_PCD_IRQHandler>:
  * @brief  This function handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 80025d4:	b580      	push	{r7, lr}
 80025d6:	b084      	sub	sp, #16
 80025d8:	af00      	add	r7, sp, #0
 80025da:	6078      	str	r0, [r7, #4]
  uint32_t wInterrupt_Mask = 0;
 80025dc:	f04f 0300 	mov.w	r3, #0
 80025e0:	60fb      	str	r3, [r7, #12]
  
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_CTR))
 80025e2:	687b      	ldr	r3, [r7, #4]
 80025e4:	681b      	ldr	r3, [r3, #0]
 80025e6:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 80025ea:	b29b      	uxth	r3, r3
 80025ec:	b29b      	uxth	r3, r3
 80025ee:	ea4f 33d3 	mov.w	r3, r3, lsr #15
 80025f2:	b2db      	uxtb	r3, r3
 80025f4:	2b00      	cmp	r3, #0
 80025f6:	d002      	beq.n	80025fe <HAL_PCD_IRQHandler+0x2a>
  {
    /* servicing of the endpoint correct transfer interrupt */
    /* clear of the CTR flag into the sub */
    PCD_EP_ISR_Handler(hpcd);
 80025f8:	6878      	ldr	r0, [r7, #4]
 80025fa:	f001 fc11 	bl	8003e20 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)>
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_RESET))
 80025fe:	687b      	ldr	r3, [r7, #4]
 8002600:	681b      	ldr	r3, [r3, #0]
 8002602:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 8002606:	b29b      	uxth	r3, r3
 8002608:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800260c:	2b00      	cmp	r3, #0
 800260e:	bf0c      	ite	eq
 8002610:	2300      	moveq	r3, #0
 8002612:	2301      	movne	r3, #1
 8002614:	b2db      	uxtb	r3, r3
 8002616:	2b00      	cmp	r3, #0
 8002618:	d013      	beq.n	8002642 <HAL_PCD_IRQHandler+0x6e>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
 800261a:	687b      	ldr	r3, [r7, #4]
 800261c:	681b      	ldr	r3, [r3, #0]
 800261e:	687a      	ldr	r2, [r7, #4]
 8002620:	6812      	ldr	r2, [r2, #0]
 8002622:	f8b2 2044 	ldrh.w	r2, [r2, #68]	; 0x44
 8002626:	b292      	uxth	r2, r2
 8002628:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800262c:	b292      	uxth	r2, r2
 800262e:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
    HAL_PCD_ResetCallback(hpcd);
 8002632:	6878      	ldr	r0, [r7, #4]
 8002634:	f7fd ffa8 	bl	8000588 <HAL_PCD_ResetCallback>
    HAL_PCD_SetAddress(hpcd, 0);
 8002638:	6878      	ldr	r0, [r7, #4]
 800263a:	f04f 0100 	mov.w	r1, #0
 800263e:	f000 f8e5 	bl	800280c <HAL_PCD_SetAddress>
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_PMAOVRM))
 8002642:	687b      	ldr	r3, [r7, #4]
 8002644:	681b      	ldr	r3, [r3, #0]
 8002646:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800264a:	b29b      	uxth	r3, r3
 800264c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8002650:	2b00      	cmp	r3, #0
 8002652:	bf0c      	ite	eq
 8002654:	2300      	moveq	r3, #0
 8002656:	2301      	movne	r3, #1
 8002658:	b2db      	uxtb	r3, r3
 800265a:	2b00      	cmp	r3, #0
 800265c:	d00b      	beq.n	8002676 <HAL_PCD_IRQHandler+0xa2>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_PMAOVRM);    
 800265e:	687b      	ldr	r3, [r7, #4]
 8002660:	681b      	ldr	r3, [r3, #0]
 8002662:	687a      	ldr	r2, [r7, #4]
 8002664:	6812      	ldr	r2, [r2, #0]
 8002666:	f8b2 2044 	ldrh.w	r2, [r2, #68]	; 0x44
 800266a:	b292      	uxth	r2, r2
 800266c:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8002670:	b292      	uxth	r2, r2
 8002672:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
  }
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_ERR))
 8002676:	687b      	ldr	r3, [r7, #4]
 8002678:	681b      	ldr	r3, [r3, #0]
 800267a:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800267e:	b29b      	uxth	r3, r3
 8002680:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8002684:	2b00      	cmp	r3, #0
 8002686:	bf0c      	ite	eq
 8002688:	2300      	moveq	r3, #0
 800268a:	2301      	movne	r3, #1
 800268c:	b2db      	uxtb	r3, r3
 800268e:	2b00      	cmp	r3, #0
 8002690:	d00b      	beq.n	80026aa <HAL_PCD_IRQHandler+0xd6>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ERR); 
 8002692:	687b      	ldr	r3, [r7, #4]
 8002694:	681b      	ldr	r3, [r3, #0]
 8002696:	687a      	ldr	r2, [r7, #4]
 8002698:	6812      	ldr	r2, [r2, #0]
 800269a:	f8b2 2044 	ldrh.w	r2, [r2, #68]	; 0x44
 800269e:	b292      	uxth	r2, r2
 80026a0:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 80026a4:	b292      	uxth	r2, r2
 80026a6:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_WKUP))
 80026aa:	687b      	ldr	r3, [r7, #4]
 80026ac:	681b      	ldr	r3, [r3, #0]
 80026ae:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 80026b2:	b29b      	uxth	r3, r3
 80026b4:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80026b8:	2b00      	cmp	r3, #0
 80026ba:	bf0c      	ite	eq
 80026bc:	2300      	moveq	r3, #0
 80026be:	2301      	movne	r3, #1
 80026c0:	b2db      	uxtb	r3, r3
 80026c2:	2b00      	cmp	r3, #0
 80026c4:	d023      	beq.n	800270e <HAL_PCD_IRQHandler+0x13a>
  {  
    hpcd->Instance->CNTR &= ~(USB_CNTR_LP_MODE);
 80026c6:	687b      	ldr	r3, [r7, #4]
 80026c8:	681b      	ldr	r3, [r3, #0]
 80026ca:	687a      	ldr	r2, [r7, #4]
 80026cc:	6812      	ldr	r2, [r2, #0]
 80026ce:	f8b2 2040 	ldrh.w	r2, [r2, #64]	; 0x40
 80026d2:	b292      	uxth	r2, r2
 80026d4:	f022 0204 	bic.w	r2, r2, #4
 80026d8:	b292      	uxth	r2, r2
 80026da:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    
    /*set wInterrupt_Mask global variable*/
    wInterrupt_Mask = USB_CNTR_CTRM  | USB_CNTR_WKUPM | USB_CNTR_SUSPM | USB_CNTR_ERRM \
      | USB_CNTR_ESOFM | USB_CNTR_RESETM;
 80026de:	f44f 433d 	mov.w	r3, #48384	; 0xbd00
 80026e2:	60fb      	str	r3, [r7, #12]
    
    /*Set interrupt mask*/
    hpcd->Instance->CNTR = wInterrupt_Mask;
 80026e4:	687b      	ldr	r3, [r7, #4]
 80026e6:	681b      	ldr	r3, [r3, #0]
 80026e8:	68fa      	ldr	r2, [r7, #12]
 80026ea:	b292      	uxth	r2, r2
 80026ec:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    
    HAL_PCD_ResumeCallback(hpcd);
 80026f0:	6878      	ldr	r0, [r7, #4]
 80026f2:	f7fd ff8d 	bl	8000610 <HAL_PCD_ResumeCallback>
    
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_WKUP);     
 80026f6:	687b      	ldr	r3, [r7, #4]
 80026f8:	681b      	ldr	r3, [r3, #0]
 80026fa:	687a      	ldr	r2, [r7, #4]
 80026fc:	6812      	ldr	r2, [r2, #0]
 80026fe:	f8b2 2044 	ldrh.w	r2, [r2, #68]	; 0x44
 8002702:	b292      	uxth	r2, r2
 8002704:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8002708:	b292      	uxth	r2, r2
 800270a:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_SUSP))
 800270e:	687b      	ldr	r3, [r7, #4]
 8002710:	681b      	ldr	r3, [r3, #0]
 8002712:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 8002716:	b29b      	uxth	r3, r3
 8002718:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800271c:	2b00      	cmp	r3, #0
 800271e:	bf0c      	ite	eq
 8002720:	2300      	moveq	r3, #0
 8002722:	2301      	movne	r3, #1
 8002724:	b2db      	uxtb	r3, r3
 8002726:	2b00      	cmp	r3, #0
 8002728:	d034      	beq.n	8002794 <HAL_PCD_IRQHandler+0x1c0>
  {    
    /* clear of the ISTR bit must be done after setting of CNTR_FSUSP */
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SUSP);  
 800272a:	687b      	ldr	r3, [r7, #4]
 800272c:	681b      	ldr	r3, [r3, #0]
 800272e:	687a      	ldr	r2, [r7, #4]
 8002730:	6812      	ldr	r2, [r2, #0]
 8002732:	f8b2 2044 	ldrh.w	r2, [r2, #68]	; 0x44
 8002736:	b292      	uxth	r2, r2
 8002738:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 800273c:	b292      	uxth	r2, r2
 800273e:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
    
    /* Force low-power mode in the macrocell */
    hpcd->Instance->CNTR |= USB_CNTR_FSUSP;
 8002742:	687b      	ldr	r3, [r7, #4]
 8002744:	681b      	ldr	r3, [r3, #0]
 8002746:	687a      	ldr	r2, [r7, #4]
 8002748:	6812      	ldr	r2, [r2, #0]
 800274a:	f8b2 2040 	ldrh.w	r2, [r2, #64]	; 0x40
 800274e:	b292      	uxth	r2, r2
 8002750:	f042 0208 	orr.w	r2, r2, #8
 8002754:	b292      	uxth	r2, r2
 8002756:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    hpcd->Instance->CNTR |= USB_CNTR_LP_MODE;
 800275a:	687b      	ldr	r3, [r7, #4]
 800275c:	681b      	ldr	r3, [r3, #0]
 800275e:	687a      	ldr	r2, [r7, #4]
 8002760:	6812      	ldr	r2, [r2, #0]
 8002762:	f8b2 2040 	ldrh.w	r2, [r2, #64]	; 0x40
 8002766:	b292      	uxth	r2, r2
 8002768:	f042 0204 	orr.w	r2, r2, #4
 800276c:	b292      	uxth	r2, r2
 800276e:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_WKUP) == 0)
 8002772:	687b      	ldr	r3, [r7, #4]
 8002774:	681b      	ldr	r3, [r3, #0]
 8002776:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800277a:	b29b      	uxth	r3, r3
 800277c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8002780:	2b00      	cmp	r3, #0
 8002782:	bf14      	ite	ne
 8002784:	2300      	movne	r3, #0
 8002786:	2301      	moveq	r3, #1
 8002788:	b2db      	uxtb	r3, r3
 800278a:	2b00      	cmp	r3, #0
 800278c:	d002      	beq.n	8002794 <HAL_PCD_IRQHandler+0x1c0>
    {
      HAL_PCD_SuspendCallback(hpcd);
 800278e:	6878      	ldr	r0, [r7, #4]
 8002790:	f7fd ff20 	bl	80005d4 <HAL_PCD_SuspendCallback>
    }
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_SOF))
 8002794:	687b      	ldr	r3, [r7, #4]
 8002796:	681b      	ldr	r3, [r3, #0]
 8002798:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800279c:	b29b      	uxth	r3, r3
 800279e:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80027a2:	2b00      	cmp	r3, #0
 80027a4:	bf0c      	ite	eq
 80027a6:	2300      	moveq	r3, #0
 80027a8:	2301      	movne	r3, #1
 80027aa:	b2db      	uxtb	r3, r3
 80027ac:	2b00      	cmp	r3, #0
 80027ae:	d00e      	beq.n	80027ce <HAL_PCD_IRQHandler+0x1fa>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SOF); 
 80027b0:	687b      	ldr	r3, [r7, #4]
 80027b2:	681b      	ldr	r3, [r3, #0]
 80027b4:	687a      	ldr	r2, [r7, #4]
 80027b6:	6812      	ldr	r2, [r2, #0]
 80027b8:	f8b2 2044 	ldrh.w	r2, [r2, #68]	; 0x44
 80027bc:	b292      	uxth	r2, r2
 80027be:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 80027c2:	b292      	uxth	r2, r2
 80027c4:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
    HAL_PCD_SOFCallback(hpcd);
 80027c8:	6878      	ldr	r0, [r7, #4]
 80027ca:	f7fd fecf 	bl	800056c <HAL_PCD_SOFCallback>
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_ESOF))
 80027ce:	687b      	ldr	r3, [r7, #4]
 80027d0:	681b      	ldr	r3, [r3, #0]
 80027d2:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 80027d6:	b29b      	uxth	r3, r3
 80027d8:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80027dc:	2b00      	cmp	r3, #0
 80027de:	bf0c      	ite	eq
 80027e0:	2300      	moveq	r3, #0
 80027e2:	2301      	movne	r3, #1
 80027e4:	b2db      	uxtb	r3, r3
 80027e6:	2b00      	cmp	r3, #0
 80027e8:	d00b      	beq.n	8002802 <HAL_PCD_IRQHandler+0x22e>
  {
    /* clear ESOF flag in ISTR */
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ESOF); 
 80027ea:	687b      	ldr	r3, [r7, #4]
 80027ec:	681b      	ldr	r3, [r3, #0]
 80027ee:	687a      	ldr	r2, [r7, #4]
 80027f0:	6812      	ldr	r2, [r2, #0]
 80027f2:	f8b2 2044 	ldrh.w	r2, [r2, #68]	; 0x44
 80027f6:	b292      	uxth	r2, r2
 80027f8:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80027fc:	b292      	uxth	r2, r2
 80027fe:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
  }
}
 8002802:	f107 0710 	add.w	r7, r7, #16
 8002806:	46bd      	mov	sp, r7
 8002808:	bd80      	pop	{r7, pc}
 800280a:	bf00      	nop

0800280c <HAL_PCD_SetAddress>:
  * @param  hpcd: PCD handle
  * @param  address: new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
 800280c:	b480      	push	{r7}
 800280e:	b083      	sub	sp, #12
 8002810:	af00      	add	r7, sp, #0
 8002812:	6078      	str	r0, [r7, #4]
 8002814:	460b      	mov	r3, r1
 8002816:	70fb      	strb	r3, [r7, #3]
   __HAL_LOCK(hpcd); 
 8002818:	687b      	ldr	r3, [r7, #4]
 800281a:	f893 31e8 	ldrb.w	r3, [r3, #488]	; 0x1e8
 800281e:	2b01      	cmp	r3, #1
 8002820:	d102      	bne.n	8002828 <HAL_PCD_SetAddress+0x1c>
 8002822:	f04f 0302 	mov.w	r3, #2
 8002826:	e019      	b.n	800285c <HAL_PCD_SetAddress+0x50>
 8002828:	687b      	ldr	r3, [r7, #4]
 800282a:	f04f 0201 	mov.w	r2, #1
 800282e:	f883 21e8 	strb.w	r2, [r3, #488]	; 0x1e8

   if(address == 0) 
 8002832:	78fb      	ldrb	r3, [r7, #3]
 8002834:	2b00      	cmp	r3, #0
 8002836:	d106      	bne.n	8002846 <HAL_PCD_SetAddress+0x3a>
   {
     /* set device address and enable function */
     hpcd->Instance->DADDR = USB_DADDR_EF;
 8002838:	687b      	ldr	r3, [r7, #4]
 800283a:	681b      	ldr	r3, [r3, #0]
 800283c:	f04f 0280 	mov.w	r2, #128	; 0x80
 8002840:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
 8002844:	e003      	b.n	800284e <HAL_PCD_SetAddress+0x42>
   }
   else /* USB Address will be applied later */
   {
     hpcd->USB_Address = address;
 8002846:	687b      	ldr	r3, [r7, #4]
 8002848:	78fa      	ldrb	r2, [r7, #3]
 800284a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
   }

  __HAL_UNLOCK(hpcd);   
 800284e:	687b      	ldr	r3, [r7, #4]
 8002850:	f04f 0200 	mov.w	r2, #0
 8002854:	f883 21e8 	strb.w	r2, [r3, #488]	; 0x1e8
  return HAL_OK;
 8002858:	f04f 0300 	mov.w	r3, #0
}
 800285c:	4618      	mov	r0, r3
 800285e:	f107 070c 	add.w	r7, r7, #12
 8002862:	46bd      	mov	sp, r7
 8002864:	bc80      	pop	{r7}
 8002866:	4770      	bx	lr

08002868 <HAL_PCD_EP_Open>:
  * @param  ep_mps: endpoint max packert size
  * @param  ep_type: endpoint type   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
{
 8002868:	b490      	push	{r4, r7}
 800286a:	b086      	sub	sp, #24
 800286c:	af00      	add	r7, sp, #0
 800286e:	6078      	str	r0, [r7, #4]
 8002870:	70f9      	strb	r1, [r7, #3]
 8002872:	803a      	strh	r2, [r7, #0]
 8002874:	70bb      	strb	r3, [r7, #2]
  HAL_StatusTypeDef  ret = HAL_OK;
 8002876:	f04f 0300 	mov.w	r3, #0
 800287a:	747b      	strb	r3, [r7, #17]
  PCD_EPTypeDef *ep;
  
  if ((ep_addr & 0x80) == 0x80)
 800287c:	78fb      	ldrb	r3, [r7, #3]
 800287e:	b25b      	sxtb	r3, r3
 8002880:	2b00      	cmp	r3, #0
 8002882:	da0e      	bge.n	80028a2 <HAL_PCD_EP_Open+0x3a>
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8002884:	78fb      	ldrb	r3, [r7, #3]
 8002886:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 800288a:	4613      	mov	r3, r2
 800288c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8002890:	1a9b      	subs	r3, r3, r2
 8002892:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002896:	f103 0328 	add.w	r3, r3, #40	; 0x28
 800289a:	687a      	ldr	r2, [r7, #4]
 800289c:	18d3      	adds	r3, r2, r3
 800289e:	617b      	str	r3, [r7, #20]
 80028a0:	e00d      	b.n	80028be <HAL_PCD_EP_Open+0x56>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 80028a2:	78fb      	ldrb	r3, [r7, #3]
 80028a4:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 80028a8:	4613      	mov	r3, r2
 80028aa:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80028ae:	1a9b      	subs	r3, r3, r2
 80028b0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80028b4:	f503 7384 	add.w	r3, r3, #264	; 0x108
 80028b8:	687a      	ldr	r2, [r7, #4]
 80028ba:	18d3      	adds	r3, r2, r3
 80028bc:	617b      	str	r3, [r7, #20]
  }
  ep->num   = ep_addr & 0x7F;
 80028be:	78fb      	ldrb	r3, [r7, #3]
 80028c0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80028c4:	b2da      	uxtb	r2, r3
 80028c6:	697b      	ldr	r3, [r7, #20]
 80028c8:	701a      	strb	r2, [r3, #0]
  
  ep->is_in = (0x80 & ep_addr) != 0;
 80028ca:	78fb      	ldrb	r3, [r7, #3]
 80028cc:	ea4f 13d3 	mov.w	r3, r3, lsr #7
 80028d0:	b2db      	uxtb	r3, r3
 80028d2:	461a      	mov	r2, r3
 80028d4:	697b      	ldr	r3, [r7, #20]
 80028d6:	705a      	strb	r2, [r3, #1]
  ep->maxpacket = ep_mps;
 80028d8:	883a      	ldrh	r2, [r7, #0]
 80028da:	697b      	ldr	r3, [r7, #20]
 80028dc:	60da      	str	r2, [r3, #12]
  ep->type = ep_type;
 80028de:	697b      	ldr	r3, [r7, #20]
 80028e0:	78ba      	ldrb	r2, [r7, #2]
 80028e2:	70da      	strb	r2, [r3, #3]
  
  __HAL_LOCK(hpcd); 
 80028e4:	687b      	ldr	r3, [r7, #4]
 80028e6:	f893 31e8 	ldrb.w	r3, [r3, #488]	; 0x1e8
 80028ea:	2b01      	cmp	r3, #1
 80028ec:	d102      	bne.n	80028f4 <HAL_PCD_EP_Open+0x8c>
 80028ee:	f04f 0302 	mov.w	r3, #2
 80028f2:	e3a3      	b.n	800303c <HAL_PCD_EP_Open+0x7d4>
 80028f4:	687b      	ldr	r3, [r7, #4]
 80028f6:	f04f 0201 	mov.w	r2, #1
 80028fa:	f883 21e8 	strb.w	r2, [r3, #488]	; 0x1e8

/* initialize Endpoint */
  switch (ep->type)
 80028fe:	697b      	ldr	r3, [r7, #20]
 8002900:	78db      	ldrb	r3, [r3, #3]
 8002902:	2b03      	cmp	r3, #3
 8002904:	d877      	bhi.n	80029f6 <HAL_PCD_EP_Open+0x18e>
 8002906:	a201      	add	r2, pc, #4	; (adr r2, 800290c <HAL_PCD_EP_Open+0xa4>)
 8002908:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800290c:	0800291d 	.word	0x0800291d
 8002910:	080029bf 	.word	0x080029bf
 8002914:	08002955 	.word	0x08002955
 8002918:	08002987 	.word	0x08002987
  {
  case PCD_EP_TYPE_CTRL:
    PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_CONTROL);
 800291c:	687b      	ldr	r3, [r7, #4]
 800291e:	681b      	ldr	r3, [r3, #0]
 8002920:	461a      	mov	r2, r3
 8002922:	697b      	ldr	r3, [r7, #20]
 8002924:	781b      	ldrb	r3, [r3, #0]
 8002926:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800292a:	18d2      	adds	r2, r2, r3
 800292c:	687b      	ldr	r3, [r7, #4]
 800292e:	681b      	ldr	r3, [r3, #0]
 8002930:	4619      	mov	r1, r3
 8002932:	697b      	ldr	r3, [r7, #20]
 8002934:	781b      	ldrb	r3, [r3, #0]
 8002936:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800293a:	18cb      	adds	r3, r1, r3
 800293c:	881b      	ldrh	r3, [r3, #0]
 800293e:	b29b      	uxth	r3, r3
 8002940:	f423 43ec 	bic.w	r3, r3, #30208	; 0x7600
 8002944:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002948:	b29b      	uxth	r3, r3
 800294a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800294e:	b29b      	uxth	r3, r3
 8002950:	8013      	strh	r3, [r2, #0]
    break;
 8002952:	e051      	b.n	80029f8 <HAL_PCD_EP_Open+0x190>
  case PCD_EP_TYPE_BULK:
    PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_BULK);
 8002954:	687b      	ldr	r3, [r7, #4]
 8002956:	681b      	ldr	r3, [r3, #0]
 8002958:	461a      	mov	r2, r3
 800295a:	697b      	ldr	r3, [r7, #20]
 800295c:	781b      	ldrb	r3, [r3, #0]
 800295e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002962:	18d2      	adds	r2, r2, r3
 8002964:	687b      	ldr	r3, [r7, #4]
 8002966:	681b      	ldr	r3, [r3, #0]
 8002968:	4619      	mov	r1, r3
 800296a:	697b      	ldr	r3, [r7, #20]
 800296c:	781b      	ldrb	r3, [r3, #0]
 800296e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002972:	18cb      	adds	r3, r1, r3
 8002974:	881b      	ldrh	r3, [r3, #0]
 8002976:	b29b      	uxth	r3, r3
 8002978:	f423 43ec 	bic.w	r3, r3, #30208	; 0x7600
 800297c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002980:	b29b      	uxth	r3, r3
 8002982:	8013      	strh	r3, [r2, #0]
    break;
 8002984:	e038      	b.n	80029f8 <HAL_PCD_EP_Open+0x190>
  case PCD_EP_TYPE_INTR:
    PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_INTERRUPT);
 8002986:	687b      	ldr	r3, [r7, #4]
 8002988:	681b      	ldr	r3, [r3, #0]
 800298a:	461a      	mov	r2, r3
 800298c:	697b      	ldr	r3, [r7, #20]
 800298e:	781b      	ldrb	r3, [r3, #0]
 8002990:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002994:	18d2      	adds	r2, r2, r3
 8002996:	687b      	ldr	r3, [r7, #4]
 8002998:	681b      	ldr	r3, [r3, #0]
 800299a:	4619      	mov	r1, r3
 800299c:	697b      	ldr	r3, [r7, #20]
 800299e:	781b      	ldrb	r3, [r3, #0]
 80029a0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80029a4:	18cb      	adds	r3, r1, r3
 80029a6:	881b      	ldrh	r3, [r3, #0]
 80029a8:	b29b      	uxth	r3, r3
 80029aa:	f423 43ec 	bic.w	r3, r3, #30208	; 0x7600
 80029ae:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80029b2:	b29b      	uxth	r3, r3
 80029b4:	f443 63c0 	orr.w	r3, r3, #1536	; 0x600
 80029b8:	b29b      	uxth	r3, r3
 80029ba:	8013      	strh	r3, [r2, #0]
    break;
 80029bc:	e01c      	b.n	80029f8 <HAL_PCD_EP_Open+0x190>
  case PCD_EP_TYPE_ISOC:
    PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_ISOCHRONOUS);
 80029be:	687b      	ldr	r3, [r7, #4]
 80029c0:	681b      	ldr	r3, [r3, #0]
 80029c2:	461a      	mov	r2, r3
 80029c4:	697b      	ldr	r3, [r7, #20]
 80029c6:	781b      	ldrb	r3, [r3, #0]
 80029c8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80029cc:	18d2      	adds	r2, r2, r3
 80029ce:	687b      	ldr	r3, [r7, #4]
 80029d0:	681b      	ldr	r3, [r3, #0]
 80029d2:	4619      	mov	r1, r3
 80029d4:	697b      	ldr	r3, [r7, #20]
 80029d6:	781b      	ldrb	r3, [r3, #0]
 80029d8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80029dc:	18cb      	adds	r3, r1, r3
 80029de:	881b      	ldrh	r3, [r3, #0]
 80029e0:	b29b      	uxth	r3, r3
 80029e2:	f423 43ec 	bic.w	r3, r3, #30208	; 0x7600
 80029e6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80029ea:	b29b      	uxth	r3, r3
 80029ec:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80029f0:	b29b      	uxth	r3, r3
 80029f2:	8013      	strh	r3, [r2, #0]
    break;
 80029f4:	e000      	b.n	80029f8 <HAL_PCD_EP_Open+0x190>
  default:
      break;
 80029f6:	bf00      	nop
  } 
  
  PCD_SET_EP_ADDRESS(hpcd->Instance, ep->num, ep->num);
 80029f8:	687b      	ldr	r3, [r7, #4]
 80029fa:	681b      	ldr	r3, [r3, #0]
 80029fc:	461a      	mov	r2, r3
 80029fe:	697b      	ldr	r3, [r7, #20]
 8002a00:	781b      	ldrb	r3, [r3, #0]
 8002a02:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002a06:	18d2      	adds	r2, r2, r3
 8002a08:	687b      	ldr	r3, [r7, #4]
 8002a0a:	681b      	ldr	r3, [r3, #0]
 8002a0c:	4619      	mov	r1, r3
 8002a0e:	697b      	ldr	r3, [r7, #20]
 8002a10:	781b      	ldrb	r3, [r3, #0]
 8002a12:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002a16:	18cb      	adds	r3, r1, r3
 8002a18:	881b      	ldrh	r3, [r3, #0]
 8002a1a:	b299      	uxth	r1, r3
 8002a1c:	f640 730f 	movw	r3, #3855	; 0xf0f
 8002a20:	400b      	ands	r3, r1
 8002a22:	b299      	uxth	r1, r3
 8002a24:	697b      	ldr	r3, [r7, #20]
 8002a26:	781b      	ldrb	r3, [r3, #0]
 8002a28:	430b      	orrs	r3, r1
 8002a2a:	b299      	uxth	r1, r3
 8002a2c:	f248 0380 	movw	r3, #32896	; 0x8080
 8002a30:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8002a34:	430b      	orrs	r3, r1
 8002a36:	b29b      	uxth	r3, r3
 8002a38:	8013      	strh	r3, [r2, #0]
  
  if (ep->doublebuffer == 0) 
 8002a3a:	697b      	ldr	r3, [r7, #20]
 8002a3c:	7a9b      	ldrb	r3, [r3, #10]
 8002a3e:	2b00      	cmp	r3, #0
 8002a40:	f040 8129 	bne.w	8002c96 <HAL_PCD_EP_Open+0x42e>
  {
    if (ep->is_in)
 8002a44:	697b      	ldr	r3, [r7, #20]
 8002a46:	785b      	ldrb	r3, [r3, #1]
 8002a48:	2b00      	cmp	r3, #0
 8002a4a:	d069      	beq.n	8002b20 <HAL_PCD_EP_Open+0x2b8>
    {
      /*Set the endpoint Transmit buffer address */
      PCD_SET_EP_TX_ADDRESS(hpcd->Instance, ep->num, ep->pmaadress);
 8002a4c:	687b      	ldr	r3, [r7, #4]
 8002a4e:	681b      	ldr	r3, [r3, #0]
 8002a50:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8002a54:	b29b      	uxth	r3, r3
 8002a56:	461a      	mov	r2, r3
 8002a58:	697b      	ldr	r3, [r7, #20]
 8002a5a:	781b      	ldrb	r3, [r3, #0]
 8002a5c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8002a60:	18d3      	adds	r3, r2, r3
 8002a62:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8002a66:	461a      	mov	r2, r3
 8002a68:	687b      	ldr	r3, [r7, #4]
 8002a6a:	681b      	ldr	r3, [r3, #0]
 8002a6c:	18d3      	adds	r3, r2, r3
 8002a6e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8002a72:	697a      	ldr	r2, [r7, #20]
 8002a74:	8892      	ldrh	r2, [r2, #4]
 8002a76:	f022 0201 	bic.w	r2, r2, #1
 8002a7a:	601a      	str	r2, [r3, #0]
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num);
 8002a7c:	687b      	ldr	r3, [r7, #4]
 8002a7e:	681b      	ldr	r3, [r3, #0]
 8002a80:	461a      	mov	r2, r3
 8002a82:	697b      	ldr	r3, [r7, #20]
 8002a84:	781b      	ldrb	r3, [r3, #0]
 8002a86:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002a8a:	18d3      	adds	r3, r2, r3
 8002a8c:	881b      	ldrh	r3, [r3, #0]
 8002a8e:	b29b      	uxth	r3, r3
 8002a90:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8002a94:	2b00      	cmp	r3, #0
 8002a96:	bf0c      	ite	eq
 8002a98:	2300      	moveq	r3, #0
 8002a9a:	2301      	movne	r3, #1
 8002a9c:	b2db      	uxtb	r3, r3
 8002a9e:	2b00      	cmp	r3, #0
 8002aa0:	d01c      	beq.n	8002adc <HAL_PCD_EP_Open+0x274>
 8002aa2:	687b      	ldr	r3, [r7, #4]
 8002aa4:	681b      	ldr	r3, [r3, #0]
 8002aa6:	461a      	mov	r2, r3
 8002aa8:	697b      	ldr	r3, [r7, #20]
 8002aaa:	781b      	ldrb	r3, [r3, #0]
 8002aac:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002ab0:	18d2      	adds	r2, r2, r3
 8002ab2:	687b      	ldr	r3, [r7, #4]
 8002ab4:	681b      	ldr	r3, [r3, #0]
 8002ab6:	4619      	mov	r1, r3
 8002ab8:	697b      	ldr	r3, [r7, #20]
 8002aba:	781b      	ldrb	r3, [r3, #0]
 8002abc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002ac0:	18cb      	adds	r3, r1, r3
 8002ac2:	881b      	ldrh	r3, [r3, #0]
 8002ac4:	b299      	uxth	r1, r3
 8002ac6:	f640 730f 	movw	r3, #3855	; 0xf0f
 8002aca:	400b      	ands	r3, r1
 8002acc:	b299      	uxth	r1, r3
 8002ace:	f248 03c0 	movw	r3, #32960	; 0x80c0
 8002ad2:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8002ad6:	430b      	orrs	r3, r1
 8002ad8:	b29b      	uxth	r3, r3
 8002ada:	8013      	strh	r3, [r2, #0]
      /* Configure NAK status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_NAK); 
 8002adc:	687b      	ldr	r3, [r7, #4]
 8002ade:	681b      	ldr	r3, [r3, #0]
 8002ae0:	461a      	mov	r2, r3
 8002ae2:	697b      	ldr	r3, [r7, #20]
 8002ae4:	781b      	ldrb	r3, [r3, #0]
 8002ae6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002aea:	18d3      	adds	r3, r2, r3
 8002aec:	881b      	ldrh	r3, [r3, #0]
 8002aee:	b29b      	uxth	r3, r3
 8002af0:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8002af4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8002af8:	b29c      	uxth	r4, r3
 8002afa:	f084 0320 	eor.w	r3, r4, #32
 8002afe:	b29c      	uxth	r4, r3
 8002b00:	687b      	ldr	r3, [r7, #4]
 8002b02:	681b      	ldr	r3, [r3, #0]
 8002b04:	461a      	mov	r2, r3
 8002b06:	697b      	ldr	r3, [r7, #20]
 8002b08:	781b      	ldrb	r3, [r3, #0]
 8002b0a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002b0e:	18d2      	adds	r2, r2, r3
 8002b10:	f248 0380 	movw	r3, #32896	; 0x8080
 8002b14:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8002b18:	4323      	orrs	r3, r4
 8002b1a:	b29b      	uxth	r3, r3
 8002b1c:	8013      	strh	r3, [r2, #0]
 8002b1e:	e287      	b.n	8003030 <HAL_PCD_EP_Open+0x7c8>
    }
    else
    {
      /*Set the endpoint Receive buffer address */
      PCD_SET_EP_RX_ADDRESS(hpcd->Instance, ep->num, ep->pmaadress);
 8002b20:	687b      	ldr	r3, [r7, #4]
 8002b22:	681b      	ldr	r3, [r3, #0]
 8002b24:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8002b28:	b29b      	uxth	r3, r3
 8002b2a:	461a      	mov	r2, r3
 8002b2c:	697b      	ldr	r3, [r7, #20]
 8002b2e:	781b      	ldrb	r3, [r3, #0]
 8002b30:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8002b34:	18d3      	adds	r3, r2, r3
 8002b36:	f103 0304 	add.w	r3, r3, #4
 8002b3a:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8002b3e:	461a      	mov	r2, r3
 8002b40:	687b      	ldr	r3, [r7, #4]
 8002b42:	681b      	ldr	r3, [r3, #0]
 8002b44:	18d3      	adds	r3, r2, r3
 8002b46:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8002b4a:	697a      	ldr	r2, [r7, #20]
 8002b4c:	8892      	ldrh	r2, [r2, #4]
 8002b4e:	f022 0201 	bic.w	r2, r2, #1
 8002b52:	601a      	str	r2, [r3, #0]
      /*Set the endpoint Receive buffer counter*/
      PCD_SET_EP_RX_CNT(hpcd->Instance, ep->num, ep->maxpacket);
 8002b54:	687b      	ldr	r3, [r7, #4]
 8002b56:	681b      	ldr	r3, [r3, #0]
 8002b58:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8002b5c:	b29b      	uxth	r3, r3
 8002b5e:	461a      	mov	r2, r3
 8002b60:	697b      	ldr	r3, [r7, #20]
 8002b62:	781b      	ldrb	r3, [r3, #0]
 8002b64:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8002b68:	18d3      	adds	r3, r2, r3
 8002b6a:	f103 0306 	add.w	r3, r3, #6
 8002b6e:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8002b72:	461a      	mov	r2, r3
 8002b74:	687b      	ldr	r3, [r7, #4]
 8002b76:	681b      	ldr	r3, [r3, #0]
 8002b78:	18d3      	adds	r3, r2, r3
 8002b7a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8002b7e:	60fb      	str	r3, [r7, #12]
 8002b80:	697b      	ldr	r3, [r7, #20]
 8002b82:	68db      	ldr	r3, [r3, #12]
 8002b84:	2b3e      	cmp	r3, #62	; 0x3e
 8002b86:	d91b      	bls.n	8002bc0 <HAL_PCD_EP_Open+0x358>
 8002b88:	697b      	ldr	r3, [r7, #20]
 8002b8a:	68db      	ldr	r3, [r3, #12]
 8002b8c:	ea4f 1353 	mov.w	r3, r3, lsr #5
 8002b90:	827b      	strh	r3, [r7, #18]
 8002b92:	697b      	ldr	r3, [r7, #20]
 8002b94:	68db      	ldr	r3, [r3, #12]
 8002b96:	f003 031f 	and.w	r3, r3, #31
 8002b9a:	2b00      	cmp	r3, #0
 8002b9c:	d103      	bne.n	8002ba6 <HAL_PCD_EP_Open+0x33e>
 8002b9e:	8a7b      	ldrh	r3, [r7, #18]
 8002ba0:	f103 33ff 	add.w	r3, r3, #4294967295
 8002ba4:	827b      	strh	r3, [r7, #18]
 8002ba6:	8a7b      	ldrh	r3, [r7, #18]
 8002ba8:	ea4f 2383 	mov.w	r3, r3, lsl #10
 8002bac:	b29b      	uxth	r3, r3
 8002bae:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8002bb2:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8002bb6:	b29b      	uxth	r3, r3
 8002bb8:	461a      	mov	r2, r3
 8002bba:	68fb      	ldr	r3, [r7, #12]
 8002bbc:	601a      	str	r2, [r3, #0]
 8002bbe:	e015      	b.n	8002bec <HAL_PCD_EP_Open+0x384>
 8002bc0:	697b      	ldr	r3, [r7, #20]
 8002bc2:	68db      	ldr	r3, [r3, #12]
 8002bc4:	ea4f 0353 	mov.w	r3, r3, lsr #1
 8002bc8:	827b      	strh	r3, [r7, #18]
 8002bca:	697b      	ldr	r3, [r7, #20]
 8002bcc:	68db      	ldr	r3, [r3, #12]
 8002bce:	f003 0301 	and.w	r3, r3, #1
 8002bd2:	2b00      	cmp	r3, #0
 8002bd4:	d003      	beq.n	8002bde <HAL_PCD_EP_Open+0x376>
 8002bd6:	8a7b      	ldrh	r3, [r7, #18]
 8002bd8:	f103 0301 	add.w	r3, r3, #1
 8002bdc:	827b      	strh	r3, [r7, #18]
 8002bde:	8a7b      	ldrh	r3, [r7, #18]
 8002be0:	ea4f 2383 	mov.w	r3, r3, lsl #10
 8002be4:	b29b      	uxth	r3, r3
 8002be6:	461a      	mov	r2, r3
 8002be8:	68fb      	ldr	r3, [r7, #12]
 8002bea:	601a      	str	r2, [r3, #0]
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num);
 8002bec:	687b      	ldr	r3, [r7, #4]
 8002bee:	681b      	ldr	r3, [r3, #0]
 8002bf0:	461a      	mov	r2, r3
 8002bf2:	697b      	ldr	r3, [r7, #20]
 8002bf4:	781b      	ldrb	r3, [r3, #0]
 8002bf6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002bfa:	18d3      	adds	r3, r2, r3
 8002bfc:	881b      	ldrh	r3, [r3, #0]
 8002bfe:	b29b      	uxth	r3, r3
 8002c00:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8002c04:	2b00      	cmp	r3, #0
 8002c06:	bf0c      	ite	eq
 8002c08:	2300      	moveq	r3, #0
 8002c0a:	2301      	movne	r3, #1
 8002c0c:	b2db      	uxtb	r3, r3
 8002c0e:	2b00      	cmp	r3, #0
 8002c10:	d01c      	beq.n	8002c4c <HAL_PCD_EP_Open+0x3e4>
 8002c12:	687b      	ldr	r3, [r7, #4]
 8002c14:	681b      	ldr	r3, [r3, #0]
 8002c16:	461a      	mov	r2, r3
 8002c18:	697b      	ldr	r3, [r7, #20]
 8002c1a:	781b      	ldrb	r3, [r3, #0]
 8002c1c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002c20:	18d2      	adds	r2, r2, r3
 8002c22:	687b      	ldr	r3, [r7, #4]
 8002c24:	681b      	ldr	r3, [r3, #0]
 8002c26:	4619      	mov	r1, r3
 8002c28:	697b      	ldr	r3, [r7, #20]
 8002c2a:	781b      	ldrb	r3, [r3, #0]
 8002c2c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002c30:	18cb      	adds	r3, r1, r3
 8002c32:	881b      	ldrh	r3, [r3, #0]
 8002c34:	b299      	uxth	r1, r3
 8002c36:	f640 730f 	movw	r3, #3855	; 0xf0f
 8002c3a:	400b      	ands	r3, r1
 8002c3c:	b299      	uxth	r1, r3
 8002c3e:	f24c 0380 	movw	r3, #49280	; 0xc080
 8002c42:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8002c46:	430b      	orrs	r3, r1
 8002c48:	b29b      	uxth	r3, r3
 8002c4a:	8013      	strh	r3, [r2, #0]
      /* Configure VALID status for the Endpoint*/
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID);
 8002c4c:	687b      	ldr	r3, [r7, #4]
 8002c4e:	681b      	ldr	r3, [r3, #0]
 8002c50:	461a      	mov	r2, r3
 8002c52:	697b      	ldr	r3, [r7, #20]
 8002c54:	781b      	ldrb	r3, [r3, #0]
 8002c56:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002c5a:	18d3      	adds	r3, r2, r3
 8002c5c:	881b      	ldrh	r3, [r3, #0]
 8002c5e:	b29b      	uxth	r3, r3
 8002c60:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8002c64:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002c68:	b29c      	uxth	r4, r3
 8002c6a:	f484 5380 	eor.w	r3, r4, #4096	; 0x1000
 8002c6e:	b29c      	uxth	r4, r3
 8002c70:	f484 5300 	eor.w	r3, r4, #8192	; 0x2000
 8002c74:	b29c      	uxth	r4, r3
 8002c76:	687b      	ldr	r3, [r7, #4]
 8002c78:	681b      	ldr	r3, [r3, #0]
 8002c7a:	461a      	mov	r2, r3
 8002c7c:	697b      	ldr	r3, [r7, #20]
 8002c7e:	781b      	ldrb	r3, [r3, #0]
 8002c80:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002c84:	18d2      	adds	r2, r2, r3
 8002c86:	f248 0380 	movw	r3, #32896	; 0x8080
 8002c8a:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8002c8e:	4323      	orrs	r3, r4
 8002c90:	b29b      	uxth	r3, r3
 8002c92:	8013      	strh	r3, [r2, #0]
 8002c94:	e1cc      	b.n	8003030 <HAL_PCD_EP_Open+0x7c8>
  }
  /*Double Buffer*/
  else
  {
    /*Set the endpoint as double buffered*/
    PCD_SET_EP_DBUF(hpcd->Instance, ep->num);
 8002c96:	687b      	ldr	r3, [r7, #4]
 8002c98:	681b      	ldr	r3, [r3, #0]
 8002c9a:	461a      	mov	r2, r3
 8002c9c:	697b      	ldr	r3, [r7, #20]
 8002c9e:	781b      	ldrb	r3, [r3, #0]
 8002ca0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002ca4:	18d2      	adds	r2, r2, r3
 8002ca6:	687b      	ldr	r3, [r7, #4]
 8002ca8:	681b      	ldr	r3, [r3, #0]
 8002caa:	4619      	mov	r1, r3
 8002cac:	697b      	ldr	r3, [r7, #20]
 8002cae:	781b      	ldrb	r3, [r3, #0]
 8002cb0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002cb4:	18cb      	adds	r3, r1, r3
 8002cb6:	881b      	ldrh	r3, [r3, #0]
 8002cb8:	b299      	uxth	r1, r3
 8002cba:	f640 630f 	movw	r3, #3599	; 0xe0f
 8002cbe:	400b      	ands	r3, r1
 8002cc0:	b299      	uxth	r1, r3
 8002cc2:	f248 1380 	movw	r3, #33152	; 0x8180
 8002cc6:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8002cca:	430b      	orrs	r3, r1
 8002ccc:	b29b      	uxth	r3, r3
 8002cce:	8013      	strh	r3, [r2, #0]
    /*Set buffer address for double buffered mode*/
    PCD_SET_EP_DBUF_ADDR(hpcd->Instance, ep->num,ep->pmaaddr0, ep->pmaaddr1);
 8002cd0:	687b      	ldr	r3, [r7, #4]
 8002cd2:	681b      	ldr	r3, [r3, #0]
 8002cd4:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8002cd8:	b29b      	uxth	r3, r3
 8002cda:	461a      	mov	r2, r3
 8002cdc:	697b      	ldr	r3, [r7, #20]
 8002cde:	781b      	ldrb	r3, [r3, #0]
 8002ce0:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8002ce4:	18d3      	adds	r3, r2, r3
 8002ce6:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8002cea:	461a      	mov	r2, r3
 8002cec:	687b      	ldr	r3, [r7, #4]
 8002cee:	681b      	ldr	r3, [r3, #0]
 8002cf0:	18d3      	adds	r3, r2, r3
 8002cf2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8002cf6:	697a      	ldr	r2, [r7, #20]
 8002cf8:	88d2      	ldrh	r2, [r2, #6]
 8002cfa:	f022 0201 	bic.w	r2, r2, #1
 8002cfe:	601a      	str	r2, [r3, #0]
 8002d00:	687b      	ldr	r3, [r7, #4]
 8002d02:	681b      	ldr	r3, [r3, #0]
 8002d04:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8002d08:	b29b      	uxth	r3, r3
 8002d0a:	461a      	mov	r2, r3
 8002d0c:	697b      	ldr	r3, [r7, #20]
 8002d0e:	781b      	ldrb	r3, [r3, #0]
 8002d10:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8002d14:	18d3      	adds	r3, r2, r3
 8002d16:	f103 0304 	add.w	r3, r3, #4
 8002d1a:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8002d1e:	461a      	mov	r2, r3
 8002d20:	687b      	ldr	r3, [r7, #4]
 8002d22:	681b      	ldr	r3, [r3, #0]
 8002d24:	18d3      	adds	r3, r2, r3
 8002d26:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8002d2a:	697a      	ldr	r2, [r7, #20]
 8002d2c:	8912      	ldrh	r2, [r2, #8]
 8002d2e:	f022 0201 	bic.w	r2, r2, #1
 8002d32:	601a      	str	r2, [r3, #0]
    
    if (ep->is_in==0)
 8002d34:	697b      	ldr	r3, [r7, #20]
 8002d36:	785b      	ldrb	r3, [r3, #1]
 8002d38:	2b00      	cmp	r3, #0
 8002d3a:	f040 80c0 	bne.w	8002ebe <HAL_PCD_EP_Open+0x656>
    {
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num);
 8002d3e:	687b      	ldr	r3, [r7, #4]
 8002d40:	681b      	ldr	r3, [r3, #0]
 8002d42:	461a      	mov	r2, r3
 8002d44:	697b      	ldr	r3, [r7, #20]
 8002d46:	781b      	ldrb	r3, [r3, #0]
 8002d48:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002d4c:	18d3      	adds	r3, r2, r3
 8002d4e:	881b      	ldrh	r3, [r3, #0]
 8002d50:	b29b      	uxth	r3, r3
 8002d52:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8002d56:	2b00      	cmp	r3, #0
 8002d58:	bf0c      	ite	eq
 8002d5a:	2300      	moveq	r3, #0
 8002d5c:	2301      	movne	r3, #1
 8002d5e:	b2db      	uxtb	r3, r3
 8002d60:	2b00      	cmp	r3, #0
 8002d62:	d01c      	beq.n	8002d9e <HAL_PCD_EP_Open+0x536>
 8002d64:	687b      	ldr	r3, [r7, #4]
 8002d66:	681b      	ldr	r3, [r3, #0]
 8002d68:	461a      	mov	r2, r3
 8002d6a:	697b      	ldr	r3, [r7, #20]
 8002d6c:	781b      	ldrb	r3, [r3, #0]
 8002d6e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002d72:	18d2      	adds	r2, r2, r3
 8002d74:	687b      	ldr	r3, [r7, #4]
 8002d76:	681b      	ldr	r3, [r3, #0]
 8002d78:	4619      	mov	r1, r3
 8002d7a:	697b      	ldr	r3, [r7, #20]
 8002d7c:	781b      	ldrb	r3, [r3, #0]
 8002d7e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002d82:	18cb      	adds	r3, r1, r3
 8002d84:	881b      	ldrh	r3, [r3, #0]
 8002d86:	b299      	uxth	r1, r3
 8002d88:	f640 730f 	movw	r3, #3855	; 0xf0f
 8002d8c:	400b      	ands	r3, r1
 8002d8e:	b299      	uxth	r1, r3
 8002d90:	f24c 0380 	movw	r3, #49280	; 0xc080
 8002d94:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8002d98:	430b      	orrs	r3, r1
 8002d9a:	b29b      	uxth	r3, r3
 8002d9c:	8013      	strh	r3, [r2, #0]
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num);
 8002d9e:	687b      	ldr	r3, [r7, #4]
 8002da0:	681b      	ldr	r3, [r3, #0]
 8002da2:	461a      	mov	r2, r3
 8002da4:	697b      	ldr	r3, [r7, #20]
 8002da6:	781b      	ldrb	r3, [r3, #0]
 8002da8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002dac:	18d3      	adds	r3, r2, r3
 8002dae:	881b      	ldrh	r3, [r3, #0]
 8002db0:	b29b      	uxth	r3, r3
 8002db2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8002db6:	2b00      	cmp	r3, #0
 8002db8:	bf0c      	ite	eq
 8002dba:	2300      	moveq	r3, #0
 8002dbc:	2301      	movne	r3, #1
 8002dbe:	b2db      	uxtb	r3, r3
 8002dc0:	2b00      	cmp	r3, #0
 8002dc2:	d01c      	beq.n	8002dfe <HAL_PCD_EP_Open+0x596>
 8002dc4:	687b      	ldr	r3, [r7, #4]
 8002dc6:	681b      	ldr	r3, [r3, #0]
 8002dc8:	461a      	mov	r2, r3
 8002dca:	697b      	ldr	r3, [r7, #20]
 8002dcc:	781b      	ldrb	r3, [r3, #0]
 8002dce:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002dd2:	18d2      	adds	r2, r2, r3
 8002dd4:	687b      	ldr	r3, [r7, #4]
 8002dd6:	681b      	ldr	r3, [r3, #0]
 8002dd8:	4619      	mov	r1, r3
 8002dda:	697b      	ldr	r3, [r7, #20]
 8002ddc:	781b      	ldrb	r3, [r3, #0]
 8002dde:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002de2:	18cb      	adds	r3, r1, r3
 8002de4:	881b      	ldrh	r3, [r3, #0]
 8002de6:	b299      	uxth	r1, r3
 8002de8:	f640 730f 	movw	r3, #3855	; 0xf0f
 8002dec:	400b      	ands	r3, r1
 8002dee:	b299      	uxth	r1, r3
 8002df0:	f248 03c0 	movw	r3, #32960	; 0x80c0
 8002df4:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8002df8:	430b      	orrs	r3, r1
 8002dfa:	b29b      	uxth	r3, r3
 8002dfc:	8013      	strh	r3, [r2, #0]
      
      /* Reset value of the data toggle bits for the endpoint out*/
      PCD_TX_DTOG(hpcd->Instance, ep->num);
 8002dfe:	687b      	ldr	r3, [r7, #4]
 8002e00:	681b      	ldr	r3, [r3, #0]
 8002e02:	461a      	mov	r2, r3
 8002e04:	697b      	ldr	r3, [r7, #20]
 8002e06:	781b      	ldrb	r3, [r3, #0]
 8002e08:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002e0c:	18d2      	adds	r2, r2, r3
 8002e0e:	687b      	ldr	r3, [r7, #4]
 8002e10:	681b      	ldr	r3, [r3, #0]
 8002e12:	4619      	mov	r1, r3
 8002e14:	697b      	ldr	r3, [r7, #20]
 8002e16:	781b      	ldrb	r3, [r3, #0]
 8002e18:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002e1c:	18cb      	adds	r3, r1, r3
 8002e1e:	881b      	ldrh	r3, [r3, #0]
 8002e20:	b299      	uxth	r1, r3
 8002e22:	f640 730f 	movw	r3, #3855	; 0xf0f
 8002e26:	400b      	ands	r3, r1
 8002e28:	b299      	uxth	r1, r3
 8002e2a:	f248 03c0 	movw	r3, #32960	; 0x80c0
 8002e2e:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8002e32:	430b      	orrs	r3, r1
 8002e34:	b29b      	uxth	r3, r3
 8002e36:	8013      	strh	r3, [r2, #0]
      
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID);
 8002e38:	687b      	ldr	r3, [r7, #4]
 8002e3a:	681b      	ldr	r3, [r3, #0]
 8002e3c:	461a      	mov	r2, r3
 8002e3e:	697b      	ldr	r3, [r7, #20]
 8002e40:	781b      	ldrb	r3, [r3, #0]
 8002e42:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002e46:	18d3      	adds	r3, r2, r3
 8002e48:	881b      	ldrh	r3, [r3, #0]
 8002e4a:	b29b      	uxth	r3, r3
 8002e4c:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8002e50:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002e54:	b29c      	uxth	r4, r3
 8002e56:	f484 5380 	eor.w	r3, r4, #4096	; 0x1000
 8002e5a:	b29c      	uxth	r4, r3
 8002e5c:	f484 5300 	eor.w	r3, r4, #8192	; 0x2000
 8002e60:	b29c      	uxth	r4, r3
 8002e62:	687b      	ldr	r3, [r7, #4]
 8002e64:	681b      	ldr	r3, [r3, #0]
 8002e66:	461a      	mov	r2, r3
 8002e68:	697b      	ldr	r3, [r7, #20]
 8002e6a:	781b      	ldrb	r3, [r3, #0]
 8002e6c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002e70:	18d2      	adds	r2, r2, r3
 8002e72:	f248 0380 	movw	r3, #32896	; 0x8080
 8002e76:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8002e7a:	4323      	orrs	r3, r4
 8002e7c:	b29b      	uxth	r3, r3
 8002e7e:	8013      	strh	r3, [r2, #0]
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS);
 8002e80:	687b      	ldr	r3, [r7, #4]
 8002e82:	681b      	ldr	r3, [r3, #0]
 8002e84:	461a      	mov	r2, r3
 8002e86:	697b      	ldr	r3, [r7, #20]
 8002e88:	781b      	ldrb	r3, [r3, #0]
 8002e8a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002e8e:	18d3      	adds	r3, r2, r3
 8002e90:	881b      	ldrh	r3, [r3, #0]
 8002e92:	b29b      	uxth	r3, r3
 8002e94:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8002e98:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8002e9c:	b29c      	uxth	r4, r3
 8002e9e:	687b      	ldr	r3, [r7, #4]
 8002ea0:	681b      	ldr	r3, [r3, #0]
 8002ea2:	461a      	mov	r2, r3
 8002ea4:	697b      	ldr	r3, [r7, #20]
 8002ea6:	781b      	ldrb	r3, [r3, #0]
 8002ea8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002eac:	18d2      	adds	r2, r2, r3
 8002eae:	f248 0380 	movw	r3, #32896	; 0x8080
 8002eb2:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8002eb6:	4323      	orrs	r3, r4
 8002eb8:	b29b      	uxth	r3, r3
 8002eba:	8013      	strh	r3, [r2, #0]
 8002ebc:	e0b8      	b.n	8003030 <HAL_PCD_EP_Open+0x7c8>
    }
    else
    {
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num);
 8002ebe:	687b      	ldr	r3, [r7, #4]
 8002ec0:	681b      	ldr	r3, [r3, #0]
 8002ec2:	461a      	mov	r2, r3
 8002ec4:	697b      	ldr	r3, [r7, #20]
 8002ec6:	781b      	ldrb	r3, [r3, #0]
 8002ec8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002ecc:	18d3      	adds	r3, r2, r3
 8002ece:	881b      	ldrh	r3, [r3, #0]
 8002ed0:	b29b      	uxth	r3, r3
 8002ed2:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8002ed6:	2b00      	cmp	r3, #0
 8002ed8:	bf0c      	ite	eq
 8002eda:	2300      	moveq	r3, #0
 8002edc:	2301      	movne	r3, #1
 8002ede:	b2db      	uxtb	r3, r3
 8002ee0:	2b00      	cmp	r3, #0
 8002ee2:	d01c      	beq.n	8002f1e <HAL_PCD_EP_Open+0x6b6>
 8002ee4:	687b      	ldr	r3, [r7, #4]
 8002ee6:	681b      	ldr	r3, [r3, #0]
 8002ee8:	461a      	mov	r2, r3
 8002eea:	697b      	ldr	r3, [r7, #20]
 8002eec:	781b      	ldrb	r3, [r3, #0]
 8002eee:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002ef2:	18d2      	adds	r2, r2, r3
 8002ef4:	687b      	ldr	r3, [r7, #4]
 8002ef6:	681b      	ldr	r3, [r3, #0]
 8002ef8:	4619      	mov	r1, r3
 8002efa:	697b      	ldr	r3, [r7, #20]
 8002efc:	781b      	ldrb	r3, [r3, #0]
 8002efe:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002f02:	18cb      	adds	r3, r1, r3
 8002f04:	881b      	ldrh	r3, [r3, #0]
 8002f06:	b299      	uxth	r1, r3
 8002f08:	f640 730f 	movw	r3, #3855	; 0xf0f
 8002f0c:	400b      	ands	r3, r1
 8002f0e:	b299      	uxth	r1, r3
 8002f10:	f24c 0380 	movw	r3, #49280	; 0xc080
 8002f14:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8002f18:	430b      	orrs	r3, r1
 8002f1a:	b29b      	uxth	r3, r3
 8002f1c:	8013      	strh	r3, [r2, #0]
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num);
 8002f1e:	687b      	ldr	r3, [r7, #4]
 8002f20:	681b      	ldr	r3, [r3, #0]
 8002f22:	461a      	mov	r2, r3
 8002f24:	697b      	ldr	r3, [r7, #20]
 8002f26:	781b      	ldrb	r3, [r3, #0]
 8002f28:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002f2c:	18d3      	adds	r3, r2, r3
 8002f2e:	881b      	ldrh	r3, [r3, #0]
 8002f30:	b29b      	uxth	r3, r3
 8002f32:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8002f36:	2b00      	cmp	r3, #0
 8002f38:	bf0c      	ite	eq
 8002f3a:	2300      	moveq	r3, #0
 8002f3c:	2301      	movne	r3, #1
 8002f3e:	b2db      	uxtb	r3, r3
 8002f40:	2b00      	cmp	r3, #0
 8002f42:	d01c      	beq.n	8002f7e <HAL_PCD_EP_Open+0x716>
 8002f44:	687b      	ldr	r3, [r7, #4]
 8002f46:	681b      	ldr	r3, [r3, #0]
 8002f48:	461a      	mov	r2, r3
 8002f4a:	697b      	ldr	r3, [r7, #20]
 8002f4c:	781b      	ldrb	r3, [r3, #0]
 8002f4e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002f52:	18d2      	adds	r2, r2, r3
 8002f54:	687b      	ldr	r3, [r7, #4]
 8002f56:	681b      	ldr	r3, [r3, #0]
 8002f58:	4619      	mov	r1, r3
 8002f5a:	697b      	ldr	r3, [r7, #20]
 8002f5c:	781b      	ldrb	r3, [r3, #0]
 8002f5e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002f62:	18cb      	adds	r3, r1, r3
 8002f64:	881b      	ldrh	r3, [r3, #0]
 8002f66:	b299      	uxth	r1, r3
 8002f68:	f640 730f 	movw	r3, #3855	; 0xf0f
 8002f6c:	400b      	ands	r3, r1
 8002f6e:	b299      	uxth	r1, r3
 8002f70:	f248 03c0 	movw	r3, #32960	; 0x80c0
 8002f74:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8002f78:	430b      	orrs	r3, r1
 8002f7a:	b29b      	uxth	r3, r3
 8002f7c:	8013      	strh	r3, [r2, #0]
      PCD_RX_DTOG(hpcd->Instance, ep->num);
 8002f7e:	687b      	ldr	r3, [r7, #4]
 8002f80:	681b      	ldr	r3, [r3, #0]
 8002f82:	461a      	mov	r2, r3
 8002f84:	697b      	ldr	r3, [r7, #20]
 8002f86:	781b      	ldrb	r3, [r3, #0]
 8002f88:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002f8c:	18d2      	adds	r2, r2, r3
 8002f8e:	687b      	ldr	r3, [r7, #4]
 8002f90:	681b      	ldr	r3, [r3, #0]
 8002f92:	4619      	mov	r1, r3
 8002f94:	697b      	ldr	r3, [r7, #20]
 8002f96:	781b      	ldrb	r3, [r3, #0]
 8002f98:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002f9c:	18cb      	adds	r3, r1, r3
 8002f9e:	881b      	ldrh	r3, [r3, #0]
 8002fa0:	b299      	uxth	r1, r3
 8002fa2:	f640 730f 	movw	r3, #3855	; 0xf0f
 8002fa6:	400b      	ands	r3, r1
 8002fa8:	b299      	uxth	r1, r3
 8002faa:	f24c 0380 	movw	r3, #49280	; 0xc080
 8002fae:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8002fb2:	430b      	orrs	r3, r1
 8002fb4:	b29b      	uxth	r3, r3
 8002fb6:	8013      	strh	r3, [r2, #0]
      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS);
 8002fb8:	687b      	ldr	r3, [r7, #4]
 8002fba:	681b      	ldr	r3, [r3, #0]
 8002fbc:	461a      	mov	r2, r3
 8002fbe:	697b      	ldr	r3, [r7, #20]
 8002fc0:	781b      	ldrb	r3, [r3, #0]
 8002fc2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002fc6:	18d3      	adds	r3, r2, r3
 8002fc8:	881b      	ldrh	r3, [r3, #0]
 8002fca:	b29b      	uxth	r3, r3
 8002fcc:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8002fd0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8002fd4:	b29c      	uxth	r4, r3
 8002fd6:	687b      	ldr	r3, [r7, #4]
 8002fd8:	681b      	ldr	r3, [r3, #0]
 8002fda:	461a      	mov	r2, r3
 8002fdc:	697b      	ldr	r3, [r7, #20]
 8002fde:	781b      	ldrb	r3, [r3, #0]
 8002fe0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002fe4:	18d2      	adds	r2, r2, r3
 8002fe6:	f248 0380 	movw	r3, #32896	; 0x8080
 8002fea:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8002fee:	4323      	orrs	r3, r4
 8002ff0:	b29b      	uxth	r3, r3
 8002ff2:	8013      	strh	r3, [r2, #0]
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS);
 8002ff4:	687b      	ldr	r3, [r7, #4]
 8002ff6:	681b      	ldr	r3, [r3, #0]
 8002ff8:	461a      	mov	r2, r3
 8002ffa:	697b      	ldr	r3, [r7, #20]
 8002ffc:	781b      	ldrb	r3, [r3, #0]
 8002ffe:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003002:	18d3      	adds	r3, r2, r3
 8003004:	881b      	ldrh	r3, [r3, #0]
 8003006:	b29b      	uxth	r3, r3
 8003008:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800300c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003010:	b29c      	uxth	r4, r3
 8003012:	687b      	ldr	r3, [r7, #4]
 8003014:	681b      	ldr	r3, [r3, #0]
 8003016:	461a      	mov	r2, r3
 8003018:	697b      	ldr	r3, [r7, #20]
 800301a:	781b      	ldrb	r3, [r3, #0]
 800301c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003020:	18d2      	adds	r2, r2, r3
 8003022:	f248 0380 	movw	r3, #32896	; 0x8080
 8003026:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 800302a:	4323      	orrs	r3, r4
 800302c:	b29b      	uxth	r3, r3
 800302e:	8013      	strh	r3, [r2, #0]
    }
  } 
  
  __HAL_UNLOCK(hpcd);   
 8003030:	687b      	ldr	r3, [r7, #4]
 8003032:	f04f 0200 	mov.w	r2, #0
 8003036:	f883 21e8 	strb.w	r2, [r3, #488]	; 0x1e8
  return ret;
 800303a:	7c7b      	ldrb	r3, [r7, #17]
}
 800303c:	4618      	mov	r0, r3
 800303e:	f107 0718 	add.w	r7, r7, #24
 8003042:	46bd      	mov	sp, r7
 8003044:	bc90      	pop	{r4, r7}
 8003046:	4770      	bx	lr

08003048 <HAL_PCD_EP_Close>:
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{  
 8003048:	b490      	push	{r4, r7}
 800304a:	b084      	sub	sp, #16
 800304c:	af00      	add	r7, sp, #0
 800304e:	6078      	str	r0, [r7, #4]
 8003050:	460b      	mov	r3, r1
 8003052:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;
  
  if ((ep_addr & 0x80) == 0x80)
 8003054:	78fb      	ldrb	r3, [r7, #3]
 8003056:	b25b      	sxtb	r3, r3
 8003058:	2b00      	cmp	r3, #0
 800305a:	da0e      	bge.n	800307a <HAL_PCD_EP_Close+0x32>
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 800305c:	78fb      	ldrb	r3, [r7, #3]
 800305e:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8003062:	4613      	mov	r3, r2
 8003064:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8003068:	1a9b      	subs	r3, r3, r2
 800306a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800306e:	f103 0328 	add.w	r3, r3, #40	; 0x28
 8003072:	687a      	ldr	r2, [r7, #4]
 8003074:	18d3      	adds	r3, r2, r3
 8003076:	60fb      	str	r3, [r7, #12]
 8003078:	e00d      	b.n	8003096 <HAL_PCD_EP_Close+0x4e>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 800307a:	78fb      	ldrb	r3, [r7, #3]
 800307c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8003080:	4613      	mov	r3, r2
 8003082:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8003086:	1a9b      	subs	r3, r3, r2
 8003088:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800308c:	f503 7384 	add.w	r3, r3, #264	; 0x108
 8003090:	687a      	ldr	r2, [r7, #4]
 8003092:	18d3      	adds	r3, r2, r3
 8003094:	60fb      	str	r3, [r7, #12]
  }
  ep->num   = ep_addr & 0x7F;
 8003096:	78fb      	ldrb	r3, [r7, #3]
 8003098:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800309c:	b2da      	uxtb	r2, r3
 800309e:	68fb      	ldr	r3, [r7, #12]
 80030a0:	701a      	strb	r2, [r3, #0]
  
  ep->is_in = (0x80 & ep_addr) != 0;
 80030a2:	78fb      	ldrb	r3, [r7, #3]
 80030a4:	ea4f 13d3 	mov.w	r3, r3, lsr #7
 80030a8:	b2db      	uxtb	r3, r3
 80030aa:	461a      	mov	r2, r3
 80030ac:	68fb      	ldr	r3, [r7, #12]
 80030ae:	705a      	strb	r2, [r3, #1]
  
  __HAL_LOCK(hpcd); 
 80030b0:	687b      	ldr	r3, [r7, #4]
 80030b2:	f893 31e8 	ldrb.w	r3, [r3, #488]	; 0x1e8
 80030b6:	2b01      	cmp	r3, #1
 80030b8:	d102      	bne.n	80030c0 <HAL_PCD_EP_Close+0x78>
 80030ba:	f04f 0302 	mov.w	r3, #2
 80030be:	e22a      	b.n	8003516 <HAL_PCD_EP_Close+0x4ce>
 80030c0:	687b      	ldr	r3, [r7, #4]
 80030c2:	f04f 0201 	mov.w	r2, #1
 80030c6:	f883 21e8 	strb.w	r2, [r3, #488]	; 0x1e8

  if (ep->doublebuffer == 0) 
 80030ca:	68fb      	ldr	r3, [r7, #12]
 80030cc:	7a9b      	ldrb	r3, [r3, #10]
 80030ce:	2b00      	cmp	r3, #0
 80030d0:	f040 80a2 	bne.w	8003218 <HAL_PCD_EP_Close+0x1d0>
  {
    if (ep->is_in)
 80030d4:	68fb      	ldr	r3, [r7, #12]
 80030d6:	785b      	ldrb	r3, [r3, #1]
 80030d8:	2b00      	cmp	r3, #0
 80030da:	d04e      	beq.n	800317a <HAL_PCD_EP_Close+0x132>
    {
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num);
 80030dc:	687b      	ldr	r3, [r7, #4]
 80030de:	681b      	ldr	r3, [r3, #0]
 80030e0:	461a      	mov	r2, r3
 80030e2:	68fb      	ldr	r3, [r7, #12]
 80030e4:	781b      	ldrb	r3, [r3, #0]
 80030e6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80030ea:	18d3      	adds	r3, r2, r3
 80030ec:	881b      	ldrh	r3, [r3, #0]
 80030ee:	b29b      	uxth	r3, r3
 80030f0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80030f4:	2b00      	cmp	r3, #0
 80030f6:	bf0c      	ite	eq
 80030f8:	2300      	moveq	r3, #0
 80030fa:	2301      	movne	r3, #1
 80030fc:	b2db      	uxtb	r3, r3
 80030fe:	2b00      	cmp	r3, #0
 8003100:	d01c      	beq.n	800313c <HAL_PCD_EP_Close+0xf4>
 8003102:	687b      	ldr	r3, [r7, #4]
 8003104:	681b      	ldr	r3, [r3, #0]
 8003106:	461a      	mov	r2, r3
 8003108:	68fb      	ldr	r3, [r7, #12]
 800310a:	781b      	ldrb	r3, [r3, #0]
 800310c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003110:	18d2      	adds	r2, r2, r3
 8003112:	687b      	ldr	r3, [r7, #4]
 8003114:	681b      	ldr	r3, [r3, #0]
 8003116:	4619      	mov	r1, r3
 8003118:	68fb      	ldr	r3, [r7, #12]
 800311a:	781b      	ldrb	r3, [r3, #0]
 800311c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003120:	18cb      	adds	r3, r1, r3
 8003122:	881b      	ldrh	r3, [r3, #0]
 8003124:	b299      	uxth	r1, r3
 8003126:	f640 730f 	movw	r3, #3855	; 0xf0f
 800312a:	400b      	ands	r3, r1
 800312c:	b299      	uxth	r1, r3
 800312e:	f248 03c0 	movw	r3, #32960	; 0x80c0
 8003132:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8003136:	430b      	orrs	r3, r1
 8003138:	b29b      	uxth	r3, r3
 800313a:	8013      	strh	r3, [r2, #0]
      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS); 
 800313c:	687b      	ldr	r3, [r7, #4]
 800313e:	681b      	ldr	r3, [r3, #0]
 8003140:	461a      	mov	r2, r3
 8003142:	68fb      	ldr	r3, [r7, #12]
 8003144:	781b      	ldrb	r3, [r3, #0]
 8003146:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800314a:	18d3      	adds	r3, r2, r3
 800314c:	881b      	ldrh	r3, [r3, #0]
 800314e:	b29b      	uxth	r3, r3
 8003150:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003154:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003158:	b29c      	uxth	r4, r3
 800315a:	687b      	ldr	r3, [r7, #4]
 800315c:	681b      	ldr	r3, [r3, #0]
 800315e:	461a      	mov	r2, r3
 8003160:	68fb      	ldr	r3, [r7, #12]
 8003162:	781b      	ldrb	r3, [r3, #0]
 8003164:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003168:	18d2      	adds	r2, r2, r3
 800316a:	f248 0380 	movw	r3, #32896	; 0x8080
 800316e:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8003172:	4323      	orrs	r3, r4
 8003174:	b29b      	uxth	r3, r3
 8003176:	8013      	strh	r3, [r2, #0]
 8003178:	e1c6      	b.n	8003508 <HAL_PCD_EP_Close+0x4c0>
    }
    else
    {
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num);
 800317a:	687b      	ldr	r3, [r7, #4]
 800317c:	681b      	ldr	r3, [r3, #0]
 800317e:	461a      	mov	r2, r3
 8003180:	68fb      	ldr	r3, [r7, #12]
 8003182:	781b      	ldrb	r3, [r3, #0]
 8003184:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003188:	18d3      	adds	r3, r2, r3
 800318a:	881b      	ldrh	r3, [r3, #0]
 800318c:	b29b      	uxth	r3, r3
 800318e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8003192:	2b00      	cmp	r3, #0
 8003194:	bf0c      	ite	eq
 8003196:	2300      	moveq	r3, #0
 8003198:	2301      	movne	r3, #1
 800319a:	b2db      	uxtb	r3, r3
 800319c:	2b00      	cmp	r3, #0
 800319e:	d01c      	beq.n	80031da <HAL_PCD_EP_Close+0x192>
 80031a0:	687b      	ldr	r3, [r7, #4]
 80031a2:	681b      	ldr	r3, [r3, #0]
 80031a4:	461a      	mov	r2, r3
 80031a6:	68fb      	ldr	r3, [r7, #12]
 80031a8:	781b      	ldrb	r3, [r3, #0]
 80031aa:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80031ae:	18d2      	adds	r2, r2, r3
 80031b0:	687b      	ldr	r3, [r7, #4]
 80031b2:	681b      	ldr	r3, [r3, #0]
 80031b4:	4619      	mov	r1, r3
 80031b6:	68fb      	ldr	r3, [r7, #12]
 80031b8:	781b      	ldrb	r3, [r3, #0]
 80031ba:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80031be:	18cb      	adds	r3, r1, r3
 80031c0:	881b      	ldrh	r3, [r3, #0]
 80031c2:	b299      	uxth	r1, r3
 80031c4:	f640 730f 	movw	r3, #3855	; 0xf0f
 80031c8:	400b      	ands	r3, r1
 80031ca:	b299      	uxth	r1, r3
 80031cc:	f24c 0380 	movw	r3, #49280	; 0xc080
 80031d0:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 80031d4:	430b      	orrs	r3, r1
 80031d6:	b29b      	uxth	r3, r3
 80031d8:	8013      	strh	r3, [r2, #0]
      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS);
 80031da:	687b      	ldr	r3, [r7, #4]
 80031dc:	681b      	ldr	r3, [r3, #0]
 80031de:	461a      	mov	r2, r3
 80031e0:	68fb      	ldr	r3, [r7, #12]
 80031e2:	781b      	ldrb	r3, [r3, #0]
 80031e4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80031e8:	18d3      	adds	r3, r2, r3
 80031ea:	881b      	ldrh	r3, [r3, #0]
 80031ec:	b29b      	uxth	r3, r3
 80031ee:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80031f2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80031f6:	b29c      	uxth	r4, r3
 80031f8:	687b      	ldr	r3, [r7, #4]
 80031fa:	681b      	ldr	r3, [r3, #0]
 80031fc:	461a      	mov	r2, r3
 80031fe:	68fb      	ldr	r3, [r7, #12]
 8003200:	781b      	ldrb	r3, [r3, #0]
 8003202:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003206:	18d2      	adds	r2, r2, r3
 8003208:	f248 0380 	movw	r3, #32896	; 0x8080
 800320c:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8003210:	4323      	orrs	r3, r4
 8003212:	b29b      	uxth	r3, r3
 8003214:	8013      	strh	r3, [r2, #0]
 8003216:	e177      	b.n	8003508 <HAL_PCD_EP_Close+0x4c0>
    }
  }
  /*Double Buffer*/
  else
  { 
    if (ep->is_in==0)
 8003218:	68fb      	ldr	r3, [r7, #12]
 800321a:	785b      	ldrb	r3, [r3, #1]
 800321c:	2b00      	cmp	r3, #0
 800321e:	f040 80ba 	bne.w	8003396 <HAL_PCD_EP_Close+0x34e>
    {
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num);
 8003222:	687b      	ldr	r3, [r7, #4]
 8003224:	681b      	ldr	r3, [r3, #0]
 8003226:	461a      	mov	r2, r3
 8003228:	68fb      	ldr	r3, [r7, #12]
 800322a:	781b      	ldrb	r3, [r3, #0]
 800322c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003230:	18d3      	adds	r3, r2, r3
 8003232:	881b      	ldrh	r3, [r3, #0]
 8003234:	b29b      	uxth	r3, r3
 8003236:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800323a:	2b00      	cmp	r3, #0
 800323c:	bf0c      	ite	eq
 800323e:	2300      	moveq	r3, #0
 8003240:	2301      	movne	r3, #1
 8003242:	b2db      	uxtb	r3, r3
 8003244:	2b00      	cmp	r3, #0
 8003246:	d01c      	beq.n	8003282 <HAL_PCD_EP_Close+0x23a>
 8003248:	687b      	ldr	r3, [r7, #4]
 800324a:	681b      	ldr	r3, [r3, #0]
 800324c:	461a      	mov	r2, r3
 800324e:	68fb      	ldr	r3, [r7, #12]
 8003250:	781b      	ldrb	r3, [r3, #0]
 8003252:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003256:	18d2      	adds	r2, r2, r3
 8003258:	687b      	ldr	r3, [r7, #4]
 800325a:	681b      	ldr	r3, [r3, #0]
 800325c:	4619      	mov	r1, r3
 800325e:	68fb      	ldr	r3, [r7, #12]
 8003260:	781b      	ldrb	r3, [r3, #0]
 8003262:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003266:	18cb      	adds	r3, r1, r3
 8003268:	881b      	ldrh	r3, [r3, #0]
 800326a:	b299      	uxth	r1, r3
 800326c:	f640 730f 	movw	r3, #3855	; 0xf0f
 8003270:	400b      	ands	r3, r1
 8003272:	b299      	uxth	r1, r3
 8003274:	f24c 0380 	movw	r3, #49280	; 0xc080
 8003278:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 800327c:	430b      	orrs	r3, r1
 800327e:	b29b      	uxth	r3, r3
 8003280:	8013      	strh	r3, [r2, #0]
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num);
 8003282:	687b      	ldr	r3, [r7, #4]
 8003284:	681b      	ldr	r3, [r3, #0]
 8003286:	461a      	mov	r2, r3
 8003288:	68fb      	ldr	r3, [r7, #12]
 800328a:	781b      	ldrb	r3, [r3, #0]
 800328c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003290:	18d3      	adds	r3, r2, r3
 8003292:	881b      	ldrh	r3, [r3, #0]
 8003294:	b29b      	uxth	r3, r3
 8003296:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800329a:	2b00      	cmp	r3, #0
 800329c:	bf0c      	ite	eq
 800329e:	2300      	moveq	r3, #0
 80032a0:	2301      	movne	r3, #1
 80032a2:	b2db      	uxtb	r3, r3
 80032a4:	2b00      	cmp	r3, #0
 80032a6:	d01c      	beq.n	80032e2 <HAL_PCD_EP_Close+0x29a>
 80032a8:	687b      	ldr	r3, [r7, #4]
 80032aa:	681b      	ldr	r3, [r3, #0]
 80032ac:	461a      	mov	r2, r3
 80032ae:	68fb      	ldr	r3, [r7, #12]
 80032b0:	781b      	ldrb	r3, [r3, #0]
 80032b2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80032b6:	18d2      	adds	r2, r2, r3
 80032b8:	687b      	ldr	r3, [r7, #4]
 80032ba:	681b      	ldr	r3, [r3, #0]
 80032bc:	4619      	mov	r1, r3
 80032be:	68fb      	ldr	r3, [r7, #12]
 80032c0:	781b      	ldrb	r3, [r3, #0]
 80032c2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80032c6:	18cb      	adds	r3, r1, r3
 80032c8:	881b      	ldrh	r3, [r3, #0]
 80032ca:	b299      	uxth	r1, r3
 80032cc:	f640 730f 	movw	r3, #3855	; 0xf0f
 80032d0:	400b      	ands	r3, r1
 80032d2:	b299      	uxth	r1, r3
 80032d4:	f248 03c0 	movw	r3, #32960	; 0x80c0
 80032d8:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 80032dc:	430b      	orrs	r3, r1
 80032de:	b29b      	uxth	r3, r3
 80032e0:	8013      	strh	r3, [r2, #0]
      
      /* Reset value of the data toggle bits for the endpoint out*/
      PCD_TX_DTOG(hpcd->Instance, ep->num);
 80032e2:	687b      	ldr	r3, [r7, #4]
 80032e4:	681b      	ldr	r3, [r3, #0]
 80032e6:	461a      	mov	r2, r3
 80032e8:	68fb      	ldr	r3, [r7, #12]
 80032ea:	781b      	ldrb	r3, [r3, #0]
 80032ec:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80032f0:	18d2      	adds	r2, r2, r3
 80032f2:	687b      	ldr	r3, [r7, #4]
 80032f4:	681b      	ldr	r3, [r3, #0]
 80032f6:	4619      	mov	r1, r3
 80032f8:	68fb      	ldr	r3, [r7, #12]
 80032fa:	781b      	ldrb	r3, [r3, #0]
 80032fc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003300:	18cb      	adds	r3, r1, r3
 8003302:	881b      	ldrh	r3, [r3, #0]
 8003304:	b299      	uxth	r1, r3
 8003306:	f640 730f 	movw	r3, #3855	; 0xf0f
 800330a:	400b      	ands	r3, r1
 800330c:	b299      	uxth	r1, r3
 800330e:	f248 03c0 	movw	r3, #32960	; 0x80c0
 8003312:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8003316:	430b      	orrs	r3, r1
 8003318:	b29b      	uxth	r3, r3
 800331a:	8013      	strh	r3, [r2, #0]
      
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS);
 800331c:	687b      	ldr	r3, [r7, #4]
 800331e:	681b      	ldr	r3, [r3, #0]
 8003320:	461a      	mov	r2, r3
 8003322:	68fb      	ldr	r3, [r7, #12]
 8003324:	781b      	ldrb	r3, [r3, #0]
 8003326:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800332a:	18d3      	adds	r3, r2, r3
 800332c:	881b      	ldrh	r3, [r3, #0]
 800332e:	b29b      	uxth	r3, r3
 8003330:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8003334:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003338:	b29c      	uxth	r4, r3
 800333a:	687b      	ldr	r3, [r7, #4]
 800333c:	681b      	ldr	r3, [r3, #0]
 800333e:	461a      	mov	r2, r3
 8003340:	68fb      	ldr	r3, [r7, #12]
 8003342:	781b      	ldrb	r3, [r3, #0]
 8003344:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003348:	18d2      	adds	r2, r2, r3
 800334a:	f248 0380 	movw	r3, #32896	; 0x8080
 800334e:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8003352:	4323      	orrs	r3, r4
 8003354:	b29b      	uxth	r3, r3
 8003356:	8013      	strh	r3, [r2, #0]
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS);
 8003358:	687b      	ldr	r3, [r7, #4]
 800335a:	681b      	ldr	r3, [r3, #0]
 800335c:	461a      	mov	r2, r3
 800335e:	68fb      	ldr	r3, [r7, #12]
 8003360:	781b      	ldrb	r3, [r3, #0]
 8003362:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003366:	18d3      	adds	r3, r2, r3
 8003368:	881b      	ldrh	r3, [r3, #0]
 800336a:	b29b      	uxth	r3, r3
 800336c:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003370:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003374:	b29c      	uxth	r4, r3
 8003376:	687b      	ldr	r3, [r7, #4]
 8003378:	681b      	ldr	r3, [r3, #0]
 800337a:	461a      	mov	r2, r3
 800337c:	68fb      	ldr	r3, [r7, #12]
 800337e:	781b      	ldrb	r3, [r3, #0]
 8003380:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003384:	18d2      	adds	r2, r2, r3
 8003386:	f248 0380 	movw	r3, #32896	; 0x8080
 800338a:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 800338e:	4323      	orrs	r3, r4
 8003390:	b29b      	uxth	r3, r3
 8003392:	8013      	strh	r3, [r2, #0]
 8003394:	e0b8      	b.n	8003508 <HAL_PCD_EP_Close+0x4c0>
    }
    else
    {
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num);
 8003396:	687b      	ldr	r3, [r7, #4]
 8003398:	681b      	ldr	r3, [r3, #0]
 800339a:	461a      	mov	r2, r3
 800339c:	68fb      	ldr	r3, [r7, #12]
 800339e:	781b      	ldrb	r3, [r3, #0]
 80033a0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80033a4:	18d3      	adds	r3, r2, r3
 80033a6:	881b      	ldrh	r3, [r3, #0]
 80033a8:	b29b      	uxth	r3, r3
 80033aa:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80033ae:	2b00      	cmp	r3, #0
 80033b0:	bf0c      	ite	eq
 80033b2:	2300      	moveq	r3, #0
 80033b4:	2301      	movne	r3, #1
 80033b6:	b2db      	uxtb	r3, r3
 80033b8:	2b00      	cmp	r3, #0
 80033ba:	d01c      	beq.n	80033f6 <HAL_PCD_EP_Close+0x3ae>
 80033bc:	687b      	ldr	r3, [r7, #4]
 80033be:	681b      	ldr	r3, [r3, #0]
 80033c0:	461a      	mov	r2, r3
 80033c2:	68fb      	ldr	r3, [r7, #12]
 80033c4:	781b      	ldrb	r3, [r3, #0]
 80033c6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80033ca:	18d2      	adds	r2, r2, r3
 80033cc:	687b      	ldr	r3, [r7, #4]
 80033ce:	681b      	ldr	r3, [r3, #0]
 80033d0:	4619      	mov	r1, r3
 80033d2:	68fb      	ldr	r3, [r7, #12]
 80033d4:	781b      	ldrb	r3, [r3, #0]
 80033d6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80033da:	18cb      	adds	r3, r1, r3
 80033dc:	881b      	ldrh	r3, [r3, #0]
 80033de:	b299      	uxth	r1, r3
 80033e0:	f640 730f 	movw	r3, #3855	; 0xf0f
 80033e4:	400b      	ands	r3, r1
 80033e6:	b299      	uxth	r1, r3
 80033e8:	f24c 0380 	movw	r3, #49280	; 0xc080
 80033ec:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 80033f0:	430b      	orrs	r3, r1
 80033f2:	b29b      	uxth	r3, r3
 80033f4:	8013      	strh	r3, [r2, #0]
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num);
 80033f6:	687b      	ldr	r3, [r7, #4]
 80033f8:	681b      	ldr	r3, [r3, #0]
 80033fa:	461a      	mov	r2, r3
 80033fc:	68fb      	ldr	r3, [r7, #12]
 80033fe:	781b      	ldrb	r3, [r3, #0]
 8003400:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003404:	18d3      	adds	r3, r2, r3
 8003406:	881b      	ldrh	r3, [r3, #0]
 8003408:	b29b      	uxth	r3, r3
 800340a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800340e:	2b00      	cmp	r3, #0
 8003410:	bf0c      	ite	eq
 8003412:	2300      	moveq	r3, #0
 8003414:	2301      	movne	r3, #1
 8003416:	b2db      	uxtb	r3, r3
 8003418:	2b00      	cmp	r3, #0
 800341a:	d01c      	beq.n	8003456 <HAL_PCD_EP_Close+0x40e>
 800341c:	687b      	ldr	r3, [r7, #4]
 800341e:	681b      	ldr	r3, [r3, #0]
 8003420:	461a      	mov	r2, r3
 8003422:	68fb      	ldr	r3, [r7, #12]
 8003424:	781b      	ldrb	r3, [r3, #0]
 8003426:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800342a:	18d2      	adds	r2, r2, r3
 800342c:	687b      	ldr	r3, [r7, #4]
 800342e:	681b      	ldr	r3, [r3, #0]
 8003430:	4619      	mov	r1, r3
 8003432:	68fb      	ldr	r3, [r7, #12]
 8003434:	781b      	ldrb	r3, [r3, #0]
 8003436:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800343a:	18cb      	adds	r3, r1, r3
 800343c:	881b      	ldrh	r3, [r3, #0]
 800343e:	b299      	uxth	r1, r3
 8003440:	f640 730f 	movw	r3, #3855	; 0xf0f
 8003444:	400b      	ands	r3, r1
 8003446:	b299      	uxth	r1, r3
 8003448:	f248 03c0 	movw	r3, #32960	; 0x80c0
 800344c:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8003450:	430b      	orrs	r3, r1
 8003452:	b29b      	uxth	r3, r3
 8003454:	8013      	strh	r3, [r2, #0]
      PCD_RX_DTOG(hpcd->Instance, ep->num);
 8003456:	687b      	ldr	r3, [r7, #4]
 8003458:	681b      	ldr	r3, [r3, #0]
 800345a:	461a      	mov	r2, r3
 800345c:	68fb      	ldr	r3, [r7, #12]
 800345e:	781b      	ldrb	r3, [r3, #0]
 8003460:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003464:	18d2      	adds	r2, r2, r3
 8003466:	687b      	ldr	r3, [r7, #4]
 8003468:	681b      	ldr	r3, [r3, #0]
 800346a:	4619      	mov	r1, r3
 800346c:	68fb      	ldr	r3, [r7, #12]
 800346e:	781b      	ldrb	r3, [r3, #0]
 8003470:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003474:	18cb      	adds	r3, r1, r3
 8003476:	881b      	ldrh	r3, [r3, #0]
 8003478:	b299      	uxth	r1, r3
 800347a:	f640 730f 	movw	r3, #3855	; 0xf0f
 800347e:	400b      	ands	r3, r1
 8003480:	b299      	uxth	r1, r3
 8003482:	f24c 0380 	movw	r3, #49280	; 0xc080
 8003486:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 800348a:	430b      	orrs	r3, r1
 800348c:	b29b      	uxth	r3, r3
 800348e:	8013      	strh	r3, [r2, #0]
      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS);
 8003490:	687b      	ldr	r3, [r7, #4]
 8003492:	681b      	ldr	r3, [r3, #0]
 8003494:	461a      	mov	r2, r3
 8003496:	68fb      	ldr	r3, [r7, #12]
 8003498:	781b      	ldrb	r3, [r3, #0]
 800349a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800349e:	18d3      	adds	r3, r2, r3
 80034a0:	881b      	ldrh	r3, [r3, #0]
 80034a2:	b29b      	uxth	r3, r3
 80034a4:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80034a8:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80034ac:	b29c      	uxth	r4, r3
 80034ae:	687b      	ldr	r3, [r7, #4]
 80034b0:	681b      	ldr	r3, [r3, #0]
 80034b2:	461a      	mov	r2, r3
 80034b4:	68fb      	ldr	r3, [r7, #12]
 80034b6:	781b      	ldrb	r3, [r3, #0]
 80034b8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80034bc:	18d2      	adds	r2, r2, r3
 80034be:	f248 0380 	movw	r3, #32896	; 0x8080
 80034c2:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 80034c6:	4323      	orrs	r3, r4
 80034c8:	b29b      	uxth	r3, r3
 80034ca:	8013      	strh	r3, [r2, #0]
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS);
 80034cc:	687b      	ldr	r3, [r7, #4]
 80034ce:	681b      	ldr	r3, [r3, #0]
 80034d0:	461a      	mov	r2, r3
 80034d2:	68fb      	ldr	r3, [r7, #12]
 80034d4:	781b      	ldrb	r3, [r3, #0]
 80034d6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80034da:	18d3      	adds	r3, r2, r3
 80034dc:	881b      	ldrh	r3, [r3, #0]
 80034de:	b29b      	uxth	r3, r3
 80034e0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80034e4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80034e8:	b29c      	uxth	r4, r3
 80034ea:	687b      	ldr	r3, [r7, #4]
 80034ec:	681b      	ldr	r3, [r3, #0]
 80034ee:	461a      	mov	r2, r3
 80034f0:	68fb      	ldr	r3, [r7, #12]
 80034f2:	781b      	ldrb	r3, [r3, #0]
 80034f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80034f8:	18d2      	adds	r2, r2, r3
 80034fa:	f248 0380 	movw	r3, #32896	; 0x8080
 80034fe:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8003502:	4323      	orrs	r3, r4
 8003504:	b29b      	uxth	r3, r3
 8003506:	8013      	strh	r3, [r2, #0]
    }
  } 
  
  __HAL_UNLOCK(hpcd);   
 8003508:	687b      	ldr	r3, [r7, #4]
 800350a:	f04f 0200 	mov.w	r2, #0
 800350e:	f883 21e8 	strb.w	r2, [r3, #488]	; 0x1e8
  return HAL_OK;
 8003512:	f04f 0300 	mov.w	r3, #0
}
 8003516:	4618      	mov	r0, r3
 8003518:	f107 0710 	add.w	r7, r7, #16
 800351c:	46bd      	mov	sp, r7
 800351e:	bc90      	pop	{r4, r7}
 8003520:	4770      	bx	lr
 8003522:	bf00      	nop

08003524 <HAL_PCD_EP_Receive>:
  * @param  pBuf: pointer to the reception buffer   
  * @param  len: amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8003524:	b490      	push	{r4, r7}
 8003526:	b088      	sub	sp, #32
 8003528:	af00      	add	r7, sp, #0
 800352a:	60f8      	str	r0, [r7, #12]
 800352c:	607a      	str	r2, [r7, #4]
 800352e:	603b      	str	r3, [r7, #0]
 8003530:	460b      	mov	r3, r1
 8003532:	72fb      	strb	r3, [r7, #11]
  
 PCD_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8003534:	7afb      	ldrb	r3, [r7, #11]
 8003536:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 800353a:	4613      	mov	r3, r2
 800353c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8003540:	1a9b      	subs	r3, r3, r2
 8003542:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003546:	f503 7384 	add.w	r3, r3, #264	; 0x108
 800354a:	68fa      	ldr	r2, [r7, #12]
 800354c:	18d3      	adds	r3, r2, r3
 800354e:	61bb      	str	r3, [r7, #24]
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 8003550:	69bb      	ldr	r3, [r7, #24]
 8003552:	687a      	ldr	r2, [r7, #4]
 8003554:	611a      	str	r2, [r3, #16]
  ep->xfer_len = len;
 8003556:	69bb      	ldr	r3, [r7, #24]
 8003558:	683a      	ldr	r2, [r7, #0]
 800355a:	615a      	str	r2, [r3, #20]
  ep->xfer_count = 0;
 800355c:	69bb      	ldr	r3, [r7, #24]
 800355e:	f04f 0200 	mov.w	r2, #0
 8003562:	619a      	str	r2, [r3, #24]
  ep->is_in = 0;
 8003564:	69bb      	ldr	r3, [r7, #24]
 8003566:	f04f 0200 	mov.w	r2, #0
 800356a:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & 0x7F;
 800356c:	7afb      	ldrb	r3, [r7, #11]
 800356e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8003572:	b2da      	uxtb	r2, r3
 8003574:	69bb      	ldr	r3, [r7, #24]
 8003576:	701a      	strb	r2, [r3, #0]
   
  __HAL_LOCK(hpcd); 
 8003578:	68fb      	ldr	r3, [r7, #12]
 800357a:	f893 31e8 	ldrb.w	r3, [r3, #488]	; 0x1e8
 800357e:	2b01      	cmp	r3, #1
 8003580:	d102      	bne.n	8003588 <HAL_PCD_EP_Receive+0x64>
 8003582:	f04f 0302 	mov.w	r3, #2
 8003586:	e0f9      	b.n	800377c <HAL_PCD_EP_Receive+0x258>
 8003588:	68fb      	ldr	r3, [r7, #12]
 800358a:	f04f 0201 	mov.w	r2, #1
 800358e:	f883 21e8 	strb.w	r2, [r3, #488]	; 0x1e8
   
  /* Multi packet transfer*/
  if (ep->xfer_len > ep->maxpacket)
 8003592:	69bb      	ldr	r3, [r7, #24]
 8003594:	695a      	ldr	r2, [r3, #20]
 8003596:	69bb      	ldr	r3, [r7, #24]
 8003598:	68db      	ldr	r3, [r3, #12]
 800359a:	429a      	cmp	r2, r3
 800359c:	d909      	bls.n	80035b2 <HAL_PCD_EP_Receive+0x8e>
  {
    len=ep->maxpacket;
 800359e:	69bb      	ldr	r3, [r7, #24]
 80035a0:	68db      	ldr	r3, [r3, #12]
 80035a2:	603b      	str	r3, [r7, #0]
    ep->xfer_len-=len; 
 80035a4:	69bb      	ldr	r3, [r7, #24]
 80035a6:	695a      	ldr	r2, [r3, #20]
 80035a8:	683b      	ldr	r3, [r7, #0]
 80035aa:	1ad2      	subs	r2, r2, r3
 80035ac:	69bb      	ldr	r3, [r7, #24]
 80035ae:	615a      	str	r2, [r3, #20]
 80035b0:	e006      	b.n	80035c0 <HAL_PCD_EP_Receive+0x9c>
  }
  else
  {
    len=ep->xfer_len;
 80035b2:	69bb      	ldr	r3, [r7, #24]
 80035b4:	695b      	ldr	r3, [r3, #20]
 80035b6:	603b      	str	r3, [r7, #0]
    ep->xfer_len =0;
 80035b8:	69bb      	ldr	r3, [r7, #24]
 80035ba:	f04f 0200 	mov.w	r2, #0
 80035be:	615a      	str	r2, [r3, #20]
  }
  
  /* configure and validate Rx endpoint */
  if (ep->doublebuffer == 0) 
 80035c0:	69bb      	ldr	r3, [r7, #24]
 80035c2:	7a9b      	ldrb	r3, [r3, #10]
 80035c4:	2b00      	cmp	r3, #0
 80035c6:	d147      	bne.n	8003658 <HAL_PCD_EP_Receive+0x134>
  {
    /*Set RX buffer count*/
    PCD_SET_EP_RX_CNT(hpcd->Instance, ep->num, len);
 80035c8:	68fb      	ldr	r3, [r7, #12]
 80035ca:	681b      	ldr	r3, [r3, #0]
 80035cc:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80035d0:	b29b      	uxth	r3, r3
 80035d2:	461a      	mov	r2, r3
 80035d4:	69bb      	ldr	r3, [r7, #24]
 80035d6:	781b      	ldrb	r3, [r3, #0]
 80035d8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80035dc:	18d3      	adds	r3, r2, r3
 80035de:	f103 0306 	add.w	r3, r3, #6
 80035e2:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80035e6:	461a      	mov	r2, r3
 80035e8:	68fb      	ldr	r3, [r7, #12]
 80035ea:	681b      	ldr	r3, [r3, #0]
 80035ec:	18d3      	adds	r3, r2, r3
 80035ee:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80035f2:	617b      	str	r3, [r7, #20]
 80035f4:	683b      	ldr	r3, [r7, #0]
 80035f6:	2b3e      	cmp	r3, #62	; 0x3e
 80035f8:	d919      	bls.n	800362e <HAL_PCD_EP_Receive+0x10a>
 80035fa:	683b      	ldr	r3, [r7, #0]
 80035fc:	ea4f 1353 	mov.w	r3, r3, lsr #5
 8003600:	83fb      	strh	r3, [r7, #30]
 8003602:	683b      	ldr	r3, [r7, #0]
 8003604:	f003 031f 	and.w	r3, r3, #31
 8003608:	2b00      	cmp	r3, #0
 800360a:	d103      	bne.n	8003614 <HAL_PCD_EP_Receive+0xf0>
 800360c:	8bfb      	ldrh	r3, [r7, #30]
 800360e:	f103 33ff 	add.w	r3, r3, #4294967295
 8003612:	83fb      	strh	r3, [r7, #30]
 8003614:	8bfb      	ldrh	r3, [r7, #30]
 8003616:	ea4f 2383 	mov.w	r3, r3, lsl #10
 800361a:	b29b      	uxth	r3, r3
 800361c:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8003620:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8003624:	b29b      	uxth	r3, r3
 8003626:	461a      	mov	r2, r3
 8003628:	697b      	ldr	r3, [r7, #20]
 800362a:	601a      	str	r2, [r3, #0]
 800362c:	e07b      	b.n	8003726 <HAL_PCD_EP_Receive+0x202>
 800362e:	683b      	ldr	r3, [r7, #0]
 8003630:	ea4f 0353 	mov.w	r3, r3, lsr #1
 8003634:	83fb      	strh	r3, [r7, #30]
 8003636:	683b      	ldr	r3, [r7, #0]
 8003638:	f003 0301 	and.w	r3, r3, #1
 800363c:	2b00      	cmp	r3, #0
 800363e:	d003      	beq.n	8003648 <HAL_PCD_EP_Receive+0x124>
 8003640:	8bfb      	ldrh	r3, [r7, #30]
 8003642:	f103 0301 	add.w	r3, r3, #1
 8003646:	83fb      	strh	r3, [r7, #30]
 8003648:	8bfb      	ldrh	r3, [r7, #30]
 800364a:	ea4f 2383 	mov.w	r3, r3, lsl #10
 800364e:	b29b      	uxth	r3, r3
 8003650:	461a      	mov	r2, r3
 8003652:	697b      	ldr	r3, [r7, #20]
 8003654:	601a      	str	r2, [r3, #0]
 8003656:	e066      	b.n	8003726 <HAL_PCD_EP_Receive+0x202>
  }
  else
  {
    /*Set the Double buffer counter*/
    PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 8003658:	69bb      	ldr	r3, [r7, #24]
 800365a:	785b      	ldrb	r3, [r3, #1]
 800365c:	2b00      	cmp	r3, #0
 800365e:	d147      	bne.n	80036f0 <HAL_PCD_EP_Receive+0x1cc>
 8003660:	68fb      	ldr	r3, [r7, #12]
 8003662:	681b      	ldr	r3, [r3, #0]
 8003664:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8003668:	b29b      	uxth	r3, r3
 800366a:	461a      	mov	r2, r3
 800366c:	69bb      	ldr	r3, [r7, #24]
 800366e:	781b      	ldrb	r3, [r3, #0]
 8003670:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8003674:	18d3      	adds	r3, r2, r3
 8003676:	f103 0306 	add.w	r3, r3, #6
 800367a:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800367e:	461a      	mov	r2, r3
 8003680:	68fb      	ldr	r3, [r7, #12]
 8003682:	681b      	ldr	r3, [r3, #0]
 8003684:	18d3      	adds	r3, r2, r3
 8003686:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800368a:	613b      	str	r3, [r7, #16]
 800368c:	683b      	ldr	r3, [r7, #0]
 800368e:	2b3e      	cmp	r3, #62	; 0x3e
 8003690:	d919      	bls.n	80036c6 <HAL_PCD_EP_Receive+0x1a2>
 8003692:	683b      	ldr	r3, [r7, #0]
 8003694:	ea4f 1353 	mov.w	r3, r3, lsr #5
 8003698:	83bb      	strh	r3, [r7, #28]
 800369a:	683b      	ldr	r3, [r7, #0]
 800369c:	f003 031f 	and.w	r3, r3, #31
 80036a0:	2b00      	cmp	r3, #0
 80036a2:	d103      	bne.n	80036ac <HAL_PCD_EP_Receive+0x188>
 80036a4:	8bbb      	ldrh	r3, [r7, #28]
 80036a6:	f103 33ff 	add.w	r3, r3, #4294967295
 80036aa:	83bb      	strh	r3, [r7, #28]
 80036ac:	8bbb      	ldrh	r3, [r7, #28]
 80036ae:	ea4f 2383 	mov.w	r3, r3, lsl #10
 80036b2:	b29b      	uxth	r3, r3
 80036b4:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80036b8:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80036bc:	b29b      	uxth	r3, r3
 80036be:	461a      	mov	r2, r3
 80036c0:	693b      	ldr	r3, [r7, #16]
 80036c2:	601a      	str	r2, [r3, #0]
 80036c4:	e02f      	b.n	8003726 <HAL_PCD_EP_Receive+0x202>
 80036c6:	683b      	ldr	r3, [r7, #0]
 80036c8:	ea4f 0353 	mov.w	r3, r3, lsr #1
 80036cc:	83bb      	strh	r3, [r7, #28]
 80036ce:	683b      	ldr	r3, [r7, #0]
 80036d0:	f003 0301 	and.w	r3, r3, #1
 80036d4:	2b00      	cmp	r3, #0
 80036d6:	d003      	beq.n	80036e0 <HAL_PCD_EP_Receive+0x1bc>
 80036d8:	8bbb      	ldrh	r3, [r7, #28]
 80036da:	f103 0301 	add.w	r3, r3, #1
 80036de:	83bb      	strh	r3, [r7, #28]
 80036e0:	8bbb      	ldrh	r3, [r7, #28]
 80036e2:	ea4f 2383 	mov.w	r3, r3, lsl #10
 80036e6:	b29b      	uxth	r3, r3
 80036e8:	461a      	mov	r2, r3
 80036ea:	693b      	ldr	r3, [r7, #16]
 80036ec:	601a      	str	r2, [r3, #0]
 80036ee:	e01a      	b.n	8003726 <HAL_PCD_EP_Receive+0x202>
 80036f0:	69bb      	ldr	r3, [r7, #24]
 80036f2:	785b      	ldrb	r3, [r3, #1]
 80036f4:	2b01      	cmp	r3, #1
 80036f6:	d116      	bne.n	8003726 <HAL_PCD_EP_Receive+0x202>
 80036f8:	68fb      	ldr	r3, [r7, #12]
 80036fa:	681b      	ldr	r3, [r3, #0]
 80036fc:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8003700:	b29b      	uxth	r3, r3
 8003702:	461a      	mov	r2, r3
 8003704:	69bb      	ldr	r3, [r7, #24]
 8003706:	781b      	ldrb	r3, [r3, #0]
 8003708:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800370c:	18d3      	adds	r3, r2, r3
 800370e:	f103 0306 	add.w	r3, r3, #6
 8003712:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8003716:	461a      	mov	r2, r3
 8003718:	68fb      	ldr	r3, [r7, #12]
 800371a:	681b      	ldr	r3, [r3, #0]
 800371c:	18d3      	adds	r3, r2, r3
 800371e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8003722:	683a      	ldr	r2, [r7, #0]
 8003724:	601a      	str	r2, [r3, #0]
  } 
  
  PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID);
 8003726:	68fb      	ldr	r3, [r7, #12]
 8003728:	681b      	ldr	r3, [r3, #0]
 800372a:	461a      	mov	r2, r3
 800372c:	69bb      	ldr	r3, [r7, #24]
 800372e:	781b      	ldrb	r3, [r3, #0]
 8003730:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003734:	18d3      	adds	r3, r2, r3
 8003736:	881b      	ldrh	r3, [r3, #0]
 8003738:	b29b      	uxth	r3, r3
 800373a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800373e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003742:	b29c      	uxth	r4, r3
 8003744:	f484 5380 	eor.w	r3, r4, #4096	; 0x1000
 8003748:	b29c      	uxth	r4, r3
 800374a:	f484 5300 	eor.w	r3, r4, #8192	; 0x2000
 800374e:	b29c      	uxth	r4, r3
 8003750:	68fb      	ldr	r3, [r7, #12]
 8003752:	681b      	ldr	r3, [r3, #0]
 8003754:	461a      	mov	r2, r3
 8003756:	69bb      	ldr	r3, [r7, #24]
 8003758:	781b      	ldrb	r3, [r3, #0]
 800375a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800375e:	18d2      	adds	r2, r2, r3
 8003760:	f248 0380 	movw	r3, #32896	; 0x8080
 8003764:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8003768:	4323      	orrs	r3, r4
 800376a:	b29b      	uxth	r3, r3
 800376c:	8013      	strh	r3, [r2, #0]
  
  __HAL_UNLOCK(hpcd); 
 800376e:	68fb      	ldr	r3, [r7, #12]
 8003770:	f04f 0200 	mov.w	r2, #0
 8003774:	f883 21e8 	strb.w	r2, [r3, #488]	; 0x1e8
  
  return HAL_OK;
 8003778:	f04f 0300 	mov.w	r3, #0
}
 800377c:	4618      	mov	r0, r3
 800377e:	f107 0720 	add.w	r7, r7, #32
 8003782:	46bd      	mov	sp, r7
 8003784:	bc90      	pop	{r4, r7}
 8003786:	4770      	bx	lr

08003788 <HAL_PCD_EP_GetRxCount>:
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval Data Size
  */
uint16_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8003788:	b480      	push	{r7}
 800378a:	b083      	sub	sp, #12
 800378c:	af00      	add	r7, sp, #0
 800378e:	6078      	str	r0, [r7, #4]
 8003790:	460b      	mov	r3, r1
 8003792:	70fb      	strb	r3, [r7, #3]
  return hpcd->OUT_ep[ep_addr & 0x7F].xfer_count;
 8003794:	78fb      	ldrb	r3, [r7, #3]
 8003796:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 800379a:	6879      	ldr	r1, [r7, #4]
 800379c:	4613      	mov	r3, r2
 800379e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80037a2:	1a9b      	subs	r3, r3, r2
 80037a4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80037a8:	18cb      	adds	r3, r1, r3
 80037aa:	f503 7390 	add.w	r3, r3, #288	; 0x120
 80037ae:	681b      	ldr	r3, [r3, #0]
 80037b0:	b29b      	uxth	r3, r3
}
 80037b2:	4618      	mov	r0, r3
 80037b4:	f107 070c 	add.w	r7, r7, #12
 80037b8:	46bd      	mov	sp, r7
 80037ba:	bc80      	pop	{r7}
 80037bc:	4770      	bx	lr
 80037be:	bf00      	nop

080037c0 <HAL_PCD_EP_Transmit>:
  * @param  pBuf: pointer to the transmission buffer   
  * @param  len: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 80037c0:	b590      	push	{r4, r7, lr}
 80037c2:	b089      	sub	sp, #36	; 0x24
 80037c4:	af00      	add	r7, sp, #0
 80037c6:	60f8      	str	r0, [r7, #12]
 80037c8:	607a      	str	r2, [r7, #4]
 80037ca:	603b      	str	r3, [r7, #0]
 80037cc:	460b      	mov	r3, r1
 80037ce:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;
  uint16_t pmabuffer = 0;
 80037d0:	f04f 0300 	mov.w	r3, #0
 80037d4:	83fb      	strh	r3, [r7, #30]
    
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
 80037d6:	7afb      	ldrb	r3, [r7, #11]
 80037d8:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 80037dc:	4613      	mov	r3, r2
 80037de:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80037e2:	1a9b      	subs	r3, r3, r2
 80037e4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80037e8:	f103 0328 	add.w	r3, r3, #40	; 0x28
 80037ec:	68fa      	ldr	r2, [r7, #12]
 80037ee:	18d3      	adds	r3, r2, r3
 80037f0:	61bb      	str	r3, [r7, #24]
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 80037f2:	69bb      	ldr	r3, [r7, #24]
 80037f4:	687a      	ldr	r2, [r7, #4]
 80037f6:	611a      	str	r2, [r3, #16]
  ep->xfer_len = len;
 80037f8:	69bb      	ldr	r3, [r7, #24]
 80037fa:	683a      	ldr	r2, [r7, #0]
 80037fc:	615a      	str	r2, [r3, #20]
  ep->xfer_count = 0;
 80037fe:	69bb      	ldr	r3, [r7, #24]
 8003800:	f04f 0200 	mov.w	r2, #0
 8003804:	619a      	str	r2, [r3, #24]
  ep->is_in = 1;
 8003806:	69bb      	ldr	r3, [r7, #24]
 8003808:	f04f 0201 	mov.w	r2, #1
 800380c:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & 0x7F;
 800380e:	7afb      	ldrb	r3, [r7, #11]
 8003810:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8003814:	b2da      	uxtb	r2, r3
 8003816:	69bb      	ldr	r3, [r7, #24]
 8003818:	701a      	strb	r2, [r3, #0]
  
  __HAL_LOCK(hpcd); 
 800381a:	68fb      	ldr	r3, [r7, #12]
 800381c:	f893 31e8 	ldrb.w	r3, [r3, #488]	; 0x1e8
 8003820:	2b01      	cmp	r3, #1
 8003822:	d102      	bne.n	800382a <HAL_PCD_EP_Transmit+0x6a>
 8003824:	f04f 0302 	mov.w	r3, #2
 8003828:	e139      	b.n	8003a9e <HAL_PCD_EP_Transmit+0x2de>
 800382a:	68fb      	ldr	r3, [r7, #12]
 800382c:	f04f 0201 	mov.w	r2, #1
 8003830:	f883 21e8 	strb.w	r2, [r3, #488]	; 0x1e8
  
  /*Multi packet transfer*/
  if (ep->xfer_len > ep->maxpacket)
 8003834:	69bb      	ldr	r3, [r7, #24]
 8003836:	695a      	ldr	r2, [r3, #20]
 8003838:	69bb      	ldr	r3, [r7, #24]
 800383a:	68db      	ldr	r3, [r3, #12]
 800383c:	429a      	cmp	r2, r3
 800383e:	d909      	bls.n	8003854 <HAL_PCD_EP_Transmit+0x94>
  {
    len=ep->maxpacket;
 8003840:	69bb      	ldr	r3, [r7, #24]
 8003842:	68db      	ldr	r3, [r3, #12]
 8003844:	603b      	str	r3, [r7, #0]
    ep->xfer_len-=len; 
 8003846:	69bb      	ldr	r3, [r7, #24]
 8003848:	695a      	ldr	r2, [r3, #20]
 800384a:	683b      	ldr	r3, [r7, #0]
 800384c:	1ad2      	subs	r2, r2, r3
 800384e:	69bb      	ldr	r3, [r7, #24]
 8003850:	615a      	str	r2, [r3, #20]
 8003852:	e006      	b.n	8003862 <HAL_PCD_EP_Transmit+0xa2>
  }
  else
  {  
    len=ep->xfer_len;
 8003854:	69bb      	ldr	r3, [r7, #24]
 8003856:	695b      	ldr	r3, [r3, #20]
 8003858:	603b      	str	r3, [r7, #0]
    ep->xfer_len =0;
 800385a:	69bb      	ldr	r3, [r7, #24]
 800385c:	f04f 0200 	mov.w	r2, #0
 8003860:	615a      	str	r2, [r3, #20]
  }
  
  /* configure and validate Tx endpoint */
  if (ep->doublebuffer == 0) 
 8003862:	69bb      	ldr	r3, [r7, #24]
 8003864:	7a9b      	ldrb	r3, [r3, #10]
 8003866:	2b00      	cmp	r3, #0
 8003868:	d121      	bne.n	80038ae <HAL_PCD_EP_Transmit+0xee>
  {
    PCD_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, len);
 800386a:	68fb      	ldr	r3, [r7, #12]
 800386c:	6818      	ldr	r0, [r3, #0]
 800386e:	69bb      	ldr	r3, [r7, #24]
 8003870:	6919      	ldr	r1, [r3, #16]
 8003872:	69bb      	ldr	r3, [r7, #24]
 8003874:	889a      	ldrh	r2, [r3, #4]
 8003876:	683b      	ldr	r3, [r7, #0]
 8003878:	b29b      	uxth	r3, r3
 800387a:	f000 fe83 	bl	8004584 <PCD_WritePMA(USB_TypeDef*, unsigned char*, unsigned short, unsigned short)>
    PCD_SET_EP_TX_CNT(hpcd->Instance, ep->num, len);
 800387e:	68fb      	ldr	r3, [r7, #12]
 8003880:	681b      	ldr	r3, [r3, #0]
 8003882:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8003886:	b29b      	uxth	r3, r3
 8003888:	461a      	mov	r2, r3
 800388a:	69bb      	ldr	r3, [r7, #24]
 800388c:	781b      	ldrb	r3, [r3, #0]
 800388e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8003892:	18d3      	adds	r3, r2, r3
 8003894:	f103 0302 	add.w	r3, r3, #2
 8003898:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800389c:	461a      	mov	r2, r3
 800389e:	68fb      	ldr	r3, [r7, #12]
 80038a0:	681b      	ldr	r3, [r3, #0]
 80038a2:	18d3      	adds	r3, r2, r3
 80038a4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80038a8:	683a      	ldr	r2, [r7, #0]
 80038aa:	601a      	str	r2, [r3, #0]
 80038ac:	e0cc      	b.n	8003a48 <HAL_PCD_EP_Transmit+0x288>
  }
  else
  {
    /*Set the Double buffer counter*/
    PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 80038ae:	69bb      	ldr	r3, [r7, #24]
 80038b0:	785b      	ldrb	r3, [r3, #1]
 80038b2:	2b00      	cmp	r3, #0
 80038b4:	d147      	bne.n	8003946 <HAL_PCD_EP_Transmit+0x186>
 80038b6:	68fb      	ldr	r3, [r7, #12]
 80038b8:	681b      	ldr	r3, [r3, #0]
 80038ba:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80038be:	b29b      	uxth	r3, r3
 80038c0:	461a      	mov	r2, r3
 80038c2:	69bb      	ldr	r3, [r7, #24]
 80038c4:	781b      	ldrb	r3, [r3, #0]
 80038c6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80038ca:	18d3      	adds	r3, r2, r3
 80038cc:	f103 0306 	add.w	r3, r3, #6
 80038d0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80038d4:	461a      	mov	r2, r3
 80038d6:	68fb      	ldr	r3, [r7, #12]
 80038d8:	681b      	ldr	r3, [r3, #0]
 80038da:	18d3      	adds	r3, r2, r3
 80038dc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80038e0:	617b      	str	r3, [r7, #20]
 80038e2:	683b      	ldr	r3, [r7, #0]
 80038e4:	2b3e      	cmp	r3, #62	; 0x3e
 80038e6:	d919      	bls.n	800391c <HAL_PCD_EP_Transmit+0x15c>
 80038e8:	683b      	ldr	r3, [r7, #0]
 80038ea:	ea4f 1353 	mov.w	r3, r3, lsr #5
 80038ee:	83bb      	strh	r3, [r7, #28]
 80038f0:	683b      	ldr	r3, [r7, #0]
 80038f2:	f003 031f 	and.w	r3, r3, #31
 80038f6:	2b00      	cmp	r3, #0
 80038f8:	d103      	bne.n	8003902 <HAL_PCD_EP_Transmit+0x142>
 80038fa:	8bbb      	ldrh	r3, [r7, #28]
 80038fc:	f103 33ff 	add.w	r3, r3, #4294967295
 8003900:	83bb      	strh	r3, [r7, #28]
 8003902:	8bbb      	ldrh	r3, [r7, #28]
 8003904:	ea4f 2383 	mov.w	r3, r3, lsl #10
 8003908:	b29b      	uxth	r3, r3
 800390a:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800390e:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8003912:	b29b      	uxth	r3, r3
 8003914:	461a      	mov	r2, r3
 8003916:	697b      	ldr	r3, [r7, #20]
 8003918:	601a      	str	r2, [r3, #0]
 800391a:	e02f      	b.n	800397c <HAL_PCD_EP_Transmit+0x1bc>
 800391c:	683b      	ldr	r3, [r7, #0]
 800391e:	ea4f 0353 	mov.w	r3, r3, lsr #1
 8003922:	83bb      	strh	r3, [r7, #28]
 8003924:	683b      	ldr	r3, [r7, #0]
 8003926:	f003 0301 	and.w	r3, r3, #1
 800392a:	2b00      	cmp	r3, #0
 800392c:	d003      	beq.n	8003936 <HAL_PCD_EP_Transmit+0x176>
 800392e:	8bbb      	ldrh	r3, [r7, #28]
 8003930:	f103 0301 	add.w	r3, r3, #1
 8003934:	83bb      	strh	r3, [r7, #28]
 8003936:	8bbb      	ldrh	r3, [r7, #28]
 8003938:	ea4f 2383 	mov.w	r3, r3, lsl #10
 800393c:	b29b      	uxth	r3, r3
 800393e:	461a      	mov	r2, r3
 8003940:	697b      	ldr	r3, [r7, #20]
 8003942:	601a      	str	r2, [r3, #0]
 8003944:	e01a      	b.n	800397c <HAL_PCD_EP_Transmit+0x1bc>
 8003946:	69bb      	ldr	r3, [r7, #24]
 8003948:	785b      	ldrb	r3, [r3, #1]
 800394a:	2b01      	cmp	r3, #1
 800394c:	d116      	bne.n	800397c <HAL_PCD_EP_Transmit+0x1bc>
 800394e:	68fb      	ldr	r3, [r7, #12]
 8003950:	681b      	ldr	r3, [r3, #0]
 8003952:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8003956:	b29b      	uxth	r3, r3
 8003958:	461a      	mov	r2, r3
 800395a:	69bb      	ldr	r3, [r7, #24]
 800395c:	781b      	ldrb	r3, [r3, #0]
 800395e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8003962:	18d3      	adds	r3, r2, r3
 8003964:	f103 0306 	add.w	r3, r3, #6
 8003968:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800396c:	461a      	mov	r2, r3
 800396e:	68fb      	ldr	r3, [r7, #12]
 8003970:	681b      	ldr	r3, [r3, #0]
 8003972:	18d3      	adds	r3, r2, r3
 8003974:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8003978:	683a      	ldr	r2, [r7, #0]
 800397a:	601a      	str	r2, [r3, #0]
    
    /*Write the data to the USB endpoint*/
    if (PCD_GET_ENDPOINT(hpcd->Instance, ep->num)& USB_EP_DTOG_TX)
 800397c:	68fb      	ldr	r3, [r7, #12]
 800397e:	681b      	ldr	r3, [r3, #0]
 8003980:	461a      	mov	r2, r3
 8003982:	69bb      	ldr	r3, [r7, #24]
 8003984:	781b      	ldrb	r3, [r3, #0]
 8003986:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800398a:	18d3      	adds	r3, r2, r3
 800398c:	881b      	ldrh	r3, [r3, #0]
 800398e:	b29b      	uxth	r3, r3
 8003990:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8003994:	2b00      	cmp	r3, #0
 8003996:	bf0c      	ite	eq
 8003998:	2300      	moveq	r3, #0
 800399a:	2301      	movne	r3, #1
 800399c:	b2db      	uxtb	r3, r3
 800399e:	2b00      	cmp	r3, #0
 80039a0:	d003      	beq.n	80039aa <HAL_PCD_EP_Transmit+0x1ea>
    {
      pmabuffer = ep->pmaaddr1;
 80039a2:	69bb      	ldr	r3, [r7, #24]
 80039a4:	891b      	ldrh	r3, [r3, #8]
 80039a6:	83fb      	strh	r3, [r7, #30]
 80039a8:	e002      	b.n	80039b0 <HAL_PCD_EP_Transmit+0x1f0>
    }
    else
    {
      pmabuffer = ep->pmaaddr0;
 80039aa:	69bb      	ldr	r3, [r7, #24]
 80039ac:	88db      	ldrh	r3, [r3, #6]
 80039ae:	83fb      	strh	r3, [r7, #30]
    }
    PCD_WritePMA(hpcd->Instance, ep->xfer_buff, pmabuffer, len);
 80039b0:	68fb      	ldr	r3, [r7, #12]
 80039b2:	6818      	ldr	r0, [r3, #0]
 80039b4:	69bb      	ldr	r3, [r7, #24]
 80039b6:	6919      	ldr	r1, [r3, #16]
 80039b8:	683b      	ldr	r3, [r7, #0]
 80039ba:	b29b      	uxth	r3, r3
 80039bc:	8bfa      	ldrh	r2, [r7, #30]
 80039be:	f000 fde1 	bl	8004584 <PCD_WritePMA(USB_TypeDef*, unsigned char*, unsigned short, unsigned short)>
    PCD_FreeUserBuffer(hpcd->Instance, ep->num, ep->is_in);
 80039c2:	69bb      	ldr	r3, [r7, #24]
 80039c4:	785b      	ldrb	r3, [r3, #1]
 80039c6:	2b00      	cmp	r3, #0
 80039c8:	d11d      	bne.n	8003a06 <HAL_PCD_EP_Transmit+0x246>
 80039ca:	68fb      	ldr	r3, [r7, #12]
 80039cc:	681b      	ldr	r3, [r3, #0]
 80039ce:	461a      	mov	r2, r3
 80039d0:	69bb      	ldr	r3, [r7, #24]
 80039d2:	781b      	ldrb	r3, [r3, #0]
 80039d4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80039d8:	18d2      	adds	r2, r2, r3
 80039da:	68fb      	ldr	r3, [r7, #12]
 80039dc:	681b      	ldr	r3, [r3, #0]
 80039de:	4619      	mov	r1, r3
 80039e0:	69bb      	ldr	r3, [r7, #24]
 80039e2:	781b      	ldrb	r3, [r3, #0]
 80039e4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80039e8:	18cb      	adds	r3, r1, r3
 80039ea:	881b      	ldrh	r3, [r3, #0]
 80039ec:	b299      	uxth	r1, r3
 80039ee:	f640 730f 	movw	r3, #3855	; 0xf0f
 80039f2:	400b      	ands	r3, r1
 80039f4:	b299      	uxth	r1, r3
 80039f6:	f248 03c0 	movw	r3, #32960	; 0x80c0
 80039fa:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 80039fe:	430b      	orrs	r3, r1
 8003a00:	b29b      	uxth	r3, r3
 8003a02:	8013      	strh	r3, [r2, #0]
 8003a04:	e020      	b.n	8003a48 <HAL_PCD_EP_Transmit+0x288>
 8003a06:	69bb      	ldr	r3, [r7, #24]
 8003a08:	785b      	ldrb	r3, [r3, #1]
 8003a0a:	2b01      	cmp	r3, #1
 8003a0c:	d11c      	bne.n	8003a48 <HAL_PCD_EP_Transmit+0x288>
 8003a0e:	68fb      	ldr	r3, [r7, #12]
 8003a10:	681b      	ldr	r3, [r3, #0]
 8003a12:	461a      	mov	r2, r3
 8003a14:	69bb      	ldr	r3, [r7, #24]
 8003a16:	781b      	ldrb	r3, [r3, #0]
 8003a18:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003a1c:	18d2      	adds	r2, r2, r3
 8003a1e:	68fb      	ldr	r3, [r7, #12]
 8003a20:	681b      	ldr	r3, [r3, #0]
 8003a22:	4619      	mov	r1, r3
 8003a24:	69bb      	ldr	r3, [r7, #24]
 8003a26:	781b      	ldrb	r3, [r3, #0]
 8003a28:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003a2c:	18cb      	adds	r3, r1, r3
 8003a2e:	881b      	ldrh	r3, [r3, #0]
 8003a30:	b299      	uxth	r1, r3
 8003a32:	f640 730f 	movw	r3, #3855	; 0xf0f
 8003a36:	400b      	ands	r3, r1
 8003a38:	b299      	uxth	r1, r3
 8003a3a:	f24c 0380 	movw	r3, #49280	; 0xc080
 8003a3e:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8003a42:	430b      	orrs	r3, r1
 8003a44:	b29b      	uxth	r3, r3
 8003a46:	8013      	strh	r3, [r2, #0]
  }

  PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_VALID);
 8003a48:	68fb      	ldr	r3, [r7, #12]
 8003a4a:	681b      	ldr	r3, [r3, #0]
 8003a4c:	461a      	mov	r2, r3
 8003a4e:	69bb      	ldr	r3, [r7, #24]
 8003a50:	781b      	ldrb	r3, [r3, #0]
 8003a52:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003a56:	18d3      	adds	r3, r2, r3
 8003a58:	881b      	ldrh	r3, [r3, #0]
 8003a5a:	b29b      	uxth	r3, r3
 8003a5c:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003a60:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003a64:	b29c      	uxth	r4, r3
 8003a66:	f084 0310 	eor.w	r3, r4, #16
 8003a6a:	b29c      	uxth	r4, r3
 8003a6c:	f084 0320 	eor.w	r3, r4, #32
 8003a70:	b29c      	uxth	r4, r3
 8003a72:	68fb      	ldr	r3, [r7, #12]
 8003a74:	681b      	ldr	r3, [r3, #0]
 8003a76:	461a      	mov	r2, r3
 8003a78:	69bb      	ldr	r3, [r7, #24]
 8003a7a:	781b      	ldrb	r3, [r3, #0]
 8003a7c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003a80:	18d2      	adds	r2, r2, r3
 8003a82:	f248 0380 	movw	r3, #32896	; 0x8080
 8003a86:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8003a8a:	4323      	orrs	r3, r4
 8003a8c:	b29b      	uxth	r3, r3
 8003a8e:	8013      	strh	r3, [r2, #0]
  
  __HAL_UNLOCK(hpcd);
 8003a90:	68fb      	ldr	r3, [r7, #12]
 8003a92:	f04f 0200 	mov.w	r2, #0
 8003a96:	f883 21e8 	strb.w	r2, [r3, #488]	; 0x1e8
     
  return HAL_OK;
 8003a9a:	f04f 0300 	mov.w	r3, #0
}
 8003a9e:	4618      	mov	r0, r3
 8003aa0:	f107 0724 	add.w	r7, r7, #36	; 0x24
 8003aa4:	46bd      	mov	sp, r7
 8003aa6:	bd90      	pop	{r4, r7, pc}

08003aa8 <HAL_PCD_EP_SetStall>:
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8003aa8:	b490      	push	{r4, r7}
 8003aaa:	b084      	sub	sp, #16
 8003aac:	af00      	add	r7, sp, #0
 8003aae:	6078      	str	r0, [r7, #4]
 8003ab0:	460b      	mov	r3, r1
 8003ab2:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;
   
  __HAL_LOCK(hpcd); 
 8003ab4:	687b      	ldr	r3, [r7, #4]
 8003ab6:	f893 31e8 	ldrb.w	r3, [r3, #488]	; 0x1e8
 8003aba:	2b01      	cmp	r3, #1
 8003abc:	d102      	bne.n	8003ac4 <HAL_PCD_EP_SetStall+0x1c>
 8003abe:	f04f 0302 	mov.w	r3, #2
 8003ac2:	e0a8      	b.n	8003c16 <HAL_PCD_EP_SetStall+0x16e>
 8003ac4:	687b      	ldr	r3, [r7, #4]
 8003ac6:	f04f 0201 	mov.w	r2, #1
 8003aca:	f883 21e8 	strb.w	r2, [r3, #488]	; 0x1e8
   
  if ((0x80 & ep_addr) == 0x80)
 8003ace:	78fb      	ldrb	r3, [r7, #3]
 8003ad0:	b25b      	sxtb	r3, r3
 8003ad2:	2b00      	cmp	r3, #0
 8003ad4:	da0e      	bge.n	8003af4 <HAL_PCD_EP_SetStall+0x4c>
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8003ad6:	78fb      	ldrb	r3, [r7, #3]
 8003ad8:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8003adc:	4613      	mov	r3, r2
 8003ade:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8003ae2:	1a9b      	subs	r3, r3, r2
 8003ae4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003ae8:	f103 0328 	add.w	r3, r3, #40	; 0x28
 8003aec:	687a      	ldr	r2, [r7, #4]
 8003aee:	18d3      	adds	r3, r2, r3
 8003af0:	60fb      	str	r3, [r7, #12]
 8003af2:	e00b      	b.n	8003b0c <HAL_PCD_EP_SetStall+0x64>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8003af4:	78fa      	ldrb	r2, [r7, #3]
 8003af6:	4613      	mov	r3, r2
 8003af8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8003afc:	1a9b      	subs	r3, r3, r2
 8003afe:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003b02:	f503 7384 	add.w	r3, r3, #264	; 0x108
 8003b06:	687a      	ldr	r2, [r7, #4]
 8003b08:	18d3      	adds	r3, r2, r3
 8003b0a:	60fb      	str	r3, [r7, #12]
  }
  
  ep->is_stall = 1;
 8003b0c:	68fb      	ldr	r3, [r7, #12]
 8003b0e:	f04f 0201 	mov.w	r2, #1
 8003b12:	709a      	strb	r2, [r3, #2]
  ep->num   = ep_addr & 0x7F;
 8003b14:	78fb      	ldrb	r3, [r7, #3]
 8003b16:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8003b1a:	b2da      	uxtb	r2, r3
 8003b1c:	68fb      	ldr	r3, [r7, #12]
 8003b1e:	701a      	strb	r2, [r3, #0]
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 8003b20:	78fb      	ldrb	r3, [r7, #3]
 8003b22:	ea4f 13d3 	mov.w	r3, r3, lsr #7
 8003b26:	b2db      	uxtb	r3, r3
 8003b28:	461a      	mov	r2, r3
 8003b2a:	68fb      	ldr	r3, [r7, #12]
 8003b2c:	705a      	strb	r2, [r3, #1]
  
  if (ep->num == 0)
 8003b2e:	68fb      	ldr	r3, [r7, #12]
 8003b30:	781b      	ldrb	r3, [r3, #0]
 8003b32:	2b00      	cmp	r3, #0
 8003b34:	d121      	bne.n	8003b7a <HAL_PCD_EP_SetStall+0xd2>
  {
    /* This macro sets STALL status for RX & TX*/ 
    PCD_SET_EP_TXRX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_STALL, USB_EP_TX_STALL); 
 8003b36:	687b      	ldr	r3, [r7, #4]
 8003b38:	681b      	ldr	r3, [r3, #0]
 8003b3a:	461a      	mov	r2, r3
 8003b3c:	68fb      	ldr	r3, [r7, #12]
 8003b3e:	781b      	ldrb	r3, [r3, #0]
 8003b40:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003b44:	18d3      	adds	r3, r2, r3
 8003b46:	881b      	ldrh	r3, [r3, #0]
 8003b48:	b29b      	uxth	r3, r3
 8003b4a:	f64b 74bf 	movw	r4, #49087	; 0xbfbf
 8003b4e:	401c      	ands	r4, r3
 8003b50:	f484 5480 	eor.w	r4, r4, #4096	; 0x1000
 8003b54:	f084 0410 	eor.w	r4, r4, #16
 8003b58:	687b      	ldr	r3, [r7, #4]
 8003b5a:	681b      	ldr	r3, [r3, #0]
 8003b5c:	461a      	mov	r2, r3
 8003b5e:	68fb      	ldr	r3, [r7, #12]
 8003b60:	781b      	ldrb	r3, [r3, #0]
 8003b62:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003b66:	18d2      	adds	r2, r2, r3
 8003b68:	b2a1      	uxth	r1, r4
 8003b6a:	f248 0380 	movw	r3, #32896	; 0x8080
 8003b6e:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8003b72:	430b      	orrs	r3, r1
 8003b74:	b29b      	uxth	r3, r3
 8003b76:	8013      	strh	r3, [r2, #0]
 8003b78:	e046      	b.n	8003c08 <HAL_PCD_EP_SetStall+0x160>
  }
  else
  {
    if (ep->is_in)
 8003b7a:	68fb      	ldr	r3, [r7, #12]
 8003b7c:	785b      	ldrb	r3, [r3, #1]
 8003b7e:	2b00      	cmp	r3, #0
 8003b80:	d021      	beq.n	8003bc6 <HAL_PCD_EP_SetStall+0x11e>
    {
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num , USB_EP_TX_STALL); 
 8003b82:	687b      	ldr	r3, [r7, #4]
 8003b84:	681b      	ldr	r3, [r3, #0]
 8003b86:	461a      	mov	r2, r3
 8003b88:	68fb      	ldr	r3, [r7, #12]
 8003b8a:	781b      	ldrb	r3, [r3, #0]
 8003b8c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003b90:	18d3      	adds	r3, r2, r3
 8003b92:	881b      	ldrh	r3, [r3, #0]
 8003b94:	b29b      	uxth	r3, r3
 8003b96:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003b9a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003b9e:	b29c      	uxth	r4, r3
 8003ba0:	f084 0310 	eor.w	r3, r4, #16
 8003ba4:	b29c      	uxth	r4, r3
 8003ba6:	687b      	ldr	r3, [r7, #4]
 8003ba8:	681b      	ldr	r3, [r3, #0]
 8003baa:	461a      	mov	r2, r3
 8003bac:	68fb      	ldr	r3, [r7, #12]
 8003bae:	781b      	ldrb	r3, [r3, #0]
 8003bb0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003bb4:	18d2      	adds	r2, r2, r3
 8003bb6:	f248 0380 	movw	r3, #32896	; 0x8080
 8003bba:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8003bbe:	4323      	orrs	r3, r4
 8003bc0:	b29b      	uxth	r3, r3
 8003bc2:	8013      	strh	r3, [r2, #0]
 8003bc4:	e020      	b.n	8003c08 <HAL_PCD_EP_SetStall+0x160>
    }
    else
    {
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num , USB_EP_RX_STALL);
 8003bc6:	687b      	ldr	r3, [r7, #4]
 8003bc8:	681b      	ldr	r3, [r3, #0]
 8003bca:	461a      	mov	r2, r3
 8003bcc:	68fb      	ldr	r3, [r7, #12]
 8003bce:	781b      	ldrb	r3, [r3, #0]
 8003bd0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003bd4:	18d3      	adds	r3, r2, r3
 8003bd6:	881b      	ldrh	r3, [r3, #0]
 8003bd8:	b29b      	uxth	r3, r3
 8003bda:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8003bde:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003be2:	b29c      	uxth	r4, r3
 8003be4:	f484 5380 	eor.w	r3, r4, #4096	; 0x1000
 8003be8:	b29c      	uxth	r4, r3
 8003bea:	687b      	ldr	r3, [r7, #4]
 8003bec:	681b      	ldr	r3, [r3, #0]
 8003bee:	461a      	mov	r2, r3
 8003bf0:	68fb      	ldr	r3, [r7, #12]
 8003bf2:	781b      	ldrb	r3, [r3, #0]
 8003bf4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003bf8:	18d2      	adds	r2, r2, r3
 8003bfa:	f248 0380 	movw	r3, #32896	; 0x8080
 8003bfe:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8003c02:	4323      	orrs	r3, r4
 8003c04:	b29b      	uxth	r3, r3
 8003c06:	8013      	strh	r3, [r2, #0]
    }
  }
  __HAL_UNLOCK(hpcd); 
 8003c08:	687b      	ldr	r3, [r7, #4]
 8003c0a:	f04f 0200 	mov.w	r2, #0
 8003c0e:	f883 21e8 	strb.w	r2, [r3, #488]	; 0x1e8
  
  return HAL_OK;
 8003c12:	f04f 0300 	mov.w	r3, #0
}
 8003c16:	4618      	mov	r0, r3
 8003c18:	f107 0710 	add.w	r7, r7, #16
 8003c1c:	46bd      	mov	sp, r7
 8003c1e:	bc90      	pop	{r4, r7}
 8003c20:	4770      	bx	lr
 8003c22:	bf00      	nop

08003c24 <HAL_PCD_EP_ClrStall>:
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8003c24:	b490      	push	{r4, r7}
 8003c26:	b084      	sub	sp, #16
 8003c28:	af00      	add	r7, sp, #0
 8003c2a:	6078      	str	r0, [r7, #4]
 8003c2c:	460b      	mov	r3, r1
 8003c2e:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;
  
  if ((0x80 & ep_addr) == 0x80)
 8003c30:	78fb      	ldrb	r3, [r7, #3]
 8003c32:	b25b      	sxtb	r3, r3
 8003c34:	2b00      	cmp	r3, #0
 8003c36:	da0e      	bge.n	8003c56 <HAL_PCD_EP_ClrStall+0x32>
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8003c38:	78fb      	ldrb	r3, [r7, #3]
 8003c3a:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8003c3e:	4613      	mov	r3, r2
 8003c40:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8003c44:	1a9b      	subs	r3, r3, r2
 8003c46:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003c4a:	f103 0328 	add.w	r3, r3, #40	; 0x28
 8003c4e:	687a      	ldr	r2, [r7, #4]
 8003c50:	18d3      	adds	r3, r2, r3
 8003c52:	60fb      	str	r3, [r7, #12]
 8003c54:	e00b      	b.n	8003c6e <HAL_PCD_EP_ClrStall+0x4a>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8003c56:	78fa      	ldrb	r2, [r7, #3]
 8003c58:	4613      	mov	r3, r2
 8003c5a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8003c5e:	1a9b      	subs	r3, r3, r2
 8003c60:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003c64:	f503 7384 	add.w	r3, r3, #264	; 0x108
 8003c68:	687a      	ldr	r2, [r7, #4]
 8003c6a:	18d3      	adds	r3, r2, r3
 8003c6c:	60fb      	str	r3, [r7, #12]
  }
  
  ep->is_stall = 0;
 8003c6e:	68fb      	ldr	r3, [r7, #12]
 8003c70:	f04f 0200 	mov.w	r2, #0
 8003c74:	709a      	strb	r2, [r3, #2]
  ep->num   = ep_addr & 0x7F;
 8003c76:	78fb      	ldrb	r3, [r7, #3]
 8003c78:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8003c7c:	b2da      	uxtb	r2, r3
 8003c7e:	68fb      	ldr	r3, [r7, #12]
 8003c80:	701a      	strb	r2, [r3, #0]
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 8003c82:	78fb      	ldrb	r3, [r7, #3]
 8003c84:	ea4f 13d3 	mov.w	r3, r3, lsr #7
 8003c88:	b2db      	uxtb	r3, r3
 8003c8a:	461a      	mov	r2, r3
 8003c8c:	68fb      	ldr	r3, [r7, #12]
 8003c8e:	705a      	strb	r2, [r3, #1]
  
  __HAL_LOCK(hpcd); 
 8003c90:	687b      	ldr	r3, [r7, #4]
 8003c92:	f893 31e8 	ldrb.w	r3, [r3, #488]	; 0x1e8
 8003c96:	2b01      	cmp	r3, #1
 8003c98:	d102      	bne.n	8003ca0 <HAL_PCD_EP_ClrStall+0x7c>
 8003c9a:	f04f 0302 	mov.w	r3, #2
 8003c9e:	e0b8      	b.n	8003e12 <HAL_PCD_EP_ClrStall+0x1ee>
 8003ca0:	687b      	ldr	r3, [r7, #4]
 8003ca2:	f04f 0201 	mov.w	r2, #1
 8003ca6:	f883 21e8 	strb.w	r2, [r3, #488]	; 0x1e8
  
  if (ep->is_in)
 8003caa:	68fb      	ldr	r3, [r7, #12]
 8003cac:	785b      	ldrb	r3, [r3, #1]
 8003cae:	2b00      	cmp	r3, #0
 8003cb0:	d054      	beq.n	8003d5c <HAL_PCD_EP_ClrStall+0x138>
  {
    PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num);
 8003cb2:	687b      	ldr	r3, [r7, #4]
 8003cb4:	681b      	ldr	r3, [r3, #0]
 8003cb6:	461a      	mov	r2, r3
 8003cb8:	68fb      	ldr	r3, [r7, #12]
 8003cba:	781b      	ldrb	r3, [r3, #0]
 8003cbc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003cc0:	18d3      	adds	r3, r2, r3
 8003cc2:	881b      	ldrh	r3, [r3, #0]
 8003cc4:	b29b      	uxth	r3, r3
 8003cc6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8003cca:	2b00      	cmp	r3, #0
 8003ccc:	bf0c      	ite	eq
 8003cce:	2300      	moveq	r3, #0
 8003cd0:	2301      	movne	r3, #1
 8003cd2:	b2db      	uxtb	r3, r3
 8003cd4:	2b00      	cmp	r3, #0
 8003cd6:	d01c      	beq.n	8003d12 <HAL_PCD_EP_ClrStall+0xee>
 8003cd8:	687b      	ldr	r3, [r7, #4]
 8003cda:	681b      	ldr	r3, [r3, #0]
 8003cdc:	461a      	mov	r2, r3
 8003cde:	68fb      	ldr	r3, [r7, #12]
 8003ce0:	781b      	ldrb	r3, [r3, #0]
 8003ce2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003ce6:	18d2      	adds	r2, r2, r3
 8003ce8:	687b      	ldr	r3, [r7, #4]
 8003cea:	681b      	ldr	r3, [r3, #0]
 8003cec:	4619      	mov	r1, r3
 8003cee:	68fb      	ldr	r3, [r7, #12]
 8003cf0:	781b      	ldrb	r3, [r3, #0]
 8003cf2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003cf6:	18cb      	adds	r3, r1, r3
 8003cf8:	881b      	ldrh	r3, [r3, #0]
 8003cfa:	b299      	uxth	r1, r3
 8003cfc:	f640 730f 	movw	r3, #3855	; 0xf0f
 8003d00:	400b      	ands	r3, r1
 8003d02:	b299      	uxth	r1, r3
 8003d04:	f248 03c0 	movw	r3, #32960	; 0x80c0
 8003d08:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8003d0c:	430b      	orrs	r3, r1
 8003d0e:	b29b      	uxth	r3, r3
 8003d10:	8013      	strh	r3, [r2, #0]
    PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_VALID);
 8003d12:	687b      	ldr	r3, [r7, #4]
 8003d14:	681b      	ldr	r3, [r3, #0]
 8003d16:	461a      	mov	r2, r3
 8003d18:	68fb      	ldr	r3, [r7, #12]
 8003d1a:	781b      	ldrb	r3, [r3, #0]
 8003d1c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003d20:	18d3      	adds	r3, r2, r3
 8003d22:	881b      	ldrh	r3, [r3, #0]
 8003d24:	b29b      	uxth	r3, r3
 8003d26:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003d2a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003d2e:	b29c      	uxth	r4, r3
 8003d30:	f084 0310 	eor.w	r3, r4, #16
 8003d34:	b29c      	uxth	r4, r3
 8003d36:	f084 0320 	eor.w	r3, r4, #32
 8003d3a:	b29c      	uxth	r4, r3
 8003d3c:	687b      	ldr	r3, [r7, #4]
 8003d3e:	681b      	ldr	r3, [r3, #0]
 8003d40:	461a      	mov	r2, r3
 8003d42:	68fb      	ldr	r3, [r7, #12]
 8003d44:	781b      	ldrb	r3, [r3, #0]
 8003d46:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003d4a:	18d2      	adds	r2, r2, r3
 8003d4c:	f248 0380 	movw	r3, #32896	; 0x8080
 8003d50:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8003d54:	4323      	orrs	r3, r4
 8003d56:	b29b      	uxth	r3, r3
 8003d58:	8013      	strh	r3, [r2, #0]
 8003d5a:	e053      	b.n	8003e04 <HAL_PCD_EP_ClrStall+0x1e0>
  }
  else
  {
    PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num);
 8003d5c:	687b      	ldr	r3, [r7, #4]
 8003d5e:	681b      	ldr	r3, [r3, #0]
 8003d60:	461a      	mov	r2, r3
 8003d62:	68fb      	ldr	r3, [r7, #12]
 8003d64:	781b      	ldrb	r3, [r3, #0]
 8003d66:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003d6a:	18d3      	adds	r3, r2, r3
 8003d6c:	881b      	ldrh	r3, [r3, #0]
 8003d6e:	b29b      	uxth	r3, r3
 8003d70:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8003d74:	2b00      	cmp	r3, #0
 8003d76:	bf0c      	ite	eq
 8003d78:	2300      	moveq	r3, #0
 8003d7a:	2301      	movne	r3, #1
 8003d7c:	b2db      	uxtb	r3, r3
 8003d7e:	2b00      	cmp	r3, #0
 8003d80:	d01c      	beq.n	8003dbc <HAL_PCD_EP_ClrStall+0x198>
 8003d82:	687b      	ldr	r3, [r7, #4]
 8003d84:	681b      	ldr	r3, [r3, #0]
 8003d86:	461a      	mov	r2, r3
 8003d88:	68fb      	ldr	r3, [r7, #12]
 8003d8a:	781b      	ldrb	r3, [r3, #0]
 8003d8c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003d90:	18d2      	adds	r2, r2, r3
 8003d92:	687b      	ldr	r3, [r7, #4]
 8003d94:	681b      	ldr	r3, [r3, #0]
 8003d96:	4619      	mov	r1, r3
 8003d98:	68fb      	ldr	r3, [r7, #12]
 8003d9a:	781b      	ldrb	r3, [r3, #0]
 8003d9c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003da0:	18cb      	adds	r3, r1, r3
 8003da2:	881b      	ldrh	r3, [r3, #0]
 8003da4:	b299      	uxth	r1, r3
 8003da6:	f640 730f 	movw	r3, #3855	; 0xf0f
 8003daa:	400b      	ands	r3, r1
 8003dac:	b299      	uxth	r1, r3
 8003dae:	f24c 0380 	movw	r3, #49280	; 0xc080
 8003db2:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8003db6:	430b      	orrs	r3, r1
 8003db8:	b29b      	uxth	r3, r3
 8003dba:	8013      	strh	r3, [r2, #0]
    PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID);
 8003dbc:	687b      	ldr	r3, [r7, #4]
 8003dbe:	681b      	ldr	r3, [r3, #0]
 8003dc0:	461a      	mov	r2, r3
 8003dc2:	68fb      	ldr	r3, [r7, #12]
 8003dc4:	781b      	ldrb	r3, [r3, #0]
 8003dc6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003dca:	18d3      	adds	r3, r2, r3
 8003dcc:	881b      	ldrh	r3, [r3, #0]
 8003dce:	b29b      	uxth	r3, r3
 8003dd0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8003dd4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003dd8:	b29c      	uxth	r4, r3
 8003dda:	f484 5380 	eor.w	r3, r4, #4096	; 0x1000
 8003dde:	b29c      	uxth	r4, r3
 8003de0:	f484 5300 	eor.w	r3, r4, #8192	; 0x2000
 8003de4:	b29c      	uxth	r4, r3
 8003de6:	687b      	ldr	r3, [r7, #4]
 8003de8:	681b      	ldr	r3, [r3, #0]
 8003dea:	461a      	mov	r2, r3
 8003dec:	68fb      	ldr	r3, [r7, #12]
 8003dee:	781b      	ldrb	r3, [r3, #0]
 8003df0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003df4:	18d2      	adds	r2, r2, r3
 8003df6:	f248 0380 	movw	r3, #32896	; 0x8080
 8003dfa:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8003dfe:	4323      	orrs	r3, r4
 8003e00:	b29b      	uxth	r3, r3
 8003e02:	8013      	strh	r3, [r2, #0]
  }
  __HAL_UNLOCK(hpcd); 
 8003e04:	687b      	ldr	r3, [r7, #4]
 8003e06:	f04f 0200 	mov.w	r2, #0
 8003e0a:	f883 21e8 	strb.w	r2, [r3, #488]	; 0x1e8
    
  return HAL_OK;
 8003e0e:	f04f 0300 	mov.w	r3, #0
}
 8003e12:	4618      	mov	r0, r3
 8003e14:	f107 0710 	add.w	r7, r7, #16
 8003e18:	46bd      	mov	sp, r7
 8003e1a:	bc90      	pop	{r4, r7}
 8003e1c:	4770      	bx	lr
 8003e1e:	bf00      	nop

08003e20 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)>:
  * @brief  This function handles PCD Endpoint interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_ISR_Handler(PCD_HandleTypeDef *hpcd)
{
 8003e20:	b590      	push	{r4, r7, lr}
 8003e22:	b089      	sub	sp, #36	; 0x24
 8003e24:	af00      	add	r7, sp, #0
 8003e26:	6078      	str	r0, [r7, #4]
  PCD_EPTypeDef *ep;
  uint16_t count=0;
 8003e28:	f04f 0300 	mov.w	r3, #0
 8003e2c:	83fb      	strh	r3, [r7, #30]
  uint8_t EPindex;
  __IO uint16_t wIstr;  
  __IO uint16_t wEPVal = 0;
 8003e2e:	f04f 0300 	mov.w	r3, #0
 8003e32:	81bb      	strh	r3, [r7, #12]
  
  /* stay in loop while pending interrupts */
  while (((wIstr = hpcd->Instance->ISTR) & USB_ISTR_CTR) != 0)
 8003e34:	e390      	b.n	8004558 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x738>
  {
    /* extract highest priority endpoint number */
    EPindex = (uint8_t)(wIstr & USB_ISTR_EP_ID);
 8003e36:	89fb      	ldrh	r3, [r7, #14]
 8003e38:	b29b      	uxth	r3, r3
 8003e3a:	b2db      	uxtb	r3, r3
 8003e3c:	f003 030f 	and.w	r3, r3, #15
 8003e40:	76fb      	strb	r3, [r7, #27]
    
    if (EPindex == 0)
 8003e42:	7efb      	ldrb	r3, [r7, #27]
 8003e44:	2b00      	cmp	r3, #0
 8003e46:	f040 815e 	bne.w	8004106 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x2e6>
    {
      /* Decode and service control endpoint interrupt */
      
      /* DIR bit = origin of the interrupt */   
      if ((wIstr & USB_ISTR_DIR) == 0)
 8003e4a:	89fb      	ldrh	r3, [r7, #14]
 8003e4c:	b29b      	uxth	r3, r3
 8003e4e:	f003 0310 	and.w	r3, r3, #16
 8003e52:	2b00      	cmp	r3, #0
 8003e54:	bf14      	ite	ne
 8003e56:	2300      	movne	r3, #0
 8003e58:	2301      	moveq	r3, #1
 8003e5a:	b2db      	uxtb	r3, r3
 8003e5c:	2b00      	cmp	r3, #0
 8003e5e:	d05b      	beq.n	8003f18 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0xf8>
      {
        /* DIR = 0 */
        
        /* DIR = 0      => IN  int */
        /* DIR = 0 implies that (EP_CTR_TX = 1) always  */
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 8003e60:	687b      	ldr	r3, [r7, #4]
 8003e62:	681a      	ldr	r2, [r3, #0]
 8003e64:	687b      	ldr	r3, [r7, #4]
 8003e66:	681b      	ldr	r3, [r3, #0]
 8003e68:	881b      	ldrh	r3, [r3, #0]
 8003e6a:	b29b      	uxth	r3, r3
 8003e6c:	f423 43e1 	bic.w	r3, r3, #28800	; 0x7080
 8003e70:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003e74:	b29b      	uxth	r3, r3
 8003e76:	8013      	strh	r3, [r2, #0]
        ep = &hpcd->IN_ep[0];
 8003e78:	687b      	ldr	r3, [r7, #4]
 8003e7a:	f103 0328 	add.w	r3, r3, #40	; 0x28
 8003e7e:	617b      	str	r3, [r7, #20]
        
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 8003e80:	687b      	ldr	r3, [r7, #4]
 8003e82:	681b      	ldr	r3, [r3, #0]
 8003e84:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8003e88:	b29b      	uxth	r3, r3
 8003e8a:	461a      	mov	r2, r3
 8003e8c:	697b      	ldr	r3, [r7, #20]
 8003e8e:	781b      	ldrb	r3, [r3, #0]
 8003e90:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8003e94:	18d3      	adds	r3, r2, r3
 8003e96:	f103 0302 	add.w	r3, r3, #2
 8003e9a:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8003e9e:	461a      	mov	r2, r3
 8003ea0:	687b      	ldr	r3, [r7, #4]
 8003ea2:	681b      	ldr	r3, [r3, #0]
 8003ea4:	18d3      	adds	r3, r2, r3
 8003ea6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8003eaa:	681b      	ldr	r3, [r3, #0]
 8003eac:	b29b      	uxth	r3, r3
 8003eae:	ea4f 5383 	mov.w	r3, r3, lsl #22
 8003eb2:	ea4f 5393 	mov.w	r3, r3, lsr #22
 8003eb6:	697a      	ldr	r2, [r7, #20]
 8003eb8:	6193      	str	r3, [r2, #24]
        ep->xfer_buff += ep->xfer_count;
 8003eba:	697b      	ldr	r3, [r7, #20]
 8003ebc:	691a      	ldr	r2, [r3, #16]
 8003ebe:	697b      	ldr	r3, [r7, #20]
 8003ec0:	699b      	ldr	r3, [r3, #24]
 8003ec2:	18d2      	adds	r2, r2, r3
 8003ec4:	697b      	ldr	r3, [r7, #20]
 8003ec6:	611a      	str	r2, [r3, #16]
 
        /* TX COMPLETE */
        HAL_PCD_DataInStageCallback(hpcd, 0);
 8003ec8:	6878      	ldr	r0, [r7, #4]
 8003eca:	f04f 0100 	mov.w	r1, #0
 8003ece:	f7fc fb2d 	bl	800052c <HAL_PCD_DataInStageCallback>
        
        
        if((hpcd->USB_Address > 0)&& ( ep->xfer_len == 0))
 8003ed2:	687b      	ldr	r3, [r7, #4]
 8003ed4:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8003ed8:	b2db      	uxtb	r3, r3
 8003eda:	2b00      	cmp	r3, #0
 8003edc:	d006      	beq.n	8003eec <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0xcc>
 8003ede:	697b      	ldr	r3, [r7, #20]
 8003ee0:	695b      	ldr	r3, [r3, #20]
 8003ee2:	2b00      	cmp	r3, #0
 8003ee4:	d102      	bne.n	8003eec <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0xcc>
 8003ee6:	f04f 0301 	mov.w	r3, #1
 8003eea:	e001      	b.n	8003ef0 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0xd0>
 8003eec:	f04f 0300 	mov.w	r3, #0
 8003ef0:	2b00      	cmp	r3, #0
 8003ef2:	f000 8331 	beq.w	8004558 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x738>
        {
          hpcd->Instance->DADDR = (hpcd->USB_Address | USB_DADDR_EF);
 8003ef6:	687b      	ldr	r3, [r7, #4]
 8003ef8:	681b      	ldr	r3, [r3, #0]
 8003efa:	687a      	ldr	r2, [r7, #4]
 8003efc:	f892 2024 	ldrb.w	r2, [r2, #36]	; 0x24
 8003f00:	b2d2      	uxtb	r2, r2
 8003f02:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8003f06:	b2d2      	uxtb	r2, r2
 8003f08:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
          hpcd->USB_Address = 0;
 8003f0c:	687b      	ldr	r3, [r7, #4]
 8003f0e:	f04f 0200 	mov.w	r2, #0
 8003f12:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 8003f16:	e31f      	b.n	8004558 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x738>
      {
        /* DIR = 1 */
        
        /* DIR = 1 & CTR_RX       => SETUP or OUT int */
        /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */
        ep = &hpcd->OUT_ep[0];
 8003f18:	687b      	ldr	r3, [r7, #4]
 8003f1a:	f503 7384 	add.w	r3, r3, #264	; 0x108
 8003f1e:	617b      	str	r3, [r7, #20]
        wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0);
 8003f20:	687b      	ldr	r3, [r7, #4]
 8003f22:	681b      	ldr	r3, [r3, #0]
 8003f24:	881b      	ldrh	r3, [r3, #0]
 8003f26:	b29b      	uxth	r3, r3
 8003f28:	81bb      	strh	r3, [r7, #12]
        
        if ((wEPVal & USB_EP_SETUP) != 0)
 8003f2a:	89bb      	ldrh	r3, [r7, #12]
 8003f2c:	b29b      	uxth	r3, r3
 8003f2e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8003f32:	2b00      	cmp	r3, #0
 8003f34:	bf0c      	ite	eq
 8003f36:	2300      	moveq	r3, #0
 8003f38:	2301      	movne	r3, #1
 8003f3a:	b2db      	uxtb	r3, r3
 8003f3c:	2b00      	cmp	r3, #0
 8003f3e:	d037      	beq.n	8003fb0 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x190>
        {
          /* Get SETUP Packet*/
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 8003f40:	687b      	ldr	r3, [r7, #4]
 8003f42:	681b      	ldr	r3, [r3, #0]
 8003f44:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8003f48:	b29b      	uxth	r3, r3
 8003f4a:	461a      	mov	r2, r3
 8003f4c:	697b      	ldr	r3, [r7, #20]
 8003f4e:	781b      	ldrb	r3, [r3, #0]
 8003f50:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8003f54:	18d3      	adds	r3, r2, r3
 8003f56:	f103 0306 	add.w	r3, r3, #6
 8003f5a:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8003f5e:	461a      	mov	r2, r3
 8003f60:	687b      	ldr	r3, [r7, #4]
 8003f62:	681b      	ldr	r3, [r3, #0]
 8003f64:	18d3      	adds	r3, r2, r3
 8003f66:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8003f6a:	681b      	ldr	r3, [r3, #0]
 8003f6c:	b29b      	uxth	r3, r3
 8003f6e:	ea4f 5383 	mov.w	r3, r3, lsl #22
 8003f72:	ea4f 5393 	mov.w	r3, r3, lsr #22
 8003f76:	697a      	ldr	r2, [r7, #20]
 8003f78:	6193      	str	r3, [r2, #24]
          PCD_ReadPMA(hpcd->Instance, (uint8_t*)hpcd->Setup ,ep->pmaadress , ep->xfer_count);       
 8003f7a:	687b      	ldr	r3, [r7, #4]
 8003f7c:	6818      	ldr	r0, [r3, #0]
 8003f7e:	687b      	ldr	r3, [r7, #4]
 8003f80:	f503 71f6 	add.w	r1, r3, #492	; 0x1ec
 8003f84:	697b      	ldr	r3, [r7, #20]
 8003f86:	889a      	ldrh	r2, [r3, #4]
 8003f88:	697b      	ldr	r3, [r7, #20]
 8003f8a:	699b      	ldr	r3, [r3, #24]
 8003f8c:	b29b      	uxth	r3, r3
 8003f8e:	f000 fb43 	bl	8004618 <PCD_ReadPMA(USB_TypeDef*, unsigned char*, unsigned short, unsigned short)>
          /* SETUP bit kept frozen while CTR_RX = 1*/ 
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0); 
 8003f92:	687b      	ldr	r3, [r7, #4]
 8003f94:	681a      	ldr	r2, [r3, #0]
 8003f96:	687b      	ldr	r3, [r7, #4]
 8003f98:	681b      	ldr	r3, [r3, #0]
 8003f9a:	881b      	ldrh	r3, [r3, #0]
 8003f9c:	b299      	uxth	r1, r3
 8003f9e:	f640 738f 	movw	r3, #3983	; 0xf8f
 8003fa2:	400b      	ands	r3, r1
 8003fa4:	b29b      	uxth	r3, r3
 8003fa6:	8013      	strh	r3, [r2, #0]
          
          /* Process SETUP Packet*/
          HAL_PCD_SetupStageCallback(hpcd);
 8003fa8:	6878      	ldr	r0, [r7, #4]
 8003faa:	f7fc fa8d 	bl	80004c8 <HAL_PCD_SetupStageCallback>
 8003fae:	e2d3      	b.n	8004558 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x738>
        }
        
        else if ((wEPVal & USB_EP_CTR_RX) != 0)
 8003fb0:	89bb      	ldrh	r3, [r7, #12]
 8003fb2:	b29b      	uxth	r3, r3
 8003fb4:	b29b      	uxth	r3, r3
 8003fb6:	ea4f 33d3 	mov.w	r3, r3, lsr #15
 8003fba:	b2db      	uxtb	r3, r3
 8003fbc:	2b00      	cmp	r3, #0
 8003fbe:	f000 82cb 	beq.w	8004558 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x738>
        {
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 8003fc2:	687b      	ldr	r3, [r7, #4]
 8003fc4:	681a      	ldr	r2, [r3, #0]
 8003fc6:	687b      	ldr	r3, [r7, #4]
 8003fc8:	681b      	ldr	r3, [r3, #0]
 8003fca:	881b      	ldrh	r3, [r3, #0]
 8003fcc:	b299      	uxth	r1, r3
 8003fce:	f640 738f 	movw	r3, #3983	; 0xf8f
 8003fd2:	400b      	ands	r3, r1
 8003fd4:	b29b      	uxth	r3, r3
 8003fd6:	8013      	strh	r3, [r2, #0]
          /* Get Control Data OUT Packet*/
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 8003fd8:	687b      	ldr	r3, [r7, #4]
 8003fda:	681b      	ldr	r3, [r3, #0]
 8003fdc:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8003fe0:	b29b      	uxth	r3, r3
 8003fe2:	461a      	mov	r2, r3
 8003fe4:	697b      	ldr	r3, [r7, #20]
 8003fe6:	781b      	ldrb	r3, [r3, #0]
 8003fe8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8003fec:	18d3      	adds	r3, r2, r3
 8003fee:	f103 0306 	add.w	r3, r3, #6
 8003ff2:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8003ff6:	461a      	mov	r2, r3
 8003ff8:	687b      	ldr	r3, [r7, #4]
 8003ffa:	681b      	ldr	r3, [r3, #0]
 8003ffc:	18d3      	adds	r3, r2, r3
 8003ffe:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8004002:	681b      	ldr	r3, [r3, #0]
 8004004:	b29b      	uxth	r3, r3
 8004006:	ea4f 5383 	mov.w	r3, r3, lsl #22
 800400a:	ea4f 5393 	mov.w	r3, r3, lsr #22
 800400e:	697a      	ldr	r2, [r7, #20]
 8004010:	6193      	str	r3, [r2, #24]
          
          if (ep->xfer_count != 0)
 8004012:	697b      	ldr	r3, [r7, #20]
 8004014:	699b      	ldr	r3, [r3, #24]
 8004016:	2b00      	cmp	r3, #0
 8004018:	d011      	beq.n	800403e <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x21e>
          {
            PCD_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, ep->xfer_count);
 800401a:	687b      	ldr	r3, [r7, #4]
 800401c:	6818      	ldr	r0, [r3, #0]
 800401e:	697b      	ldr	r3, [r7, #20]
 8004020:	6919      	ldr	r1, [r3, #16]
 8004022:	697b      	ldr	r3, [r7, #20]
 8004024:	889a      	ldrh	r2, [r3, #4]
 8004026:	697b      	ldr	r3, [r7, #20]
 8004028:	699b      	ldr	r3, [r3, #24]
 800402a:	b29b      	uxth	r3, r3
 800402c:	f000 faf4 	bl	8004618 <PCD_ReadPMA(USB_TypeDef*, unsigned char*, unsigned short, unsigned short)>
            ep->xfer_buff+=ep->xfer_count;
 8004030:	697b      	ldr	r3, [r7, #20]
 8004032:	691a      	ldr	r2, [r3, #16]
 8004034:	697b      	ldr	r3, [r7, #20]
 8004036:	699b      	ldr	r3, [r3, #24]
 8004038:	18d2      	adds	r2, r2, r3
 800403a:	697b      	ldr	r3, [r7, #20]
 800403c:	611a      	str	r2, [r3, #16]
          }
          
          /* Process Control Data OUT Packet*/
           HAL_PCD_DataOutStageCallback(hpcd, 0);
 800403e:	6878      	ldr	r0, [r7, #4]
 8004040:	f04f 0100 	mov.w	r1, #0
 8004044:	f7fc fa52 	bl	80004ec <HAL_PCD_DataOutStageCallback>
          
          PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket);
 8004048:	687b      	ldr	r3, [r7, #4]
 800404a:	681b      	ldr	r3, [r3, #0]
 800404c:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8004050:	b29b      	uxth	r3, r3
 8004052:	f103 0306 	add.w	r3, r3, #6
 8004056:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800405a:	461a      	mov	r2, r3
 800405c:	687b      	ldr	r3, [r7, #4]
 800405e:	681b      	ldr	r3, [r3, #0]
 8004060:	18d3      	adds	r3, r2, r3
 8004062:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8004066:	613b      	str	r3, [r7, #16]
 8004068:	697b      	ldr	r3, [r7, #20]
 800406a:	68db      	ldr	r3, [r3, #12]
 800406c:	2b3e      	cmp	r3, #62	; 0x3e
 800406e:	d91b      	bls.n	80040a8 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x288>
 8004070:	697b      	ldr	r3, [r7, #20]
 8004072:	68db      	ldr	r3, [r3, #12]
 8004074:	ea4f 1353 	mov.w	r3, r3, lsr #5
 8004078:	83bb      	strh	r3, [r7, #28]
 800407a:	697b      	ldr	r3, [r7, #20]
 800407c:	68db      	ldr	r3, [r3, #12]
 800407e:	f003 031f 	and.w	r3, r3, #31
 8004082:	2b00      	cmp	r3, #0
 8004084:	d103      	bne.n	800408e <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x26e>
 8004086:	8bbb      	ldrh	r3, [r7, #28]
 8004088:	f103 33ff 	add.w	r3, r3, #4294967295
 800408c:	83bb      	strh	r3, [r7, #28]
 800408e:	8bbb      	ldrh	r3, [r7, #28]
 8004090:	ea4f 2383 	mov.w	r3, r3, lsl #10
 8004094:	b29b      	uxth	r3, r3
 8004096:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800409a:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800409e:	b29b      	uxth	r3, r3
 80040a0:	461a      	mov	r2, r3
 80040a2:	693b      	ldr	r3, [r7, #16]
 80040a4:	601a      	str	r2, [r3, #0]
 80040a6:	e015      	b.n	80040d4 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x2b4>
 80040a8:	697b      	ldr	r3, [r7, #20]
 80040aa:	68db      	ldr	r3, [r3, #12]
 80040ac:	ea4f 0353 	mov.w	r3, r3, lsr #1
 80040b0:	83bb      	strh	r3, [r7, #28]
 80040b2:	697b      	ldr	r3, [r7, #20]
 80040b4:	68db      	ldr	r3, [r3, #12]
 80040b6:	f003 0301 	and.w	r3, r3, #1
 80040ba:	2b00      	cmp	r3, #0
 80040bc:	d003      	beq.n	80040c6 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x2a6>
 80040be:	8bbb      	ldrh	r3, [r7, #28]
 80040c0:	f103 0301 	add.w	r3, r3, #1
 80040c4:	83bb      	strh	r3, [r7, #28]
 80040c6:	8bbb      	ldrh	r3, [r7, #28]
 80040c8:	ea4f 2383 	mov.w	r3, r3, lsl #10
 80040cc:	b29b      	uxth	r3, r3
 80040ce:	461a      	mov	r2, r3
 80040d0:	693b      	ldr	r3, [r7, #16]
 80040d2:	601a      	str	r2, [r3, #0]
          PCD_SET_EP_RX_STATUS(hpcd->Instance, PCD_ENDP0, USB_EP_RX_VALID);
 80040d4:	687b      	ldr	r3, [r7, #4]
 80040d6:	681b      	ldr	r3, [r3, #0]
 80040d8:	881b      	ldrh	r3, [r3, #0]
 80040da:	b29b      	uxth	r3, r3
 80040dc:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80040e0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80040e4:	b29c      	uxth	r4, r3
 80040e6:	f484 5380 	eor.w	r3, r4, #4096	; 0x1000
 80040ea:	b29c      	uxth	r4, r3
 80040ec:	f484 5300 	eor.w	r3, r4, #8192	; 0x2000
 80040f0:	b29c      	uxth	r4, r3
 80040f2:	687b      	ldr	r3, [r7, #4]
 80040f4:	681a      	ldr	r2, [r3, #0]
 80040f6:	f248 0380 	movw	r3, #32896	; 0x8080
 80040fa:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 80040fe:	4323      	orrs	r3, r4
 8004100:	b29b      	uxth	r3, r3
 8004102:	8013      	strh	r3, [r2, #0]
 8004104:	e228      	b.n	8004558 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x738>
    {
      
      /* Decode and service non control endpoints interrupt  */
      
      /* process related endpoint register */
      wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, EPindex);
 8004106:	687b      	ldr	r3, [r7, #4]
 8004108:	681b      	ldr	r3, [r3, #0]
 800410a:	461a      	mov	r2, r3
 800410c:	7efb      	ldrb	r3, [r7, #27]
 800410e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004112:	18d3      	adds	r3, r2, r3
 8004114:	881b      	ldrh	r3, [r3, #0]
 8004116:	b29b      	uxth	r3, r3
 8004118:	81bb      	strh	r3, [r7, #12]
      if ((wEPVal & USB_EP_CTR_RX) != 0)
 800411a:	89bb      	ldrh	r3, [r7, #12]
 800411c:	b29b      	uxth	r3, r3
 800411e:	b29b      	uxth	r3, r3
 8004120:	ea4f 33d3 	mov.w	r3, r3, lsr #15
 8004124:	b2db      	uxtb	r3, r3
 8004126:	2b00      	cmp	r3, #0
 8004128:	f000 80f5 	beq.w	8004316 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x4f6>
      {  
        /* clear int flag */
        PCD_CLEAR_RX_EP_CTR(hpcd->Instance, EPindex);
 800412c:	687b      	ldr	r3, [r7, #4]
 800412e:	681b      	ldr	r3, [r3, #0]
 8004130:	461a      	mov	r2, r3
 8004132:	7efb      	ldrb	r3, [r7, #27]
 8004134:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004138:	18d2      	adds	r2, r2, r3
 800413a:	687b      	ldr	r3, [r7, #4]
 800413c:	681b      	ldr	r3, [r3, #0]
 800413e:	4619      	mov	r1, r3
 8004140:	7efb      	ldrb	r3, [r7, #27]
 8004142:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004146:	18cb      	adds	r3, r1, r3
 8004148:	881b      	ldrh	r3, [r3, #0]
 800414a:	b299      	uxth	r1, r3
 800414c:	f640 738f 	movw	r3, #3983	; 0xf8f
 8004150:	400b      	ands	r3, r1
 8004152:	b29b      	uxth	r3, r3
 8004154:	8013      	strh	r3, [r2, #0]
        ep = &hpcd->OUT_ep[EPindex];
 8004156:	7efa      	ldrb	r2, [r7, #27]
 8004158:	4613      	mov	r3, r2
 800415a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800415e:	1a9b      	subs	r3, r3, r2
 8004160:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004164:	f503 7384 	add.w	r3, r3, #264	; 0x108
 8004168:	687a      	ldr	r2, [r7, #4]
 800416a:	18d3      	adds	r3, r2, r3
 800416c:	617b      	str	r3, [r7, #20]
        
        /* OUT double Buffering*/
        if (ep->doublebuffer == 0)
 800416e:	697b      	ldr	r3, [r7, #20]
 8004170:	7a9b      	ldrb	r3, [r3, #10]
 8004172:	2b00      	cmp	r3, #0
 8004174:	d129      	bne.n	80041ca <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x3aa>
        {
          count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 8004176:	687b      	ldr	r3, [r7, #4]
 8004178:	681b      	ldr	r3, [r3, #0]
 800417a:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800417e:	b29b      	uxth	r3, r3
 8004180:	461a      	mov	r2, r3
 8004182:	697b      	ldr	r3, [r7, #20]
 8004184:	781b      	ldrb	r3, [r3, #0]
 8004186:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800418a:	18d3      	adds	r3, r2, r3
 800418c:	f103 0306 	add.w	r3, r3, #6
 8004190:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8004194:	461a      	mov	r2, r3
 8004196:	687b      	ldr	r3, [r7, #4]
 8004198:	681b      	ldr	r3, [r3, #0]
 800419a:	18d3      	adds	r3, r2, r3
 800419c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80041a0:	681b      	ldr	r3, [r3, #0]
 80041a2:	b29b      	uxth	r3, r3
 80041a4:	ea4f 5383 	mov.w	r3, r3, lsl #22
 80041a8:	ea4f 5393 	mov.w	r3, r3, lsr #22
 80041ac:	83fb      	strh	r3, [r7, #30]
          if (count != 0)
 80041ae:	8bfb      	ldrh	r3, [r7, #30]
 80041b0:	2b00      	cmp	r3, #0
 80041b2:	f000 808b 	beq.w	80042cc <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x4ac>
          {
            PCD_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, count);
 80041b6:	687b      	ldr	r3, [r7, #4]
 80041b8:	6818      	ldr	r0, [r3, #0]
 80041ba:	697b      	ldr	r3, [r7, #20]
 80041bc:	6919      	ldr	r1, [r3, #16]
 80041be:	697b      	ldr	r3, [r7, #20]
 80041c0:	889a      	ldrh	r2, [r3, #4]
 80041c2:	8bfb      	ldrh	r3, [r7, #30]
 80041c4:	f000 fa28 	bl	8004618 <PCD_ReadPMA(USB_TypeDef*, unsigned char*, unsigned short, unsigned short)>
 80041c8:	e080      	b.n	80042cc <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x4ac>
          }
        }
        else
        {
          if (PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_RX)
 80041ca:	687b      	ldr	r3, [r7, #4]
 80041cc:	681b      	ldr	r3, [r3, #0]
 80041ce:	461a      	mov	r2, r3
 80041d0:	697b      	ldr	r3, [r7, #20]
 80041d2:	781b      	ldrb	r3, [r3, #0]
 80041d4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80041d8:	18d3      	adds	r3, r2, r3
 80041da:	881b      	ldrh	r3, [r3, #0]
 80041dc:	b29b      	uxth	r3, r3
 80041de:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80041e2:	2b00      	cmp	r3, #0
 80041e4:	bf0c      	ite	eq
 80041e6:	2300      	moveq	r3, #0
 80041e8:	2301      	movne	r3, #1
 80041ea:	b2db      	uxtb	r3, r3
 80041ec:	2b00      	cmp	r3, #0
 80041ee:	d028      	beq.n	8004242 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x422>
          {
            /*read from endpoint BUF0Addr buffer*/
            count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 80041f0:	687b      	ldr	r3, [r7, #4]
 80041f2:	681b      	ldr	r3, [r3, #0]
 80041f4:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80041f8:	b29b      	uxth	r3, r3
 80041fa:	461a      	mov	r2, r3
 80041fc:	697b      	ldr	r3, [r7, #20]
 80041fe:	781b      	ldrb	r3, [r3, #0]
 8004200:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8004204:	18d3      	adds	r3, r2, r3
 8004206:	f103 0302 	add.w	r3, r3, #2
 800420a:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800420e:	461a      	mov	r2, r3
 8004210:	687b      	ldr	r3, [r7, #4]
 8004212:	681b      	ldr	r3, [r3, #0]
 8004214:	18d3      	adds	r3, r2, r3
 8004216:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800421a:	681b      	ldr	r3, [r3, #0]
 800421c:	b29b      	uxth	r3, r3
 800421e:	ea4f 5383 	mov.w	r3, r3, lsl #22
 8004222:	ea4f 5393 	mov.w	r3, r3, lsr #22
 8004226:	83fb      	strh	r3, [r7, #30]
            if (count != 0)
 8004228:	8bfb      	ldrh	r3, [r7, #30]
 800422a:	2b00      	cmp	r3, #0
 800422c:	d031      	beq.n	8004292 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x472>
            {
              PCD_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, count);
 800422e:	687b      	ldr	r3, [r7, #4]
 8004230:	6818      	ldr	r0, [r3, #0]
 8004232:	697b      	ldr	r3, [r7, #20]
 8004234:	6919      	ldr	r1, [r3, #16]
 8004236:	697b      	ldr	r3, [r7, #20]
 8004238:	88da      	ldrh	r2, [r3, #6]
 800423a:	8bfb      	ldrh	r3, [r7, #30]
 800423c:	f000 f9ec 	bl	8004618 <PCD_ReadPMA(USB_TypeDef*, unsigned char*, unsigned short, unsigned short)>
 8004240:	e027      	b.n	8004292 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x472>
            }
          }
          else
          {
            /*read from endpoint BUF1Addr buffer*/
            count = PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 8004242:	687b      	ldr	r3, [r7, #4]
 8004244:	681b      	ldr	r3, [r3, #0]
 8004246:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800424a:	b29b      	uxth	r3, r3
 800424c:	461a      	mov	r2, r3
 800424e:	697b      	ldr	r3, [r7, #20]
 8004250:	781b      	ldrb	r3, [r3, #0]
 8004252:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8004256:	18d3      	adds	r3, r2, r3
 8004258:	f103 0306 	add.w	r3, r3, #6
 800425c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8004260:	461a      	mov	r2, r3
 8004262:	687b      	ldr	r3, [r7, #4]
 8004264:	681b      	ldr	r3, [r3, #0]
 8004266:	18d3      	adds	r3, r2, r3
 8004268:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800426c:	681b      	ldr	r3, [r3, #0]
 800426e:	b29b      	uxth	r3, r3
 8004270:	ea4f 5383 	mov.w	r3, r3, lsl #22
 8004274:	ea4f 5393 	mov.w	r3, r3, lsr #22
 8004278:	83fb      	strh	r3, [r7, #30]
            if (count != 0)
 800427a:	8bfb      	ldrh	r3, [r7, #30]
 800427c:	2b00      	cmp	r3, #0
 800427e:	d008      	beq.n	8004292 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x472>
            {
              PCD_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
 8004280:	687b      	ldr	r3, [r7, #4]
 8004282:	6818      	ldr	r0, [r3, #0]
 8004284:	697b      	ldr	r3, [r7, #20]
 8004286:	6919      	ldr	r1, [r3, #16]
 8004288:	697b      	ldr	r3, [r7, #20]
 800428a:	891a      	ldrh	r2, [r3, #8]
 800428c:	8bfb      	ldrh	r3, [r7, #30]
 800428e:	f000 f9c3 	bl	8004618 <PCD_ReadPMA(USB_TypeDef*, unsigned char*, unsigned short, unsigned short)>
            }
          }
          PCD_FreeUserBuffer(hpcd->Instance, ep->num, PCD_EP_DBUF_OUT);  
 8004292:	687b      	ldr	r3, [r7, #4]
 8004294:	681b      	ldr	r3, [r3, #0]
 8004296:	461a      	mov	r2, r3
 8004298:	697b      	ldr	r3, [r7, #20]
 800429a:	781b      	ldrb	r3, [r3, #0]
 800429c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80042a0:	18d2      	adds	r2, r2, r3
 80042a2:	687b      	ldr	r3, [r7, #4]
 80042a4:	681b      	ldr	r3, [r3, #0]
 80042a6:	4619      	mov	r1, r3
 80042a8:	697b      	ldr	r3, [r7, #20]
 80042aa:	781b      	ldrb	r3, [r3, #0]
 80042ac:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80042b0:	18cb      	adds	r3, r1, r3
 80042b2:	881b      	ldrh	r3, [r3, #0]
 80042b4:	b299      	uxth	r1, r3
 80042b6:	f640 730f 	movw	r3, #3855	; 0xf0f
 80042ba:	400b      	ands	r3, r1
 80042bc:	b299      	uxth	r1, r3
 80042be:	f248 03c0 	movw	r3, #32960	; 0x80c0
 80042c2:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 80042c6:	430b      	orrs	r3, r1
 80042c8:	b29b      	uxth	r3, r3
 80042ca:	8013      	strh	r3, [r2, #0]
        }
        /*multi-packet on the NON control OUT endpoint*/
        ep->xfer_count+=count;
 80042cc:	697b      	ldr	r3, [r7, #20]
 80042ce:	699a      	ldr	r2, [r3, #24]
 80042d0:	8bfb      	ldrh	r3, [r7, #30]
 80042d2:	18d2      	adds	r2, r2, r3
 80042d4:	697b      	ldr	r3, [r7, #20]
 80042d6:	619a      	str	r2, [r3, #24]
        ep->xfer_buff+=count;
 80042d8:	697b      	ldr	r3, [r7, #20]
 80042da:	691a      	ldr	r2, [r3, #16]
 80042dc:	8bfb      	ldrh	r3, [r7, #30]
 80042de:	18d2      	adds	r2, r2, r3
 80042e0:	697b      	ldr	r3, [r7, #20]
 80042e2:	611a      	str	r2, [r3, #16]
       
        if ((ep->xfer_len == 0) || (count < ep->maxpacket))
 80042e4:	697b      	ldr	r3, [r7, #20]
 80042e6:	695b      	ldr	r3, [r3, #20]
 80042e8:	2b00      	cmp	r3, #0
 80042ea:	d004      	beq.n	80042f6 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x4d6>
 80042ec:	8bfa      	ldrh	r2, [r7, #30]
 80042ee:	697b      	ldr	r3, [r7, #20]
 80042f0:	68db      	ldr	r3, [r3, #12]
 80042f2:	429a      	cmp	r2, r3
 80042f4:	d206      	bcs.n	8004304 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x4e4>
        {
          /* RX COMPLETE */
          HAL_PCD_DataOutStageCallback(hpcd, ep->num);
 80042f6:	697b      	ldr	r3, [r7, #20]
 80042f8:	781b      	ldrb	r3, [r3, #0]
 80042fa:	6878      	ldr	r0, [r7, #4]
 80042fc:	4619      	mov	r1, r3
 80042fe:	f7fc f8f5 	bl	80004ec <HAL_PCD_DataOutStageCallback>
 8004302:	e008      	b.n	8004316 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x4f6>
        }
        else
        {
          HAL_PCD_EP_Receive(hpcd, ep->num, ep->xfer_buff, ep->xfer_len);
 8004304:	697b      	ldr	r3, [r7, #20]
 8004306:	7819      	ldrb	r1, [r3, #0]
 8004308:	697b      	ldr	r3, [r7, #20]
 800430a:	691a      	ldr	r2, [r3, #16]
 800430c:	697b      	ldr	r3, [r7, #20]
 800430e:	695b      	ldr	r3, [r3, #20]
 8004310:	6878      	ldr	r0, [r7, #4]
 8004312:	f7ff f907 	bl	8003524 <HAL_PCD_EP_Receive>
        }
        
      } /* if((wEPVal & EP_CTR_RX) */
      
      if ((wEPVal & USB_EP_CTR_TX) != 0)
 8004316:	89bb      	ldrh	r3, [r7, #12]
 8004318:	b29b      	uxth	r3, r3
 800431a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800431e:	2b00      	cmp	r3, #0
 8004320:	bf0c      	ite	eq
 8004322:	2300      	moveq	r3, #0
 8004324:	2301      	movne	r3, #1
 8004326:	b2db      	uxtb	r3, r3
 8004328:	2b00      	cmp	r3, #0
 800432a:	f000 8115 	beq.w	8004558 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x738>
      {
        ep = &hpcd->IN_ep[EPindex];
 800432e:	7efa      	ldrb	r2, [r7, #27]
 8004330:	4613      	mov	r3, r2
 8004332:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8004336:	1a9b      	subs	r3, r3, r2
 8004338:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800433c:	f103 0328 	add.w	r3, r3, #40	; 0x28
 8004340:	687a      	ldr	r2, [r7, #4]
 8004342:	18d3      	adds	r3, r2, r3
 8004344:	617b      	str	r3, [r7, #20]
        
        /* clear int flag */
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, EPindex);
 8004346:	687b      	ldr	r3, [r7, #4]
 8004348:	681b      	ldr	r3, [r3, #0]
 800434a:	461a      	mov	r2, r3
 800434c:	7efb      	ldrb	r3, [r7, #27]
 800434e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004352:	18d2      	adds	r2, r2, r3
 8004354:	687b      	ldr	r3, [r7, #4]
 8004356:	681b      	ldr	r3, [r3, #0]
 8004358:	4619      	mov	r1, r3
 800435a:	7efb      	ldrb	r3, [r7, #27]
 800435c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004360:	18cb      	adds	r3, r1, r3
 8004362:	881b      	ldrh	r3, [r3, #0]
 8004364:	b29b      	uxth	r3, r3
 8004366:	f423 43e1 	bic.w	r3, r3, #28800	; 0x7080
 800436a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800436e:	b29b      	uxth	r3, r3
 8004370:	8013      	strh	r3, [r2, #0]
        
        /* IN double Buffering*/
        if (ep->doublebuffer == 0)
 8004372:	697b      	ldr	r3, [r7, #20]
 8004374:	7a9b      	ldrb	r3, [r3, #10]
 8004376:	2b00      	cmp	r3, #0
 8004378:	d12d      	bne.n	80043d6 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x5b6>
        {
          ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 800437a:	687b      	ldr	r3, [r7, #4]
 800437c:	681b      	ldr	r3, [r3, #0]
 800437e:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8004382:	b29b      	uxth	r3, r3
 8004384:	461a      	mov	r2, r3
 8004386:	697b      	ldr	r3, [r7, #20]
 8004388:	781b      	ldrb	r3, [r3, #0]
 800438a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800438e:	18d3      	adds	r3, r2, r3
 8004390:	f103 0302 	add.w	r3, r3, #2
 8004394:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8004398:	461a      	mov	r2, r3
 800439a:	687b      	ldr	r3, [r7, #4]
 800439c:	681b      	ldr	r3, [r3, #0]
 800439e:	18d3      	adds	r3, r2, r3
 80043a0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80043a4:	681b      	ldr	r3, [r3, #0]
 80043a6:	b29b      	uxth	r3, r3
 80043a8:	ea4f 5383 	mov.w	r3, r3, lsl #22
 80043ac:	ea4f 5393 	mov.w	r3, r3, lsr #22
 80043b0:	697a      	ldr	r2, [r7, #20]
 80043b2:	6193      	str	r3, [r2, #24]
          if (ep->xfer_count != 0)
 80043b4:	697b      	ldr	r3, [r7, #20]
 80043b6:	699b      	ldr	r3, [r3, #24]
 80043b8:	2b00      	cmp	r3, #0
 80043ba:	f000 8095 	beq.w	80044e8 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x6c8>
          {
            PCD_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, ep->xfer_count);
 80043be:	687b      	ldr	r3, [r7, #4]
 80043c0:	6818      	ldr	r0, [r3, #0]
 80043c2:	697b      	ldr	r3, [r7, #20]
 80043c4:	6919      	ldr	r1, [r3, #16]
 80043c6:	697b      	ldr	r3, [r7, #20]
 80043c8:	889a      	ldrh	r2, [r3, #4]
 80043ca:	697b      	ldr	r3, [r7, #20]
 80043cc:	699b      	ldr	r3, [r3, #24]
 80043ce:	b29b      	uxth	r3, r3
 80043d0:	f000 f8d8 	bl	8004584 <PCD_WritePMA(USB_TypeDef*, unsigned char*, unsigned short, unsigned short)>
 80043d4:	e088      	b.n	80044e8 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x6c8>
          }
        }
        else
        {
          if (PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_TX)
 80043d6:	687b      	ldr	r3, [r7, #4]
 80043d8:	681b      	ldr	r3, [r3, #0]
 80043da:	461a      	mov	r2, r3
 80043dc:	697b      	ldr	r3, [r7, #20]
 80043de:	781b      	ldrb	r3, [r3, #0]
 80043e0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80043e4:	18d3      	adds	r3, r2, r3
 80043e6:	881b      	ldrh	r3, [r3, #0]
 80043e8:	b29b      	uxth	r3, r3
 80043ea:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80043ee:	2b00      	cmp	r3, #0
 80043f0:	bf0c      	ite	eq
 80043f2:	2300      	moveq	r3, #0
 80043f4:	2301      	movne	r3, #1
 80043f6:	b2db      	uxtb	r3, r3
 80043f8:	2b00      	cmp	r3, #0
 80043fa:	d02c      	beq.n	8004456 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x636>
          {
            /*read from endpoint BUF0Addr buffer*/
            ep->xfer_count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 80043fc:	687b      	ldr	r3, [r7, #4]
 80043fe:	681b      	ldr	r3, [r3, #0]
 8004400:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8004404:	b29b      	uxth	r3, r3
 8004406:	461a      	mov	r2, r3
 8004408:	697b      	ldr	r3, [r7, #20]
 800440a:	781b      	ldrb	r3, [r3, #0]
 800440c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8004410:	18d3      	adds	r3, r2, r3
 8004412:	f103 0302 	add.w	r3, r3, #2
 8004416:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800441a:	461a      	mov	r2, r3
 800441c:	687b      	ldr	r3, [r7, #4]
 800441e:	681b      	ldr	r3, [r3, #0]
 8004420:	18d3      	adds	r3, r2, r3
 8004422:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8004426:	681b      	ldr	r3, [r3, #0]
 8004428:	b29b      	uxth	r3, r3
 800442a:	ea4f 5383 	mov.w	r3, r3, lsl #22
 800442e:	ea4f 5393 	mov.w	r3, r3, lsr #22
 8004432:	697a      	ldr	r2, [r7, #20]
 8004434:	6193      	str	r3, [r2, #24]
            if (ep->xfer_count != 0)
 8004436:	697b      	ldr	r3, [r7, #20]
 8004438:	699b      	ldr	r3, [r3, #24]
 800443a:	2b00      	cmp	r3, #0
 800443c:	d037      	beq.n	80044ae <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x68e>
            {
              PCD_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, ep->xfer_count);
 800443e:	687b      	ldr	r3, [r7, #4]
 8004440:	6818      	ldr	r0, [r3, #0]
 8004442:	697b      	ldr	r3, [r7, #20]
 8004444:	6919      	ldr	r1, [r3, #16]
 8004446:	697b      	ldr	r3, [r7, #20]
 8004448:	88da      	ldrh	r2, [r3, #6]
 800444a:	697b      	ldr	r3, [r7, #20]
 800444c:	699b      	ldr	r3, [r3, #24]
 800444e:	b29b      	uxth	r3, r3
 8004450:	f000 f898 	bl	8004584 <PCD_WritePMA(USB_TypeDef*, unsigned char*, unsigned short, unsigned short)>
 8004454:	e02b      	b.n	80044ae <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x68e>
            }
          }
          else
          {
            /*read from endpoint BUF1Addr buffer*/
            ep->xfer_count = PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 8004456:	687b      	ldr	r3, [r7, #4]
 8004458:	681b      	ldr	r3, [r3, #0]
 800445a:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800445e:	b29b      	uxth	r3, r3
 8004460:	461a      	mov	r2, r3
 8004462:	697b      	ldr	r3, [r7, #20]
 8004464:	781b      	ldrb	r3, [r3, #0]
 8004466:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800446a:	18d3      	adds	r3, r2, r3
 800446c:	f103 0306 	add.w	r3, r3, #6
 8004470:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8004474:	461a      	mov	r2, r3
 8004476:	687b      	ldr	r3, [r7, #4]
 8004478:	681b      	ldr	r3, [r3, #0]
 800447a:	18d3      	adds	r3, r2, r3
 800447c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8004480:	681b      	ldr	r3, [r3, #0]
 8004482:	b29b      	uxth	r3, r3
 8004484:	ea4f 5383 	mov.w	r3, r3, lsl #22
 8004488:	ea4f 5393 	mov.w	r3, r3, lsr #22
 800448c:	697a      	ldr	r2, [r7, #20]
 800448e:	6193      	str	r3, [r2, #24]
            if (ep->xfer_count != 0)
 8004490:	697b      	ldr	r3, [r7, #20]
 8004492:	699b      	ldr	r3, [r3, #24]
 8004494:	2b00      	cmp	r3, #0
 8004496:	d00a      	beq.n	80044ae <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x68e>
            {
              PCD_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, ep->xfer_count);
 8004498:	687b      	ldr	r3, [r7, #4]
 800449a:	6818      	ldr	r0, [r3, #0]
 800449c:	697b      	ldr	r3, [r7, #20]
 800449e:	6919      	ldr	r1, [r3, #16]
 80044a0:	697b      	ldr	r3, [r7, #20]
 80044a2:	891a      	ldrh	r2, [r3, #8]
 80044a4:	697b      	ldr	r3, [r7, #20]
 80044a6:	699b      	ldr	r3, [r3, #24]
 80044a8:	b29b      	uxth	r3, r3
 80044aa:	f000 f86b 	bl	8004584 <PCD_WritePMA(USB_TypeDef*, unsigned char*, unsigned short, unsigned short)>
            }
          }
          PCD_FreeUserBuffer(hpcd->Instance, ep->num, PCD_EP_DBUF_IN);  
 80044ae:	687b      	ldr	r3, [r7, #4]
 80044b0:	681b      	ldr	r3, [r3, #0]
 80044b2:	461a      	mov	r2, r3
 80044b4:	697b      	ldr	r3, [r7, #20]
 80044b6:	781b      	ldrb	r3, [r3, #0]
 80044b8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80044bc:	18d2      	adds	r2, r2, r3
 80044be:	687b      	ldr	r3, [r7, #4]
 80044c0:	681b      	ldr	r3, [r3, #0]
 80044c2:	4619      	mov	r1, r3
 80044c4:	697b      	ldr	r3, [r7, #20]
 80044c6:	781b      	ldrb	r3, [r3, #0]
 80044c8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80044cc:	18cb      	adds	r3, r1, r3
 80044ce:	881b      	ldrh	r3, [r3, #0]
 80044d0:	b299      	uxth	r1, r3
 80044d2:	f640 730f 	movw	r3, #3855	; 0xf0f
 80044d6:	400b      	ands	r3, r1
 80044d8:	b299      	uxth	r1, r3
 80044da:	f24c 0380 	movw	r3, #49280	; 0xc080
 80044de:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 80044e2:	430b      	orrs	r3, r1
 80044e4:	b29b      	uxth	r3, r3
 80044e6:	8013      	strh	r3, [r2, #0]
        }
        /*multi-packet on the NON control IN endpoint*/
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 80044e8:	687b      	ldr	r3, [r7, #4]
 80044ea:	681b      	ldr	r3, [r3, #0]
 80044ec:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80044f0:	b29b      	uxth	r3, r3
 80044f2:	461a      	mov	r2, r3
 80044f4:	697b      	ldr	r3, [r7, #20]
 80044f6:	781b      	ldrb	r3, [r3, #0]
 80044f8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80044fc:	18d3      	adds	r3, r2, r3
 80044fe:	f103 0302 	add.w	r3, r3, #2
 8004502:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8004506:	461a      	mov	r2, r3
 8004508:	687b      	ldr	r3, [r7, #4]
 800450a:	681b      	ldr	r3, [r3, #0]
 800450c:	18d3      	adds	r3, r2, r3
 800450e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8004512:	681b      	ldr	r3, [r3, #0]
 8004514:	b29b      	uxth	r3, r3
 8004516:	ea4f 5383 	mov.w	r3, r3, lsl #22
 800451a:	ea4f 5393 	mov.w	r3, r3, lsr #22
 800451e:	697a      	ldr	r2, [r7, #20]
 8004520:	6193      	str	r3, [r2, #24]
        ep->xfer_buff+=ep->xfer_count;
 8004522:	697b      	ldr	r3, [r7, #20]
 8004524:	691a      	ldr	r2, [r3, #16]
 8004526:	697b      	ldr	r3, [r7, #20]
 8004528:	699b      	ldr	r3, [r3, #24]
 800452a:	18d2      	adds	r2, r2, r3
 800452c:	697b      	ldr	r3, [r7, #20]
 800452e:	611a      	str	r2, [r3, #16]
       
        /* Zero Length Packet? */
        if (ep->xfer_len == 0)
 8004530:	697b      	ldr	r3, [r7, #20]
 8004532:	695b      	ldr	r3, [r3, #20]
 8004534:	2b00      	cmp	r3, #0
 8004536:	d106      	bne.n	8004546 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x726>
        {
          /* TX COMPLETE */
          HAL_PCD_DataInStageCallback(hpcd, ep->num);
 8004538:	697b      	ldr	r3, [r7, #20]
 800453a:	781b      	ldrb	r3, [r3, #0]
 800453c:	6878      	ldr	r0, [r7, #4]
 800453e:	4619      	mov	r1, r3
 8004540:	f7fb fff4 	bl	800052c <HAL_PCD_DataInStageCallback>
 8004544:	e008      	b.n	8004558 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x738>
        }
        else
        {
          HAL_PCD_EP_Transmit(hpcd, ep->num, ep->xfer_buff, ep->xfer_len);
 8004546:	697b      	ldr	r3, [r7, #20]
 8004548:	7819      	ldrb	r1, [r3, #0]
 800454a:	697b      	ldr	r3, [r7, #20]
 800454c:	691a      	ldr	r2, [r3, #16]
 800454e:	697b      	ldr	r3, [r7, #20]
 8004550:	695b      	ldr	r3, [r3, #20]
 8004552:	6878      	ldr	r0, [r7, #4]
 8004554:	f7ff f934 	bl	80037c0 <HAL_PCD_EP_Transmit>
  uint8_t EPindex;
  __IO uint16_t wIstr;  
  __IO uint16_t wEPVal = 0;
  
  /* stay in loop while pending interrupts */
  while (((wIstr = hpcd->Instance->ISTR) & USB_ISTR_CTR) != 0)
 8004558:	687b      	ldr	r3, [r7, #4]
 800455a:	681b      	ldr	r3, [r3, #0]
 800455c:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 8004560:	b29b      	uxth	r3, r3
 8004562:	461a      	mov	r2, r3
 8004564:	81fa      	strh	r2, [r7, #14]
 8004566:	b29b      	uxth	r3, r3
 8004568:	ea4f 33d3 	mov.w	r3, r3, lsr #15
 800456c:	b2db      	uxtb	r3, r3
 800456e:	2b00      	cmp	r3, #0
 8004570:	f47f ac61 	bne.w	8003e36 <PCD_EP_ISR_Handler(PCD_HandleTypeDef*)+0x16>
          HAL_PCD_EP_Transmit(hpcd, ep->num, ep->xfer_buff, ep->xfer_len);
        }
      } 
    }
  }
  return HAL_OK;
 8004574:	f04f 0300 	mov.w	r3, #0
}
 8004578:	4618      	mov	r0, r3
 800457a:	f107 0724 	add.w	r7, r7, #36	; 0x24
 800457e:	46bd      	mov	sp, r7
 8004580:	bd90      	pop	{r4, r7, pc}
 8004582:	bf00      	nop

08004584 <PCD_WritePMA(USB_TypeDef*, unsigned char*, unsigned short, unsigned short)>:
  * @param   wPMABufAddr: address into PMA.
  * @param   wNBytes: no. of bytes to be copied.
  * @retval None
  */
static void PCD_WritePMA(USB_TypeDef  *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
 8004584:	b480      	push	{r7}
 8004586:	b08b      	sub	sp, #44	; 0x2c
 8004588:	af00      	add	r7, sp, #0
 800458a:	60f8      	str	r0, [r7, #12]
 800458c:	60b9      	str	r1, [r7, #8]
 800458e:	80fa      	strh	r2, [r7, #6]
 8004590:	80bb      	strh	r3, [r7, #4]
  uint32_t n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
 8004592:	88bb      	ldrh	r3, [r7, #4]
 8004594:	f103 0301 	add.w	r3, r3, #1
 8004598:	ea4f 0363 	mov.w	r3, r3, asr #1
 800459c:	61fb      	str	r3, [r7, #28]
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
 800459e:	88fb      	ldrh	r3, [r7, #6]
 80045a0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80045a4:	461a      	mov	r2, r3
 80045a6:	68fb      	ldr	r3, [r7, #12]
 80045a8:	18d3      	adds	r3, r2, r3
 80045aa:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80045ae:	623b      	str	r3, [r7, #32]
  for (i = n; i != 0; i--)
 80045b0:	69fb      	ldr	r3, [r7, #28]
 80045b2:	627b      	str	r3, [r7, #36]	; 0x24
 80045b4:	e022      	b.n	80045fc <PCD_WritePMA(USB_TypeDef*, unsigned char*, unsigned short, unsigned short)+0x78>
  {
    temp1 = (uint16_t) * pbUsrBuf;
 80045b6:	68bb      	ldr	r3, [r7, #8]
 80045b8:	781b      	ldrb	r3, [r3, #0]
 80045ba:	61bb      	str	r3, [r7, #24]
    pbUsrBuf++;
 80045bc:	68bb      	ldr	r3, [r7, #8]
 80045be:	f103 0301 	add.w	r3, r3, #1
 80045c2:	60bb      	str	r3, [r7, #8]
    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
 80045c4:	68bb      	ldr	r3, [r7, #8]
 80045c6:	781b      	ldrb	r3, [r3, #0]
 80045c8:	ea4f 2303 	mov.w	r3, r3, lsl #8
 80045cc:	461a      	mov	r2, r3
 80045ce:	69bb      	ldr	r3, [r7, #24]
 80045d0:	4313      	orrs	r3, r2
 80045d2:	617b      	str	r3, [r7, #20]
    *pdwVal++ = temp2;
 80045d4:	697b      	ldr	r3, [r7, #20]
 80045d6:	b29a      	uxth	r2, r3
 80045d8:	6a3b      	ldr	r3, [r7, #32]
 80045da:	801a      	strh	r2, [r3, #0]
 80045dc:	6a3b      	ldr	r3, [r7, #32]
 80045de:	f103 0302 	add.w	r3, r3, #2
 80045e2:	623b      	str	r3, [r7, #32]
    pdwVal++;
 80045e4:	6a3b      	ldr	r3, [r7, #32]
 80045e6:	f103 0302 	add.w	r3, r3, #2
 80045ea:	623b      	str	r3, [r7, #32]
    pbUsrBuf++;
 80045ec:	68bb      	ldr	r3, [r7, #8]
 80045ee:	f103 0301 	add.w	r3, r3, #1
 80045f2:	60bb      	str	r3, [r7, #8]
{
  uint32_t n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
  for (i = n; i != 0; i--)
 80045f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80045f6:	f103 33ff 	add.w	r3, r3, #4294967295
 80045fa:	627b      	str	r3, [r7, #36]	; 0x24
 80045fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80045fe:	2b00      	cmp	r3, #0
 8004600:	bf0c      	ite	eq
 8004602:	2300      	moveq	r3, #0
 8004604:	2301      	movne	r3, #1
 8004606:	b2db      	uxtb	r3, r3
 8004608:	2b00      	cmp	r3, #0
 800460a:	d1d4      	bne.n	80045b6 <PCD_WritePMA(USB_TypeDef*, unsigned char*, unsigned short, unsigned short)+0x32>
    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
    *pdwVal++ = temp2;
    pdwVal++;
    pbUsrBuf++;
  }
}
 800460c:	f107 072c 	add.w	r7, r7, #44	; 0x2c
 8004610:	46bd      	mov	sp, r7
 8004612:	bc80      	pop	{r7}
 8004614:	4770      	bx	lr
 8004616:	bf00      	nop

08004618 <PCD_ReadPMA(USB_TypeDef*, unsigned char*, unsigned short, unsigned short)>:
  * @param   wPMABufAddr: address into PMA.
  * @param   wNBytes: no. of bytes to be copied.
  * @retval None
  */
static void PCD_ReadPMA(USB_TypeDef  *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
 8004618:	b480      	push	{r7}
 800461a:	b089      	sub	sp, #36	; 0x24
 800461c:	af00      	add	r7, sp, #0
 800461e:	60f8      	str	r0, [r7, #12]
 8004620:	60b9      	str	r1, [r7, #8]
 8004622:	80fa      	strh	r2, [r7, #6]
 8004624:	80bb      	strh	r3, [r7, #4]
  uint32_t n = (wNBytes + 1) >> 1;/* /2*/
 8004626:	88bb      	ldrh	r3, [r7, #4]
 8004628:	f103 0301 	add.w	r3, r3, #1
 800462c:	ea4f 0363 	mov.w	r3, r3, asr #1
 8004630:	617b      	str	r3, [r7, #20]
  uint32_t i;
  uint32_t *pdwVal;
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
 8004632:	88fb      	ldrh	r3, [r7, #6]
 8004634:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8004638:	461a      	mov	r2, r3
 800463a:	68fb      	ldr	r3, [r7, #12]
 800463c:	18d3      	adds	r3, r2, r3
 800463e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8004642:	61bb      	str	r3, [r7, #24]
  for (i = n; i != 0; i--)
 8004644:	697b      	ldr	r3, [r7, #20]
 8004646:	61fb      	str	r3, [r7, #28]
 8004648:	e014      	b.n	8004674 <PCD_ReadPMA(USB_TypeDef*, unsigned char*, unsigned short, unsigned short)+0x5c>
  {
    *(uint16_t*)pbUsrBuf++ = *pdwVal++;
 800464a:	69bb      	ldr	r3, [r7, #24]
 800464c:	681b      	ldr	r3, [r3, #0]
 800464e:	b29a      	uxth	r2, r3
 8004650:	68bb      	ldr	r3, [r7, #8]
 8004652:	801a      	strh	r2, [r3, #0]
 8004654:	68bb      	ldr	r3, [r7, #8]
 8004656:	f103 0301 	add.w	r3, r3, #1
 800465a:	60bb      	str	r3, [r7, #8]
 800465c:	69bb      	ldr	r3, [r7, #24]
 800465e:	f103 0304 	add.w	r3, r3, #4
 8004662:	61bb      	str	r3, [r7, #24]
    pbUsrBuf++;
 8004664:	68bb      	ldr	r3, [r7, #8]
 8004666:	f103 0301 	add.w	r3, r3, #1
 800466a:	60bb      	str	r3, [r7, #8]
{
  uint32_t n = (wNBytes + 1) >> 1;/* /2*/
  uint32_t i;
  uint32_t *pdwVal;
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
  for (i = n; i != 0; i--)
 800466c:	69fb      	ldr	r3, [r7, #28]
 800466e:	f103 33ff 	add.w	r3, r3, #4294967295
 8004672:	61fb      	str	r3, [r7, #28]
 8004674:	69fb      	ldr	r3, [r7, #28]
 8004676:	2b00      	cmp	r3, #0
 8004678:	bf0c      	ite	eq
 800467a:	2300      	moveq	r3, #0
 800467c:	2301      	movne	r3, #1
 800467e:	b2db      	uxtb	r3, r3
 8004680:	2b00      	cmp	r3, #0
 8004682:	d1e2      	bne.n	800464a <PCD_ReadPMA(USB_TypeDef*, unsigned char*, unsigned short, unsigned short)+0x32>
  {
    *(uint16_t*)pbUsrBuf++ = *pdwVal++;
    pbUsrBuf++;
  }
}
 8004684:	f107 0724 	add.w	r7, r7, #36	; 0x24
 8004688:	46bd      	mov	sp, r7
 800468a:	bc80      	pop	{r7}
 800468c:	4770      	bx	lr
 800468e:	bf00      	nop

08004690 <HAL_PCDEx_PMAConfig>:
HAL_StatusTypeDef  HAL_PCDEx_PMAConfig(PCD_HandleTypeDef *hpcd, 
                        uint16_t ep_addr,
                        uint16_t ep_kind,
                        uint32_t pmaadress)

{
 8004690:	b480      	push	{r7}
 8004692:	b087      	sub	sp, #28
 8004694:	af00      	add	r7, sp, #0
 8004696:	60f8      	str	r0, [r7, #12]
 8004698:	607b      	str	r3, [r7, #4]
 800469a:	460b      	mov	r3, r1
 800469c:	817b      	strh	r3, [r7, #10]
 800469e:	4613      	mov	r3, r2
 80046a0:	813b      	strh	r3, [r7, #8]
  PCD_EPTypeDef *ep;
  
  /* initialize ep structure*/
  if ((0x80 & ep_addr) == 0x80)
 80046a2:	897b      	ldrh	r3, [r7, #10]
 80046a4:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80046a8:	2b00      	cmp	r3, #0
 80046aa:	d00e      	beq.n	80046ca <HAL_PCDEx_PMAConfig+0x3a>
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 80046ac:	897b      	ldrh	r3, [r7, #10]
 80046ae:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 80046b2:	4613      	mov	r3, r2
 80046b4:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80046b8:	1a9b      	subs	r3, r3, r2
 80046ba:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80046be:	f103 0328 	add.w	r3, r3, #40	; 0x28
 80046c2:	68fa      	ldr	r2, [r7, #12]
 80046c4:	18d3      	adds	r3, r2, r3
 80046c6:	617b      	str	r3, [r7, #20]
 80046c8:	e00b      	b.n	80046e2 <HAL_PCDEx_PMAConfig+0x52>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 80046ca:	897a      	ldrh	r2, [r7, #10]
 80046cc:	4613      	mov	r3, r2
 80046ce:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80046d2:	1a9b      	subs	r3, r3, r2
 80046d4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80046d8:	f503 7384 	add.w	r3, r3, #264	; 0x108
 80046dc:	68fa      	ldr	r2, [r7, #12]
 80046de:	18d3      	adds	r3, r2, r3
 80046e0:	617b      	str	r3, [r7, #20]
  }
  
  /* Here we check if the endpoint is single or double Buffer*/
  if (ep_kind == PCD_SNG_BUF)
 80046e2:	893b      	ldrh	r3, [r7, #8]
 80046e4:	2b00      	cmp	r3, #0
 80046e6:	d108      	bne.n	80046fa <HAL_PCDEx_PMAConfig+0x6a>
  {
    /*Single Buffer*/
    ep->doublebuffer = 0;
 80046e8:	697b      	ldr	r3, [r7, #20]
 80046ea:	f04f 0200 	mov.w	r2, #0
 80046ee:	729a      	strb	r2, [r3, #10]
    /*Configure te PMA*/
    ep->pmaadress = (uint16_t)pmaadress;
 80046f0:	687b      	ldr	r3, [r7, #4]
 80046f2:	b29a      	uxth	r2, r3
 80046f4:	697b      	ldr	r3, [r7, #20]
 80046f6:	809a      	strh	r2, [r3, #4]
 80046f8:	e00d      	b.n	8004716 <HAL_PCDEx_PMAConfig+0x86>
  }
  else /*USB_DBL_BUF*/
  {
    /*Double Buffer Endpoint*/
    ep->doublebuffer = 1;
 80046fa:	697b      	ldr	r3, [r7, #20]
 80046fc:	f04f 0201 	mov.w	r2, #1
 8004700:	729a      	strb	r2, [r3, #10]
    /*Configure the PMA*/
    ep->pmaaddr0 =  pmaadress & 0xFFFF;
 8004702:	687b      	ldr	r3, [r7, #4]
 8004704:	b29a      	uxth	r2, r3
 8004706:	697b      	ldr	r3, [r7, #20]
 8004708:	80da      	strh	r2, [r3, #6]
    ep->pmaaddr1 =  (pmaadress & 0xFFFF0000) >> 16;
 800470a:	687b      	ldr	r3, [r7, #4]
 800470c:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8004710:	b29a      	uxth	r2, r3
 8004712:	697b      	ldr	r3, [r7, #20]
 8004714:	811a      	strh	r2, [r3, #8]
  }
  
  return HAL_OK; 
 8004716:	f04f 0300 	mov.w	r3, #0
}
 800471a:	4618      	mov	r0, r3
 800471c:	f107 071c 	add.w	r7, r7, #28
 8004720:	46bd      	mov	sp, r7
 8004722:	bc80      	pop	{r7}
 8004724:	4770      	bx	lr
 8004726:	bf00      	nop

08004728 <HAL_RCC_OscConfig>:
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8004728:	b590      	push	{r4, r7, lr}
 800472a:	f5ad 7d69 	sub.w	sp, sp, #932	; 0x3a4
 800472e:	af00      	add	r7, sp, #0
 8004730:	f107 0304 	add.w	r3, r7, #4
 8004734:	6018      	str	r0, [r3, #0]
   uint32_t tickstart = 0;
 8004736:	f04f 0300 	mov.w	r3, #0
 800473a:	f8c7 339c 	str.w	r3, [r7, #924]	; 0x39c
  
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800473e:	f107 0304 	add.w	r3, r7, #4
 8004742:	681b      	ldr	r3, [r3, #0]
 8004744:	681b      	ldr	r3, [r3, #0]
 8004746:	f003 0301 	and.w	r3, r3, #1
 800474a:	2b00      	cmp	r3, #0
 800474c:	f000 81c3 	beq.w	8004ad6 <HAL_RCC_OscConfig+0x3ae>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) 
 8004750:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004754:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004758:	689b      	ldr	r3, [r3, #8]
 800475a:	f003 030c 	and.w	r3, r3, #12
 800475e:	2b08      	cmp	r3, #8
 8004760:	d011      	beq.n	8004786 <HAL_RCC_OscConfig+0x5e>
 8004762:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004766:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800476a:	689b      	ldr	r3, [r3, #8]
 800476c:	f003 030c 	and.w	r3, r3, #12
 8004770:	2b0c      	cmp	r3, #12
 8004772:	d10b      	bne.n	800478c <HAL_RCC_OscConfig+0x64>
 8004774:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004778:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800477c:	689b      	ldr	r3, [r3, #8]
 800477e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8004782:	2b00      	cmp	r3, #0
 8004784:	d002      	beq.n	800478c <HAL_RCC_OscConfig+0x64>
 8004786:	f04f 0301 	mov.w	r3, #1
 800478a:	e001      	b.n	8004790 <HAL_RCC_OscConfig+0x68>
 800478c:	f04f 0300 	mov.w	r3, #0
 8004790:	2b00      	cmp	r3, #0
 8004792:	d059      	beq.n	8004848 <HAL_RCC_OscConfig+0x120>
 8004794:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8004798:	f8c7 3398 	str.w	r3, [r7, #920]	; 0x398
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800479c:	f8d7 3398 	ldr.w	r3, [r7, #920]	; 0x398
 80047a0:	fa93 f4a3 	rbit	r4, r3
 80047a4:	f8c7 4394 	str.w	r4, [r7, #916]	; 0x394
   return(result);
 80047a8:	f8d7 3394 	ldr.w	r3, [r7, #916]	; 0x394
 80047ac:	f8c7 3390 	str.w	r3, [r7, #912]	; 0x390
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80047b0:	f8d7 3390 	ldr.w	r3, [r7, #912]	; 0x390
 80047b4:	fab3 f483 	clz	r4, r3
 80047b8:	f8c7 438c 	str.w	r4, [r7, #908]	; 0x38c
  return(result);
 80047bc:	f8d7 338c 	ldr.w	r3, [r7, #908]	; 0x38c
 80047c0:	b2db      	uxtb	r3, r3
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState != RCC_HSE_ON))
 80047c2:	f043 0320 	orr.w	r3, r3, #32
 80047c6:	b2db      	uxtb	r3, r3
 80047c8:	ea4f 1363 	mov.w	r3, r3, asr #5
 80047cc:	2b01      	cmp	r3, #1
 80047ce:	d105      	bne.n	80047dc <HAL_RCC_OscConfig+0xb4>
 80047d0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80047d4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80047d8:	681b      	ldr	r3, [r3, #0]
 80047da:	e004      	b.n	80047e6 <HAL_RCC_OscConfig+0xbe>
 80047dc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80047e0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80047e4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80047e6:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 80047ea:	f8c7 2388 	str.w	r2, [r7, #904]	; 0x388
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80047ee:	f8d7 2388 	ldr.w	r2, [r7, #904]	; 0x388
 80047f2:	fa92 f4a2 	rbit	r4, r2
 80047f6:	f8c7 4384 	str.w	r4, [r7, #900]	; 0x384
   return(result);
 80047fa:	f8d7 2384 	ldr.w	r2, [r7, #900]	; 0x384
 80047fe:	f8c7 2380 	str.w	r2, [r7, #896]	; 0x380
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8004802:	f8d7 2380 	ldr.w	r2, [r7, #896]	; 0x380
 8004806:	fab2 f482 	clz	r4, r2
 800480a:	f8c7 437c 	str.w	r4, [r7, #892]	; 0x37c
  return(result);
 800480e:	f8d7 237c 	ldr.w	r2, [r7, #892]	; 0x37c
 8004812:	b2d2      	uxtb	r2, r2
 8004814:	f002 021f 	and.w	r2, r2, #31
 8004818:	fa23 f302 	lsr.w	r3, r3, r2
 800481c:	f003 0301 	and.w	r3, r3, #1
 8004820:	2b00      	cmp	r3, #0
 8004822:	d008      	beq.n	8004836 <HAL_RCC_OscConfig+0x10e>
 8004824:	f107 0304 	add.w	r3, r7, #4
 8004828:	681b      	ldr	r3, [r3, #0]
 800482a:	685b      	ldr	r3, [r3, #4]
 800482c:	2b01      	cmp	r3, #1
 800482e:	d002      	beq.n	8004836 <HAL_RCC_OscConfig+0x10e>
 8004830:	f04f 0301 	mov.w	r3, #1
 8004834:	e001      	b.n	800483a <HAL_RCC_OscConfig+0x112>
 8004836:	f04f 0300 	mov.w	r3, #0
 800483a:	2b00      	cmp	r3, #0
 800483c:	f000 814b 	beq.w	8004ad6 <HAL_RCC_OscConfig+0x3ae>
      {
        return HAL_ERROR;
 8004840:	f04f 0301 	mov.w	r3, #1
 8004844:	f001 bc01 	b.w	800604a <HAL_RCC_OscConfig+0x1922>
      }
    }
    else
    {
      /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
 8004848:	f643 0302 	movw	r3, #14338	; 0x3802
 800484c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004850:	f04f 0200 	mov.w	r2, #0
 8004854:	701a      	strb	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8004856:	f7fd fd89 	bl	800236c <HAL_GetTick>
 800485a:	f8c7 039c 	str.w	r0, [r7, #924]	; 0x39c
      
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800485e:	e012      	b.n	8004886 <HAL_RCC_OscConfig+0x15e>
      {
        if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8004860:	f7fd fd84 	bl	800236c <HAL_GetTick>
 8004864:	4602      	mov	r2, r0
 8004866:	f8d7 339c 	ldr.w	r3, [r7, #924]	; 0x39c
 800486a:	1ad2      	subs	r2, r2, r3
 800486c:	f241 3388 	movw	r3, #5000	; 0x1388
 8004870:	429a      	cmp	r2, r3
 8004872:	bf94      	ite	ls
 8004874:	2300      	movls	r3, #0
 8004876:	2301      	movhi	r3, #1
 8004878:	b2db      	uxtb	r3, r3
 800487a:	2b00      	cmp	r3, #0
 800487c:	d003      	beq.n	8004886 <HAL_RCC_OscConfig+0x15e>
        {
          return HAL_TIMEOUT;
 800487e:	f04f 0303 	mov.w	r3, #3
 8004882:	f001 bbe2 	b.w	800604a <HAL_RCC_OscConfig+0x1922>
 8004886:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 800488a:	f8c7 3378 	str.w	r3, [r7, #888]	; 0x378
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800488e:	f8d7 3378 	ldr.w	r3, [r7, #888]	; 0x378
 8004892:	fa93 f4a3 	rbit	r4, r3
 8004896:	f8c7 4374 	str.w	r4, [r7, #884]	; 0x374
   return(result);
 800489a:	f8d7 3374 	ldr.w	r3, [r7, #884]	; 0x374
 800489e:	f8c7 3370 	str.w	r3, [r7, #880]	; 0x370
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80048a2:	f8d7 3370 	ldr.w	r3, [r7, #880]	; 0x370
 80048a6:	fab3 f483 	clz	r4, r3
 80048aa:	f8c7 436c 	str.w	r4, [r7, #876]	; 0x36c
  return(result);
 80048ae:	f8d7 336c 	ldr.w	r3, [r7, #876]	; 0x36c
 80048b2:	b2db      	uxtb	r3, r3
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80048b4:	f043 0320 	orr.w	r3, r3, #32
 80048b8:	b2db      	uxtb	r3, r3
 80048ba:	ea4f 1363 	mov.w	r3, r3, asr #5
 80048be:	2b01      	cmp	r3, #1
 80048c0:	d105      	bne.n	80048ce <HAL_RCC_OscConfig+0x1a6>
 80048c2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80048c6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80048ca:	681b      	ldr	r3, [r3, #0]
 80048cc:	e004      	b.n	80048d8 <HAL_RCC_OscConfig+0x1b0>
 80048ce:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80048d2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80048d6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80048d8:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 80048dc:	f8c7 2368 	str.w	r2, [r7, #872]	; 0x368
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80048e0:	f8d7 2368 	ldr.w	r2, [r7, #872]	; 0x368
 80048e4:	fa92 f4a2 	rbit	r4, r2
 80048e8:	f8c7 4364 	str.w	r4, [r7, #868]	; 0x364
   return(result);
 80048ec:	f8d7 2364 	ldr.w	r2, [r7, #868]	; 0x364
 80048f0:	f8c7 2360 	str.w	r2, [r7, #864]	; 0x360
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80048f4:	f8d7 2360 	ldr.w	r2, [r7, #864]	; 0x360
 80048f8:	fab2 f482 	clz	r4, r2
 80048fc:	f8c7 435c 	str.w	r4, [r7, #860]	; 0x35c
  return(result);
 8004900:	f8d7 235c 	ldr.w	r2, [r7, #860]	; 0x35c
 8004904:	b2d2      	uxtb	r2, r2
 8004906:	f002 021f 	and.w	r2, r2, #31
 800490a:	fa23 f302 	lsr.w	r3, r3, r2
 800490e:	f003 0301 	and.w	r3, r3, #1
 8004912:	2b00      	cmp	r3, #0
 8004914:	bf0c      	ite	eq
 8004916:	2300      	moveq	r3, #0
 8004918:	2301      	movne	r3, #1
 800491a:	b2db      	uxtb	r3, r3
 800491c:	2b00      	cmp	r3, #0
 800491e:	d19f      	bne.n	8004860 <HAL_RCC_OscConfig+0x138>
          return HAL_TIMEOUT;
        }
      }
      
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8004920:	f643 0302 	movw	r3, #14338	; 0x3802
 8004924:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004928:	f107 0204 	add.w	r2, r7, #4
 800492c:	6812      	ldr	r2, [r2, #0]
 800492e:	6852      	ldr	r2, [r2, #4]
 8004930:	b2d2      	uxtb	r2, r2
 8004932:	701a      	strb	r2, [r3, #0]
      
      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8004934:	f107 0304 	add.w	r3, r7, #4
 8004938:	681b      	ldr	r3, [r3, #0]
 800493a:	685b      	ldr	r3, [r3, #4]
 800493c:	2b00      	cmp	r3, #0
 800493e:	d065      	beq.n	8004a0c <HAL_RCC_OscConfig+0x2e4>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004940:	f7fd fd14 	bl	800236c <HAL_GetTick>
 8004944:	f8c7 039c 	str.w	r0, [r7, #924]	; 0x39c
        
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8004948:	e012      	b.n	8004970 <HAL_RCC_OscConfig+0x248>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800494a:	f7fd fd0f 	bl	800236c <HAL_GetTick>
 800494e:	4602      	mov	r2, r0
 8004950:	f8d7 339c 	ldr.w	r3, [r7, #924]	; 0x39c
 8004954:	1ad2      	subs	r2, r2, r3
 8004956:	f241 3388 	movw	r3, #5000	; 0x1388
 800495a:	429a      	cmp	r2, r3
 800495c:	bf94      	ite	ls
 800495e:	2300      	movls	r3, #0
 8004960:	2301      	movhi	r3, #1
 8004962:	b2db      	uxtb	r3, r3
 8004964:	2b00      	cmp	r3, #0
 8004966:	d003      	beq.n	8004970 <HAL_RCC_OscConfig+0x248>
          {
            return HAL_TIMEOUT;
 8004968:	f04f 0303 	mov.w	r3, #3
 800496c:	f001 bb6d 	b.w	800604a <HAL_RCC_OscConfig+0x1922>
 8004970:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8004974:	f8c7 3358 	str.w	r3, [r7, #856]	; 0x358
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004978:	f8d7 3358 	ldr.w	r3, [r7, #856]	; 0x358
 800497c:	fa93 f4a3 	rbit	r4, r3
 8004980:	f8c7 4354 	str.w	r4, [r7, #852]	; 0x354
   return(result);
 8004984:	f8d7 3354 	ldr.w	r3, [r7, #852]	; 0x354
 8004988:	f8c7 3350 	str.w	r3, [r7, #848]	; 0x350
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 800498c:	f8d7 3350 	ldr.w	r3, [r7, #848]	; 0x350
 8004990:	fab3 f483 	clz	r4, r3
 8004994:	f8c7 434c 	str.w	r4, [r7, #844]	; 0x34c
  return(result);
 8004998:	f8d7 334c 	ldr.w	r3, [r7, #844]	; 0x34c
 800499c:	b2db      	uxtb	r3, r3
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800499e:	f043 0320 	orr.w	r3, r3, #32
 80049a2:	b2db      	uxtb	r3, r3
 80049a4:	ea4f 1363 	mov.w	r3, r3, asr #5
 80049a8:	2b01      	cmp	r3, #1
 80049aa:	d105      	bne.n	80049b8 <HAL_RCC_OscConfig+0x290>
 80049ac:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80049b0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80049b4:	681b      	ldr	r3, [r3, #0]
 80049b6:	e004      	b.n	80049c2 <HAL_RCC_OscConfig+0x29a>
 80049b8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80049bc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80049c0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80049c2:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 80049c6:	f8c7 2348 	str.w	r2, [r7, #840]	; 0x348
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80049ca:	f8d7 2348 	ldr.w	r2, [r7, #840]	; 0x348
 80049ce:	fa92 f4a2 	rbit	r4, r2
 80049d2:	f8c7 4344 	str.w	r4, [r7, #836]	; 0x344
   return(result);
 80049d6:	f8d7 2344 	ldr.w	r2, [r7, #836]	; 0x344
 80049da:	f8c7 2340 	str.w	r2, [r7, #832]	; 0x340
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80049de:	f8d7 2340 	ldr.w	r2, [r7, #832]	; 0x340
 80049e2:	fab2 f482 	clz	r4, r2
 80049e6:	f8c7 433c 	str.w	r4, [r7, #828]	; 0x33c
  return(result);
 80049ea:	f8d7 233c 	ldr.w	r2, [r7, #828]	; 0x33c
 80049ee:	b2d2      	uxtb	r2, r2
 80049f0:	f002 021f 	and.w	r2, r2, #31
 80049f4:	fa23 f302 	lsr.w	r3, r3, r2
 80049f8:	f003 0301 	and.w	r3, r3, #1
 80049fc:	2b00      	cmp	r3, #0
 80049fe:	bf14      	ite	ne
 8004a00:	2300      	movne	r3, #0
 8004a02:	2301      	moveq	r3, #1
 8004a04:	b2db      	uxtb	r3, r3
 8004a06:	2b00      	cmp	r3, #0
 8004a08:	d19f      	bne.n	800494a <HAL_RCC_OscConfig+0x222>
 8004a0a:	e064      	b.n	8004ad6 <HAL_RCC_OscConfig+0x3ae>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004a0c:	f7fd fcae 	bl	800236c <HAL_GetTick>
 8004a10:	f8c7 039c 	str.w	r0, [r7, #924]	; 0x39c
        
        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8004a14:	e012      	b.n	8004a3c <HAL_RCC_OscConfig+0x314>
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8004a16:	f7fd fca9 	bl	800236c <HAL_GetTick>
 8004a1a:	4602      	mov	r2, r0
 8004a1c:	f8d7 339c 	ldr.w	r3, [r7, #924]	; 0x39c
 8004a20:	1ad2      	subs	r2, r2, r3
 8004a22:	f241 3388 	movw	r3, #5000	; 0x1388
 8004a26:	429a      	cmp	r2, r3
 8004a28:	bf94      	ite	ls
 8004a2a:	2300      	movls	r3, #0
 8004a2c:	2301      	movhi	r3, #1
 8004a2e:	b2db      	uxtb	r3, r3
 8004a30:	2b00      	cmp	r3, #0
 8004a32:	d003      	beq.n	8004a3c <HAL_RCC_OscConfig+0x314>
          {
            return HAL_TIMEOUT;
 8004a34:	f04f 0303 	mov.w	r3, #3
 8004a38:	f001 bb07 	b.w	800604a <HAL_RCC_OscConfig+0x1922>
 8004a3c:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8004a40:	f8c7 3338 	str.w	r3, [r7, #824]	; 0x338
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004a44:	f8d7 3338 	ldr.w	r3, [r7, #824]	; 0x338
 8004a48:	fa93 f4a3 	rbit	r4, r3
 8004a4c:	f8c7 4334 	str.w	r4, [r7, #820]	; 0x334
   return(result);
 8004a50:	f8d7 3334 	ldr.w	r3, [r7, #820]	; 0x334
 8004a54:	f8c7 3330 	str.w	r3, [r7, #816]	; 0x330
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8004a58:	f8d7 3330 	ldr.w	r3, [r7, #816]	; 0x330
 8004a5c:	fab3 f483 	clz	r4, r3
 8004a60:	f8c7 432c 	str.w	r4, [r7, #812]	; 0x32c
  return(result);
 8004a64:	f8d7 332c 	ldr.w	r3, [r7, #812]	; 0x32c
 8004a68:	b2db      	uxtb	r3, r3
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8004a6a:	f043 0320 	orr.w	r3, r3, #32
 8004a6e:	b2db      	uxtb	r3, r3
 8004a70:	ea4f 1363 	mov.w	r3, r3, asr #5
 8004a74:	2b01      	cmp	r3, #1
 8004a76:	d105      	bne.n	8004a84 <HAL_RCC_OscConfig+0x35c>
 8004a78:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004a7c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004a80:	681b      	ldr	r3, [r3, #0]
 8004a82:	e004      	b.n	8004a8e <HAL_RCC_OscConfig+0x366>
 8004a84:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004a88:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004a8c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004a8e:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8004a92:	f8c7 2328 	str.w	r2, [r7, #808]	; 0x328
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004a96:	f8d7 2328 	ldr.w	r2, [r7, #808]	; 0x328
 8004a9a:	fa92 f4a2 	rbit	r4, r2
 8004a9e:	f8c7 4324 	str.w	r4, [r7, #804]	; 0x324
   return(result);
 8004aa2:	f8d7 2324 	ldr.w	r2, [r7, #804]	; 0x324
 8004aa6:	f8c7 2320 	str.w	r2, [r7, #800]	; 0x320
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8004aaa:	f8d7 2320 	ldr.w	r2, [r7, #800]	; 0x320
 8004aae:	fab2 f482 	clz	r4, r2
 8004ab2:	f8c7 431c 	str.w	r4, [r7, #796]	; 0x31c
  return(result);
 8004ab6:	f8d7 231c 	ldr.w	r2, [r7, #796]	; 0x31c
 8004aba:	b2d2      	uxtb	r2, r2
 8004abc:	f002 021f 	and.w	r2, r2, #31
 8004ac0:	fa23 f302 	lsr.w	r3, r3, r2
 8004ac4:	f003 0301 	and.w	r3, r3, #1
 8004ac8:	2b00      	cmp	r3, #0
 8004aca:	bf0c      	ite	eq
 8004acc:	2300      	moveq	r3, #0
 8004ace:	2301      	movne	r3, #1
 8004ad0:	b2db      	uxtb	r3, r3
 8004ad2:	2b00      	cmp	r3, #0
 8004ad4:	d19f      	bne.n	8004a16 <HAL_RCC_OscConfig+0x2ee>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8004ad6:	f107 0304 	add.w	r3, r7, #4
 8004ada:	681b      	ldr	r3, [r3, #0]
 8004adc:	681b      	ldr	r3, [r3, #0]
 8004ade:	f003 0302 	and.w	r3, r3, #2
 8004ae2:	2b00      	cmp	r3, #0
 8004ae4:	f000 81f6 	beq.w	8004ed4 <HAL_RCC_OscConfig+0x7ac>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) 
 8004ae8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004aec:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004af0:	689b      	ldr	r3, [r3, #8]
 8004af2:	f003 030c 	and.w	r3, r3, #12
 8004af6:	2b04      	cmp	r3, #4
 8004af8:	d011      	beq.n	8004b1e <HAL_RCC_OscConfig+0x3f6>
 8004afa:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004afe:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004b02:	689b      	ldr	r3, [r3, #8]
 8004b04:	f003 030c 	and.w	r3, r3, #12
 8004b08:	2b0c      	cmp	r3, #12
 8004b0a:	d10b      	bne.n	8004b24 <HAL_RCC_OscConfig+0x3fc>
 8004b0c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004b10:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004b14:	689b      	ldr	r3, [r3, #8]
 8004b16:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8004b1a:	2b00      	cmp	r3, #0
 8004b1c:	d102      	bne.n	8004b24 <HAL_RCC_OscConfig+0x3fc>
 8004b1e:	f04f 0301 	mov.w	r3, #1
 8004b22:	e001      	b.n	8004b28 <HAL_RCC_OscConfig+0x400>
 8004b24:	f04f 0300 	mov.w	r3, #0
 8004b28:	2b00      	cmp	r3, #0
 8004b2a:	f000 8084 	beq.w	8004c36 <HAL_RCC_OscConfig+0x50e>
 8004b2e:	f04f 0302 	mov.w	r3, #2
 8004b32:	f8c7 3318 	str.w	r3, [r7, #792]	; 0x318
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004b36:	f8d7 3318 	ldr.w	r3, [r7, #792]	; 0x318
 8004b3a:	fa93 f4a3 	rbit	r4, r3
 8004b3e:	f8c7 4314 	str.w	r4, [r7, #788]	; 0x314
   return(result);
 8004b42:	f8d7 3314 	ldr.w	r3, [r7, #788]	; 0x314
 8004b46:	f8c7 3310 	str.w	r3, [r7, #784]	; 0x310
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8004b4a:	f8d7 3310 	ldr.w	r3, [r7, #784]	; 0x310
 8004b4e:	fab3 f483 	clz	r4, r3
 8004b52:	f8c7 430c 	str.w	r4, [r7, #780]	; 0x30c
  return(result);
 8004b56:	f8d7 330c 	ldr.w	r3, [r7, #780]	; 0x30c
 8004b5a:	b2db      	uxtb	r3, r3
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8004b5c:	f043 0320 	orr.w	r3, r3, #32
 8004b60:	b2db      	uxtb	r3, r3
 8004b62:	ea4f 1363 	mov.w	r3, r3, asr #5
 8004b66:	2b01      	cmp	r3, #1
 8004b68:	d105      	bne.n	8004b76 <HAL_RCC_OscConfig+0x44e>
 8004b6a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004b6e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004b72:	681b      	ldr	r3, [r3, #0]
 8004b74:	e004      	b.n	8004b80 <HAL_RCC_OscConfig+0x458>
 8004b76:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004b7a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004b7e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004b80:	f04f 0202 	mov.w	r2, #2
 8004b84:	f8c7 2308 	str.w	r2, [r7, #776]	; 0x308
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004b88:	f8d7 2308 	ldr.w	r2, [r7, #776]	; 0x308
 8004b8c:	fa92 f4a2 	rbit	r4, r2
 8004b90:	f8c7 4304 	str.w	r4, [r7, #772]	; 0x304
   return(result);
 8004b94:	f8d7 2304 	ldr.w	r2, [r7, #772]	; 0x304
 8004b98:	f8c7 2300 	str.w	r2, [r7, #768]	; 0x300
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8004b9c:	f8d7 2300 	ldr.w	r2, [r7, #768]	; 0x300
 8004ba0:	fab2 f482 	clz	r4, r2
 8004ba4:	f8c7 42fc 	str.w	r4, [r7, #764]	; 0x2fc
  return(result);
 8004ba8:	f8d7 22fc 	ldr.w	r2, [r7, #764]	; 0x2fc
 8004bac:	b2d2      	uxtb	r2, r2
 8004bae:	f002 021f 	and.w	r2, r2, #31
 8004bb2:	fa23 f302 	lsr.w	r3, r3, r2
 8004bb6:	f003 0301 	and.w	r3, r3, #1
 8004bba:	2b00      	cmp	r3, #0
 8004bbc:	d008      	beq.n	8004bd0 <HAL_RCC_OscConfig+0x4a8>
 8004bbe:	f107 0304 	add.w	r3, r7, #4
 8004bc2:	681b      	ldr	r3, [r3, #0]
 8004bc4:	68db      	ldr	r3, [r3, #12]
 8004bc6:	2b01      	cmp	r3, #1
 8004bc8:	d002      	beq.n	8004bd0 <HAL_RCC_OscConfig+0x4a8>
 8004bca:	f04f 0301 	mov.w	r3, #1
 8004bce:	e001      	b.n	8004bd4 <HAL_RCC_OscConfig+0x4ac>
 8004bd0:	f04f 0300 	mov.w	r3, #0
 8004bd4:	2b00      	cmp	r3, #0
 8004bd6:	d003      	beq.n	8004be0 <HAL_RCC_OscConfig+0x4b8>
      {
        return HAL_ERROR;
 8004bd8:	f04f 0301 	mov.w	r3, #1
 8004bdc:	f001 ba35 	b.w	800604a <HAL_RCC_OscConfig+0x1922>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8004be0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004be4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004be8:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8004bec:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8004bf0:	6852      	ldr	r2, [r2, #4]
 8004bf2:	f422 51f8 	bic.w	r1, r2, #7936	; 0x1f00
 8004bf6:	f107 0204 	add.w	r2, r7, #4
 8004bfa:	6812      	ldr	r2, [r2, #0]
 8004bfc:	6910      	ldr	r0, [r2, #16]
 8004bfe:	f44f 52f8 	mov.w	r2, #7936	; 0x1f00
 8004c02:	f8c7 22f8 	str.w	r2, [r7, #760]	; 0x2f8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004c06:	f8d7 22f8 	ldr.w	r2, [r7, #760]	; 0x2f8
 8004c0a:	fa92 f4a2 	rbit	r4, r2
 8004c0e:	f8c7 42f4 	str.w	r4, [r7, #756]	; 0x2f4
   return(result);
 8004c12:	f8d7 22f4 	ldr.w	r2, [r7, #756]	; 0x2f4
 8004c16:	f8c7 22f0 	str.w	r2, [r7, #752]	; 0x2f0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8004c1a:	f8d7 22f0 	ldr.w	r2, [r7, #752]	; 0x2f0
 8004c1e:	fab2 f482 	clz	r4, r2
 8004c22:	f8c7 42ec 	str.w	r4, [r7, #748]	; 0x2ec
  return(result);
 8004c26:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 8004c2a:	b2d2      	uxtb	r2, r2
 8004c2c:	fa00 f202 	lsl.w	r2, r0, r2
 8004c30:	430a      	orrs	r2, r1
 8004c32:	605a      	str	r2, [r3, #4]
 8004c34:	e14e      	b.n	8004ed4 <HAL_RCC_OscConfig+0x7ac>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8004c36:	f107 0304 	add.w	r3, r7, #4
 8004c3a:	681b      	ldr	r3, [r3, #0]
 8004c3c:	68db      	ldr	r3, [r3, #12]
 8004c3e:	2b00      	cmp	r3, #0
 8004c40:	f000 80ae 	beq.w	8004da0 <HAL_RCC_OscConfig+0x678>
 8004c44:	f04f 0301 	mov.w	r3, #1
 8004c48:	f8c7 32e8 	str.w	r3, [r7, #744]	; 0x2e8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004c4c:	f8d7 32e8 	ldr.w	r3, [r7, #744]	; 0x2e8
 8004c50:	fa93 f4a3 	rbit	r4, r3
 8004c54:	f8c7 42e4 	str.w	r4, [r7, #740]	; 0x2e4
   return(result);
 8004c58:	f8d7 32e4 	ldr.w	r3, [r7, #740]	; 0x2e4
 8004c5c:	f8c7 32e0 	str.w	r3, [r7, #736]	; 0x2e0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8004c60:	f8d7 32e0 	ldr.w	r3, [r7, #736]	; 0x2e0
 8004c64:	fab3 f483 	clz	r4, r3
 8004c68:	f8c7 42dc 	str.w	r4, [r7, #732]	; 0x2dc
  return(result);
 8004c6c:	f8d7 32dc 	ldr.w	r3, [r7, #732]	; 0x2dc
 8004c70:	b2db      	uxtb	r3, r3
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8004c72:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004c76:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8004c7a:	f503 038e 	add.w	r3, r3, #4653056	; 0x470000
 8004c7e:	f04f 0201 	mov.w	r2, #1
 8004c82:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004c84:	f7fd fb72 	bl	800236c <HAL_GetTick>
 8004c88:	f8c7 039c 	str.w	r0, [r7, #924]	; 0x39c
        
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8004c8c:	e010      	b.n	8004cb0 <HAL_RCC_OscConfig+0x588>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8004c8e:	f7fd fb6d 	bl	800236c <HAL_GetTick>
 8004c92:	4602      	mov	r2, r0
 8004c94:	f8d7 339c 	ldr.w	r3, [r7, #924]	; 0x39c
 8004c98:	1ad3      	subs	r3, r2, r3
 8004c9a:	2b64      	cmp	r3, #100	; 0x64
 8004c9c:	bf94      	ite	ls
 8004c9e:	2300      	movls	r3, #0
 8004ca0:	2301      	movhi	r3, #1
 8004ca2:	b2db      	uxtb	r3, r3
 8004ca4:	2b00      	cmp	r3, #0
 8004ca6:	d003      	beq.n	8004cb0 <HAL_RCC_OscConfig+0x588>
          {
            return HAL_TIMEOUT;
 8004ca8:	f04f 0303 	mov.w	r3, #3
 8004cac:	f001 b9cd 	b.w	800604a <HAL_RCC_OscConfig+0x1922>
 8004cb0:	f04f 0302 	mov.w	r3, #2
 8004cb4:	f8c7 32d8 	str.w	r3, [r7, #728]	; 0x2d8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004cb8:	f8d7 32d8 	ldr.w	r3, [r7, #728]	; 0x2d8
 8004cbc:	fa93 f4a3 	rbit	r4, r3
 8004cc0:	f8c7 42d4 	str.w	r4, [r7, #724]	; 0x2d4
   return(result);
 8004cc4:	f8d7 32d4 	ldr.w	r3, [r7, #724]	; 0x2d4
 8004cc8:	f8c7 32d0 	str.w	r3, [r7, #720]	; 0x2d0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8004ccc:	f8d7 32d0 	ldr.w	r3, [r7, #720]	; 0x2d0
 8004cd0:	fab3 f483 	clz	r4, r3
 8004cd4:	f8c7 42cc 	str.w	r4, [r7, #716]	; 0x2cc
  return(result);
 8004cd8:	f8d7 32cc 	ldr.w	r3, [r7, #716]	; 0x2cc
 8004cdc:	b2db      	uxtb	r3, r3
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8004cde:	f043 0320 	orr.w	r3, r3, #32
 8004ce2:	b2db      	uxtb	r3, r3
 8004ce4:	ea4f 1363 	mov.w	r3, r3, asr #5
 8004ce8:	2b01      	cmp	r3, #1
 8004cea:	d105      	bne.n	8004cf8 <HAL_RCC_OscConfig+0x5d0>
 8004cec:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004cf0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004cf4:	681b      	ldr	r3, [r3, #0]
 8004cf6:	e004      	b.n	8004d02 <HAL_RCC_OscConfig+0x5da>
 8004cf8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004cfc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004d00:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004d02:	f04f 0202 	mov.w	r2, #2
 8004d06:	f8c7 22c8 	str.w	r2, [r7, #712]	; 0x2c8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004d0a:	f8d7 22c8 	ldr.w	r2, [r7, #712]	; 0x2c8
 8004d0e:	fa92 f4a2 	rbit	r4, r2
 8004d12:	f8c7 42c4 	str.w	r4, [r7, #708]	; 0x2c4
   return(result);
 8004d16:	f8d7 22c4 	ldr.w	r2, [r7, #708]	; 0x2c4
 8004d1a:	f8c7 22c0 	str.w	r2, [r7, #704]	; 0x2c0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8004d1e:	f8d7 22c0 	ldr.w	r2, [r7, #704]	; 0x2c0
 8004d22:	fab2 f482 	clz	r4, r2
 8004d26:	f8c7 42bc 	str.w	r4, [r7, #700]	; 0x2bc
  return(result);
 8004d2a:	f8d7 22bc 	ldr.w	r2, [r7, #700]	; 0x2bc
 8004d2e:	b2d2      	uxtb	r2, r2
 8004d30:	f002 021f 	and.w	r2, r2, #31
 8004d34:	fa23 f302 	lsr.w	r3, r3, r2
 8004d38:	f003 0301 	and.w	r3, r3, #1
 8004d3c:	2b00      	cmp	r3, #0
 8004d3e:	bf14      	ite	ne
 8004d40:	2300      	movne	r3, #0
 8004d42:	2301      	moveq	r3, #1
 8004d44:	b2db      	uxtb	r3, r3
 8004d46:	2b00      	cmp	r3, #0
 8004d48:	d1a1      	bne.n	8004c8e <HAL_RCC_OscConfig+0x566>
            return HAL_TIMEOUT;
          }
        }
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8004d4a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004d4e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004d52:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8004d56:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8004d5a:	6852      	ldr	r2, [r2, #4]
 8004d5c:	f422 51f8 	bic.w	r1, r2, #7936	; 0x1f00
 8004d60:	f107 0204 	add.w	r2, r7, #4
 8004d64:	6812      	ldr	r2, [r2, #0]
 8004d66:	6910      	ldr	r0, [r2, #16]
 8004d68:	f44f 52f8 	mov.w	r2, #7936	; 0x1f00
 8004d6c:	f8c7 22b8 	str.w	r2, [r7, #696]	; 0x2b8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004d70:	f8d7 22b8 	ldr.w	r2, [r7, #696]	; 0x2b8
 8004d74:	fa92 f4a2 	rbit	r4, r2
 8004d78:	f8c7 42b4 	str.w	r4, [r7, #692]	; 0x2b4
   return(result);
 8004d7c:	f8d7 22b4 	ldr.w	r2, [r7, #692]	; 0x2b4
 8004d80:	f8c7 22b0 	str.w	r2, [r7, #688]	; 0x2b0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8004d84:	f8d7 22b0 	ldr.w	r2, [r7, #688]	; 0x2b0
 8004d88:	fab2 f482 	clz	r4, r2
 8004d8c:	f8c7 42ac 	str.w	r4, [r7, #684]	; 0x2ac
  return(result);
 8004d90:	f8d7 22ac 	ldr.w	r2, [r7, #684]	; 0x2ac
 8004d94:	b2d2      	uxtb	r2, r2
 8004d96:	fa00 f202 	lsl.w	r2, r0, r2
 8004d9a:	430a      	orrs	r2, r1
 8004d9c:	605a      	str	r2, [r3, #4]
 8004d9e:	e099      	b.n	8004ed4 <HAL_RCC_OscConfig+0x7ac>
 8004da0:	f04f 0301 	mov.w	r3, #1
 8004da4:	f8c7 32a8 	str.w	r3, [r7, #680]	; 0x2a8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004da8:	f8d7 32a8 	ldr.w	r3, [r7, #680]	; 0x2a8
 8004dac:	fa93 f4a3 	rbit	r4, r3
 8004db0:	f8c7 42a4 	str.w	r4, [r7, #676]	; 0x2a4
   return(result);
 8004db4:	f8d7 32a4 	ldr.w	r3, [r7, #676]	; 0x2a4
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8004db8:	461a      	mov	r2, r3
 8004dba:	f507 7328 	add.w	r3, r7, #672	; 0x2a0
 8004dbe:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8004dc0:	f507 7328 	add.w	r3, r7, #672	; 0x2a0
 8004dc4:	681b      	ldr	r3, [r3, #0]
 8004dc6:	fab3 f483 	clz	r4, r3
 8004dca:	f507 7327 	add.w	r3, r7, #668	; 0x29c
 8004dce:	601c      	str	r4, [r3, #0]
  return(result);
 8004dd0:	f507 7327 	add.w	r3, r7, #668	; 0x29c
 8004dd4:	681b      	ldr	r3, [r3, #0]
 8004dd6:	b2db      	uxtb	r3, r3
 8004dd8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004ddc:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8004de0:	f503 038e 	add.w	r3, r3, #4653056	; 0x470000
 8004de4:	f04f 0200 	mov.w	r2, #0
 8004de8:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004dea:	f7fd fabf 	bl	800236c <HAL_GetTick>
 8004dee:	f8c7 039c 	str.w	r0, [r7, #924]	; 0x39c
        
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8004df2:	e010      	b.n	8004e16 <HAL_RCC_OscConfig+0x6ee>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8004df4:	f7fd faba 	bl	800236c <HAL_GetTick>
 8004df8:	4602      	mov	r2, r0
 8004dfa:	f8d7 339c 	ldr.w	r3, [r7, #924]	; 0x39c
 8004dfe:	1ad3      	subs	r3, r2, r3
 8004e00:	2b64      	cmp	r3, #100	; 0x64
 8004e02:	bf94      	ite	ls
 8004e04:	2300      	movls	r3, #0
 8004e06:	2301      	movhi	r3, #1
 8004e08:	b2db      	uxtb	r3, r3
 8004e0a:	2b00      	cmp	r3, #0
 8004e0c:	d003      	beq.n	8004e16 <HAL_RCC_OscConfig+0x6ee>
          {
            return HAL_TIMEOUT;
 8004e0e:	f04f 0303 	mov.w	r3, #3
 8004e12:	f001 b91a 	b.w	800604a <HAL_RCC_OscConfig+0x1922>
 8004e16:	f507 7326 	add.w	r3, r7, #664	; 0x298
 8004e1a:	f04f 0202 	mov.w	r2, #2
 8004e1e:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004e20:	f507 7326 	add.w	r3, r7, #664	; 0x298
 8004e24:	681b      	ldr	r3, [r3, #0]
 8004e26:	fa93 f4a3 	rbit	r4, r3
 8004e2a:	f507 7325 	add.w	r3, r7, #660	; 0x294
 8004e2e:	601c      	str	r4, [r3, #0]
   return(result);
 8004e30:	f507 7325 	add.w	r3, r7, #660	; 0x294
 8004e34:	681b      	ldr	r3, [r3, #0]
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8004e36:	461a      	mov	r2, r3
 8004e38:	f507 7324 	add.w	r3, r7, #656	; 0x290
 8004e3c:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8004e3e:	f507 7324 	add.w	r3, r7, #656	; 0x290
 8004e42:	681b      	ldr	r3, [r3, #0]
 8004e44:	fab3 f483 	clz	r4, r3
 8004e48:	f507 7323 	add.w	r3, r7, #652	; 0x28c
 8004e4c:	601c      	str	r4, [r3, #0]
  return(result);
 8004e4e:	f507 7323 	add.w	r3, r7, #652	; 0x28c
 8004e52:	681b      	ldr	r3, [r3, #0]
 8004e54:	b2db      	uxtb	r3, r3
 8004e56:	f043 0320 	orr.w	r3, r3, #32
 8004e5a:	b2db      	uxtb	r3, r3
 8004e5c:	ea4f 1363 	mov.w	r3, r3, asr #5
 8004e60:	2b01      	cmp	r3, #1
 8004e62:	d105      	bne.n	8004e70 <HAL_RCC_OscConfig+0x748>
 8004e64:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004e68:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004e6c:	681b      	ldr	r3, [r3, #0]
 8004e6e:	e004      	b.n	8004e7a <HAL_RCC_OscConfig+0x752>
 8004e70:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004e74:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004e78:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004e7a:	f507 7222 	add.w	r2, r7, #648	; 0x288
 8004e7e:	f04f 0102 	mov.w	r1, #2
 8004e82:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004e84:	f507 7222 	add.w	r2, r7, #648	; 0x288
 8004e88:	6812      	ldr	r2, [r2, #0]
 8004e8a:	fa92 f4a2 	rbit	r4, r2
 8004e8e:	f507 7221 	add.w	r2, r7, #644	; 0x284
 8004e92:	6014      	str	r4, [r2, #0]
   return(result);
 8004e94:	f507 7221 	add.w	r2, r7, #644	; 0x284
 8004e98:	6812      	ldr	r2, [r2, #0]
 8004e9a:	4611      	mov	r1, r2
 8004e9c:	f507 7220 	add.w	r2, r7, #640	; 0x280
 8004ea0:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8004ea2:	f507 7220 	add.w	r2, r7, #640	; 0x280
 8004ea6:	6812      	ldr	r2, [r2, #0]
 8004ea8:	fab2 f482 	clz	r4, r2
 8004eac:	f507 721f 	add.w	r2, r7, #636	; 0x27c
 8004eb0:	6014      	str	r4, [r2, #0]
  return(result);
 8004eb2:	f507 721f 	add.w	r2, r7, #636	; 0x27c
 8004eb6:	6812      	ldr	r2, [r2, #0]
 8004eb8:	b2d2      	uxtb	r2, r2
 8004eba:	f002 021f 	and.w	r2, r2, #31
 8004ebe:	fa23 f302 	lsr.w	r3, r3, r2
 8004ec2:	f003 0301 	and.w	r3, r3, #1
 8004ec6:	2b00      	cmp	r3, #0
 8004ec8:	bf0c      	ite	eq
 8004eca:	2300      	moveq	r3, #0
 8004ecc:	2301      	movne	r3, #1
 8004ece:	b2db      	uxtb	r3, r3
 8004ed0:	2b00      	cmp	r3, #0
 8004ed2:	d18f      	bne.n	8004df4 <HAL_RCC_OscConfig+0x6cc>
        }
      }
    }
  }
  /*----------------------------- MSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8004ed4:	f107 0304 	add.w	r3, r7, #4
 8004ed8:	681b      	ldr	r3, [r3, #0]
 8004eda:	681b      	ldr	r3, [r3, #0]
 8004edc:	f003 0310 	and.w	r3, r3, #16
 8004ee0:	2b00      	cmp	r3, #0
 8004ee2:	f000 8236 	beq.w	8005352 <HAL_RCC_OscConfig+0xc2a>
    /* Check the parameters */
    assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    assert_param(IS_RCC_MSIRANGE(RCC_OscInitStruct->MSIClockRange));
    
    /* Configures the Internal Multi Speed oscillator (MSI) clock range. */
    __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8004ee6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004eea:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004eee:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8004ef2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8004ef6:	6852      	ldr	r2, [r2, #4]
 8004ef8:	f422 4160 	bic.w	r1, r2, #57344	; 0xe000
 8004efc:	f107 0204 	add.w	r2, r7, #4
 8004f00:	6812      	ldr	r2, [r2, #0]
 8004f02:	6a12      	ldr	r2, [r2, #32]
 8004f04:	430a      	orrs	r2, r1
 8004f06:	605a      	str	r2, [r3, #4]
    
    /* Check if MSI is used as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI))
 8004f08:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004f0c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004f10:	689b      	ldr	r3, [r3, #8]
 8004f12:	f003 030c 	and.w	r3, r3, #12
 8004f16:	2b00      	cmp	r3, #0
 8004f18:	bf14      	ite	ne
 8004f1a:	2300      	movne	r3, #0
 8004f1c:	2301      	moveq	r3, #1
 8004f1e:	b2db      	uxtb	r3, r3
 8004f20:	2b00      	cmp	r3, #0
 8004f22:	f000 809f 	beq.w	8005064 <HAL_RCC_OscConfig+0x93c>
 8004f26:	f507 731e 	add.w	r3, r7, #632	; 0x278
 8004f2a:	f44f 7200 	mov.w	r2, #512	; 0x200
 8004f2e:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004f30:	f507 731e 	add.w	r3, r7, #632	; 0x278
 8004f34:	681b      	ldr	r3, [r3, #0]
 8004f36:	fa93 f4a3 	rbit	r4, r3
 8004f3a:	f507 731d 	add.w	r3, r7, #628	; 0x274
 8004f3e:	601c      	str	r4, [r3, #0]
   return(result);
 8004f40:	f507 731d 	add.w	r3, r7, #628	; 0x274
 8004f44:	681b      	ldr	r3, [r3, #0]
    {
      /* When MSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET) && (RCC_OscInitStruct->MSIState != RCC_MSI_ON))
 8004f46:	461a      	mov	r2, r3
 8004f48:	f507 731c 	add.w	r3, r7, #624	; 0x270
 8004f4c:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8004f4e:	f507 731c 	add.w	r3, r7, #624	; 0x270
 8004f52:	681b      	ldr	r3, [r3, #0]
 8004f54:	fab3 f483 	clz	r4, r3
 8004f58:	f507 731b 	add.w	r3, r7, #620	; 0x26c
 8004f5c:	601c      	str	r4, [r3, #0]
  return(result);
 8004f5e:	f507 731b 	add.w	r3, r7, #620	; 0x26c
 8004f62:	681b      	ldr	r3, [r3, #0]
 8004f64:	b2db      	uxtb	r3, r3
 8004f66:	f043 0320 	orr.w	r3, r3, #32
 8004f6a:	b2db      	uxtb	r3, r3
 8004f6c:	ea4f 1363 	mov.w	r3, r3, asr #5
 8004f70:	2b01      	cmp	r3, #1
 8004f72:	d105      	bne.n	8004f80 <HAL_RCC_OscConfig+0x858>
 8004f74:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004f78:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004f7c:	681b      	ldr	r3, [r3, #0]
 8004f7e:	e004      	b.n	8004f8a <HAL_RCC_OscConfig+0x862>
 8004f80:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8004f84:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004f88:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004f8a:	f507 721a 	add.w	r2, r7, #616	; 0x268
 8004f8e:	f44f 7100 	mov.w	r1, #512	; 0x200
 8004f92:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004f94:	f507 721a 	add.w	r2, r7, #616	; 0x268
 8004f98:	6812      	ldr	r2, [r2, #0]
 8004f9a:	fa92 f4a2 	rbit	r4, r2
 8004f9e:	f507 7219 	add.w	r2, r7, #612	; 0x264
 8004fa2:	6014      	str	r4, [r2, #0]
   return(result);
 8004fa4:	f507 7219 	add.w	r2, r7, #612	; 0x264
 8004fa8:	6812      	ldr	r2, [r2, #0]
 8004faa:	4611      	mov	r1, r2
 8004fac:	f507 7218 	add.w	r2, r7, #608	; 0x260
 8004fb0:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8004fb2:	f507 7218 	add.w	r2, r7, #608	; 0x260
 8004fb6:	6812      	ldr	r2, [r2, #0]
 8004fb8:	fab2 f482 	clz	r4, r2
 8004fbc:	f507 7217 	add.w	r2, r7, #604	; 0x25c
 8004fc0:	6014      	str	r4, [r2, #0]
  return(result);
 8004fc2:	f507 7217 	add.w	r2, r7, #604	; 0x25c
 8004fc6:	6812      	ldr	r2, [r2, #0]
 8004fc8:	b2d2      	uxtb	r2, r2
 8004fca:	f002 021f 	and.w	r2, r2, #31
 8004fce:	fa23 f302 	lsr.w	r3, r3, r2
 8004fd2:	f003 0301 	and.w	r3, r3, #1
 8004fd6:	2b00      	cmp	r3, #0
 8004fd8:	d008      	beq.n	8004fec <HAL_RCC_OscConfig+0x8c4>
 8004fda:	f107 0304 	add.w	r3, r7, #4
 8004fde:	681b      	ldr	r3, [r3, #0]
 8004fe0:	699b      	ldr	r3, [r3, #24]
 8004fe2:	2b01      	cmp	r3, #1
 8004fe4:	d002      	beq.n	8004fec <HAL_RCC_OscConfig+0x8c4>
 8004fe6:	f04f 0301 	mov.w	r3, #1
 8004fea:	e001      	b.n	8004ff0 <HAL_RCC_OscConfig+0x8c8>
 8004fec:	f04f 0300 	mov.w	r3, #0
 8004ff0:	2b00      	cmp	r3, #0
 8004ff2:	d003      	beq.n	8004ffc <HAL_RCC_OscConfig+0x8d4>
      {
        return HAL_ERROR;
 8004ff4:	f04f 0301 	mov.w	r3, #1
 8004ff8:	f001 b827 	b.w	800604a <HAL_RCC_OscConfig+0x1922>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Multi Speed oscillator (MSI) calibration value. */
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8004ffc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8005000:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005004:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8005008:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800500c:	6852      	ldr	r2, [r2, #4]
 800500e:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
 8005012:	f107 0204 	add.w	r2, r7, #4
 8005016:	6812      	ldr	r2, [r2, #0]
 8005018:	69d0      	ldr	r0, [r2, #28]
 800501a:	f507 7216 	add.w	r2, r7, #600	; 0x258
 800501e:	f04f 447f 	mov.w	r4, #4278190080	; 0xff000000
 8005022:	6014      	str	r4, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005024:	f507 7216 	add.w	r2, r7, #600	; 0x258
 8005028:	6812      	ldr	r2, [r2, #0]
 800502a:	fa92 f4a2 	rbit	r4, r2
 800502e:	f507 7215 	add.w	r2, r7, #596	; 0x254
 8005032:	6014      	str	r4, [r2, #0]
   return(result);
 8005034:	f507 7215 	add.w	r2, r7, #596	; 0x254
 8005038:	6812      	ldr	r2, [r2, #0]
 800503a:	4614      	mov	r4, r2
 800503c:	f507 7214 	add.w	r2, r7, #592	; 0x250
 8005040:	6014      	str	r4, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8005042:	f507 7214 	add.w	r2, r7, #592	; 0x250
 8005046:	6812      	ldr	r2, [r2, #0]
 8005048:	fab2 f482 	clz	r4, r2
 800504c:	f507 7213 	add.w	r2, r7, #588	; 0x24c
 8005050:	6014      	str	r4, [r2, #0]
  return(result);
 8005052:	f507 7213 	add.w	r2, r7, #588	; 0x24c
 8005056:	6812      	ldr	r2, [r2, #0]
 8005058:	b2d2      	uxtb	r2, r2
 800505a:	fa00 f202 	lsl.w	r2, r0, r2
 800505e:	430a      	orrs	r2, r1
 8005060:	605a      	str	r2, [r3, #4]
 8005062:	e176      	b.n	8005352 <HAL_RCC_OscConfig+0xc2a>
      }
    }
    else
    {
      /* Check the MSI State */
      if((RCC_OscInitStruct->MSIState)!= RCC_MSI_OFF)
 8005064:	f107 0304 	add.w	r3, r7, #4
 8005068:	681b      	ldr	r3, [r3, #0]
 800506a:	699b      	ldr	r3, [r3, #24]
 800506c:	2b00      	cmp	r3, #0
 800506e:	f000 80d2 	beq.w	8005216 <HAL_RCC_OscConfig+0xaee>
 8005072:	f507 7312 	add.w	r3, r7, #584	; 0x248
 8005076:	f44f 7280 	mov.w	r2, #256	; 0x100
 800507a:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800507c:	f507 7312 	add.w	r3, r7, #584	; 0x248
 8005080:	681b      	ldr	r3, [r3, #0]
 8005082:	fa93 f4a3 	rbit	r4, r3
 8005086:	f507 7311 	add.w	r3, r7, #580	; 0x244
 800508a:	601c      	str	r4, [r3, #0]
   return(result);
 800508c:	f507 7311 	add.w	r3, r7, #580	; 0x244
 8005090:	681b      	ldr	r3, [r3, #0]
      {
        /* Enable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 8005092:	461a      	mov	r2, r3
 8005094:	f507 7310 	add.w	r3, r7, #576	; 0x240
 8005098:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 800509a:	f507 7310 	add.w	r3, r7, #576	; 0x240
 800509e:	681b      	ldr	r3, [r3, #0]
 80050a0:	fab3 f483 	clz	r4, r3
 80050a4:	f507 730f 	add.w	r3, r7, #572	; 0x23c
 80050a8:	601c      	str	r4, [r3, #0]
  return(result);
 80050aa:	f507 730f 	add.w	r3, r7, #572	; 0x23c
 80050ae:	681b      	ldr	r3, [r3, #0]
 80050b0:	b2db      	uxtb	r3, r3
 80050b2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80050b6:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 80050ba:	f503 038e 	add.w	r3, r3, #4653056	; 0x470000
 80050be:	f04f 0201 	mov.w	r2, #1
 80050c2:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80050c4:	f7fd f952 	bl	800236c <HAL_GetTick>
 80050c8:	f8c7 039c 	str.w	r0, [r7, #924]	; 0x39c
        
        /* Wait till MSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
 80050cc:	e010      	b.n	80050f0 <HAL_RCC_OscConfig+0x9c8>
        {
          if((HAL_GetTick() - tickstart ) > MSI_TIMEOUT_VALUE)
 80050ce:	f7fd f94d 	bl	800236c <HAL_GetTick>
 80050d2:	4602      	mov	r2, r0
 80050d4:	f8d7 339c 	ldr.w	r3, [r7, #924]	; 0x39c
 80050d8:	1ad3      	subs	r3, r2, r3
 80050da:	2b64      	cmp	r3, #100	; 0x64
 80050dc:	bf94      	ite	ls
 80050de:	2300      	movls	r3, #0
 80050e0:	2301      	movhi	r3, #1
 80050e2:	b2db      	uxtb	r3, r3
 80050e4:	2b00      	cmp	r3, #0
 80050e6:	d003      	beq.n	80050f0 <HAL_RCC_OscConfig+0x9c8>
          {
            return HAL_TIMEOUT;
 80050e8:	f04f 0303 	mov.w	r3, #3
 80050ec:	f000 bfad 	b.w	800604a <HAL_RCC_OscConfig+0x1922>
 80050f0:	f507 730e 	add.w	r3, r7, #568	; 0x238
 80050f4:	f44f 7200 	mov.w	r2, #512	; 0x200
 80050f8:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80050fa:	f507 730e 	add.w	r3, r7, #568	; 0x238
 80050fe:	681b      	ldr	r3, [r3, #0]
 8005100:	fa93 f4a3 	rbit	r4, r3
 8005104:	f507 730d 	add.w	r3, r7, #564	; 0x234
 8005108:	601c      	str	r4, [r3, #0]
   return(result);
 800510a:	f507 730d 	add.w	r3, r7, #564	; 0x234
 800510e:	681b      	ldr	r3, [r3, #0]
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till MSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
 8005110:	461a      	mov	r2, r3
 8005112:	f507 730c 	add.w	r3, r7, #560	; 0x230
 8005116:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8005118:	f507 730c 	add.w	r3, r7, #560	; 0x230
 800511c:	681b      	ldr	r3, [r3, #0]
 800511e:	fab3 f483 	clz	r4, r3
 8005122:	f507 730b 	add.w	r3, r7, #556	; 0x22c
 8005126:	601c      	str	r4, [r3, #0]
  return(result);
 8005128:	f507 730b 	add.w	r3, r7, #556	; 0x22c
 800512c:	681b      	ldr	r3, [r3, #0]
 800512e:	b2db      	uxtb	r3, r3
 8005130:	f043 0320 	orr.w	r3, r3, #32
 8005134:	b2db      	uxtb	r3, r3
 8005136:	ea4f 1363 	mov.w	r3, r3, asr #5
 800513a:	2b01      	cmp	r3, #1
 800513c:	d105      	bne.n	800514a <HAL_RCC_OscConfig+0xa22>
 800513e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8005142:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005146:	681b      	ldr	r3, [r3, #0]
 8005148:	e004      	b.n	8005154 <HAL_RCC_OscConfig+0xa2c>
 800514a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800514e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005152:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005154:	f507 720a 	add.w	r2, r7, #552	; 0x228
 8005158:	f44f 7100 	mov.w	r1, #512	; 0x200
 800515c:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800515e:	f507 720a 	add.w	r2, r7, #552	; 0x228
 8005162:	6812      	ldr	r2, [r2, #0]
 8005164:	fa92 f4a2 	rbit	r4, r2
 8005168:	f507 7209 	add.w	r2, r7, #548	; 0x224
 800516c:	6014      	str	r4, [r2, #0]
   return(result);
 800516e:	f507 7209 	add.w	r2, r7, #548	; 0x224
 8005172:	6812      	ldr	r2, [r2, #0]
 8005174:	4611      	mov	r1, r2
 8005176:	f507 7208 	add.w	r2, r7, #544	; 0x220
 800517a:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 800517c:	f507 7208 	add.w	r2, r7, #544	; 0x220
 8005180:	6812      	ldr	r2, [r2, #0]
 8005182:	fab2 f482 	clz	r4, r2
 8005186:	f507 7207 	add.w	r2, r7, #540	; 0x21c
 800518a:	6014      	str	r4, [r2, #0]
  return(result);
 800518c:	f507 7207 	add.w	r2, r7, #540	; 0x21c
 8005190:	6812      	ldr	r2, [r2, #0]
 8005192:	b2d2      	uxtb	r2, r2
 8005194:	f002 021f 	and.w	r2, r2, #31
 8005198:	fa23 f302 	lsr.w	r3, r3, r2
 800519c:	f003 0301 	and.w	r3, r3, #1
 80051a0:	2b00      	cmp	r3, #0
 80051a2:	bf14      	ite	ne
 80051a4:	2300      	movne	r3, #0
 80051a6:	2301      	moveq	r3, #1
 80051a8:	b2db      	uxtb	r3, r3
 80051aa:	2b00      	cmp	r3, #0
 80051ac:	d18f      	bne.n	80050ce <HAL_RCC_OscConfig+0x9a6>
            return HAL_TIMEOUT;
          }
        }
        
        /* Adjusts the Multi Speed oscillator (MSI) calibration value. */
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80051ae:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80051b2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80051b6:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80051ba:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80051be:	6852      	ldr	r2, [r2, #4]
 80051c0:	f022 417f 	bic.w	r1, r2, #4278190080	; 0xff000000
 80051c4:	f107 0204 	add.w	r2, r7, #4
 80051c8:	6812      	ldr	r2, [r2, #0]
 80051ca:	69d0      	ldr	r0, [r2, #28]
 80051cc:	f507 7206 	add.w	r2, r7, #536	; 0x218
 80051d0:	f04f 447f 	mov.w	r4, #4278190080	; 0xff000000
 80051d4:	6014      	str	r4, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80051d6:	f507 7206 	add.w	r2, r7, #536	; 0x218
 80051da:	6812      	ldr	r2, [r2, #0]
 80051dc:	fa92 f4a2 	rbit	r4, r2
 80051e0:	f507 7205 	add.w	r2, r7, #532	; 0x214
 80051e4:	6014      	str	r4, [r2, #0]
   return(result);
 80051e6:	f507 7205 	add.w	r2, r7, #532	; 0x214
 80051ea:	6812      	ldr	r2, [r2, #0]
 80051ec:	4614      	mov	r4, r2
 80051ee:	f507 7204 	add.w	r2, r7, #528	; 0x210
 80051f2:	6014      	str	r4, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80051f4:	f507 7204 	add.w	r2, r7, #528	; 0x210
 80051f8:	6812      	ldr	r2, [r2, #0]
 80051fa:	fab2 f482 	clz	r4, r2
 80051fe:	f507 7203 	add.w	r2, r7, #524	; 0x20c
 8005202:	6014      	str	r4, [r2, #0]
  return(result);
 8005204:	f507 7203 	add.w	r2, r7, #524	; 0x20c
 8005208:	6812      	ldr	r2, [r2, #0]
 800520a:	b2d2      	uxtb	r2, r2
 800520c:	fa00 f202 	lsl.w	r2, r0, r2
 8005210:	430a      	orrs	r2, r1
 8005212:	605a      	str	r2, [r3, #4]
 8005214:	e09d      	b.n	8005352 <HAL_RCC_OscConfig+0xc2a>
 8005216:	f507 7302 	add.w	r3, r7, #520	; 0x208
 800521a:	f44f 7280 	mov.w	r2, #256	; 0x100
 800521e:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005220:	f507 7302 	add.w	r3, r7, #520	; 0x208
 8005224:	681b      	ldr	r3, [r3, #0]
 8005226:	fa93 f4a3 	rbit	r4, r3
 800522a:	f507 7301 	add.w	r3, r7, #516	; 0x204
 800522e:	601c      	str	r4, [r3, #0]
   return(result);
 8005230:	f507 7301 	add.w	r3, r7, #516	; 0x204
 8005234:	681b      	ldr	r3, [r3, #0]
      }
      else
      {
        /* Disable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 8005236:	461a      	mov	r2, r3
 8005238:	f507 7300 	add.w	r3, r7, #512	; 0x200
 800523c:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 800523e:	f507 7300 	add.w	r3, r7, #512	; 0x200
 8005242:	681b      	ldr	r3, [r3, #0]
 8005244:	fab3 f483 	clz	r4, r3
 8005248:	f507 73fe 	add.w	r3, r7, #508	; 0x1fc
 800524c:	601c      	str	r4, [r3, #0]
  return(result);
 800524e:	f507 73fe 	add.w	r3, r7, #508	; 0x1fc
 8005252:	681b      	ldr	r3, [r3, #0]
 8005254:	b2db      	uxtb	r3, r3
 8005256:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800525a:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 800525e:	f503 038e 	add.w	r3, r3, #4653056	; 0x470000
 8005262:	f04f 0200 	mov.w	r2, #0
 8005266:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8005268:	f7fd f880 	bl	800236c <HAL_GetTick>
 800526c:	f8c7 039c 	str.w	r0, [r7, #924]	; 0x39c
        
        /* Wait till MSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET)
 8005270:	e010      	b.n	8005294 <HAL_RCC_OscConfig+0xb6c>
        {
          if((HAL_GetTick() - tickstart ) > MSI_TIMEOUT_VALUE)
 8005272:	f7fd f87b 	bl	800236c <HAL_GetTick>
 8005276:	4602      	mov	r2, r0
 8005278:	f8d7 339c 	ldr.w	r3, [r7, #924]	; 0x39c
 800527c:	1ad3      	subs	r3, r2, r3
 800527e:	2b64      	cmp	r3, #100	; 0x64
 8005280:	bf94      	ite	ls
 8005282:	2300      	movls	r3, #0
 8005284:	2301      	movhi	r3, #1
 8005286:	b2db      	uxtb	r3, r3
 8005288:	2b00      	cmp	r3, #0
 800528a:	d003      	beq.n	8005294 <HAL_RCC_OscConfig+0xb6c>
          {
            return HAL_TIMEOUT;
 800528c:	f04f 0303 	mov.w	r3, #3
 8005290:	f000 bedb 	b.w	800604a <HAL_RCC_OscConfig+0x1922>
 8005294:	f507 73fc 	add.w	r3, r7, #504	; 0x1f8
 8005298:	f44f 7200 	mov.w	r2, #512	; 0x200
 800529c:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800529e:	f507 73fc 	add.w	r3, r7, #504	; 0x1f8
 80052a2:	681b      	ldr	r3, [r3, #0]
 80052a4:	fa93 f4a3 	rbit	r4, r3
 80052a8:	f507 73fa 	add.w	r3, r7, #500	; 0x1f4
 80052ac:	601c      	str	r4, [r3, #0]
   return(result);
 80052ae:	f507 73fa 	add.w	r3, r7, #500	; 0x1f4
 80052b2:	681b      	ldr	r3, [r3, #0]
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till MSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET)
 80052b4:	461a      	mov	r2, r3
 80052b6:	f507 73f8 	add.w	r3, r7, #496	; 0x1f0
 80052ba:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80052bc:	f507 73f8 	add.w	r3, r7, #496	; 0x1f0
 80052c0:	681b      	ldr	r3, [r3, #0]
 80052c2:	fab3 f483 	clz	r4, r3
 80052c6:	f507 73f6 	add.w	r3, r7, #492	; 0x1ec
 80052ca:	601c      	str	r4, [r3, #0]
  return(result);
 80052cc:	f507 73f6 	add.w	r3, r7, #492	; 0x1ec
 80052d0:	681b      	ldr	r3, [r3, #0]
 80052d2:	b2db      	uxtb	r3, r3
 80052d4:	f043 0320 	orr.w	r3, r3, #32
 80052d8:	b2db      	uxtb	r3, r3
 80052da:	ea4f 1363 	mov.w	r3, r3, asr #5
 80052de:	2b01      	cmp	r3, #1
 80052e0:	d105      	bne.n	80052ee <HAL_RCC_OscConfig+0xbc6>
 80052e2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80052e6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80052ea:	681b      	ldr	r3, [r3, #0]
 80052ec:	e004      	b.n	80052f8 <HAL_RCC_OscConfig+0xbd0>
 80052ee:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80052f2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80052f6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80052f8:	f507 72f4 	add.w	r2, r7, #488	; 0x1e8
 80052fc:	f44f 7100 	mov.w	r1, #512	; 0x200
 8005300:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005302:	f507 72f4 	add.w	r2, r7, #488	; 0x1e8
 8005306:	6812      	ldr	r2, [r2, #0]
 8005308:	fa92 f4a2 	rbit	r4, r2
 800530c:	f507 72f2 	add.w	r2, r7, #484	; 0x1e4
 8005310:	6014      	str	r4, [r2, #0]
   return(result);
 8005312:	f507 72f2 	add.w	r2, r7, #484	; 0x1e4
 8005316:	6812      	ldr	r2, [r2, #0]
 8005318:	4611      	mov	r1, r2
 800531a:	f507 72f0 	add.w	r2, r7, #480	; 0x1e0
 800531e:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8005320:	f507 72f0 	add.w	r2, r7, #480	; 0x1e0
 8005324:	6812      	ldr	r2, [r2, #0]
 8005326:	fab2 f482 	clz	r4, r2
 800532a:	f507 72ee 	add.w	r2, r7, #476	; 0x1dc
 800532e:	6014      	str	r4, [r2, #0]
  return(result);
 8005330:	f507 72ee 	add.w	r2, r7, #476	; 0x1dc
 8005334:	6812      	ldr	r2, [r2, #0]
 8005336:	b2d2      	uxtb	r2, r2
 8005338:	f002 021f 	and.w	r2, r2, #31
 800533c:	fa23 f302 	lsr.w	r3, r3, r2
 8005340:	f003 0301 	and.w	r3, r3, #1
 8005344:	2b00      	cmp	r3, #0
 8005346:	bf0c      	ite	eq
 8005348:	2300      	moveq	r3, #0
 800534a:	2301      	movne	r3, #1
 800534c:	b2db      	uxtb	r3, r3
 800534e:	2b00      	cmp	r3, #0
 8005350:	d18f      	bne.n	8005272 <HAL_RCC_OscConfig+0xb4a>
        } 
      }
    }
  }  
  /*------------------------------ LSI Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8005352:	f107 0304 	add.w	r3, r7, #4
 8005356:	681b      	ldr	r3, [r3, #0]
 8005358:	681b      	ldr	r3, [r3, #0]
 800535a:	f003 0308 	and.w	r3, r3, #8
 800535e:	2b00      	cmp	r3, #0
 8005360:	f000 8148 	beq.w	80055f4 <HAL_RCC_OscConfig+0xecc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    
    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8005364:	f107 0304 	add.w	r3, r7, #4
 8005368:	681b      	ldr	r3, [r3, #0]
 800536a:	695b      	ldr	r3, [r3, #20]
 800536c:	2b00      	cmp	r3, #0
 800536e:	f000 80a1 	beq.w	80054b4 <HAL_RCC_OscConfig+0xd8c>
 8005372:	f507 73ec 	add.w	r3, r7, #472	; 0x1d8
 8005376:	f04f 0201 	mov.w	r2, #1
 800537a:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800537c:	f507 73ec 	add.w	r3, r7, #472	; 0x1d8
 8005380:	681b      	ldr	r3, [r3, #0]
 8005382:	fa93 f4a3 	rbit	r4, r3
 8005386:	f507 73ea 	add.w	r3, r7, #468	; 0x1d4
 800538a:	601c      	str	r4, [r3, #0]
   return(result);
 800538c:	f507 73ea 	add.w	r3, r7, #468	; 0x1d4
 8005390:	681b      	ldr	r3, [r3, #0]
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8005392:	461a      	mov	r2, r3
 8005394:	f507 73e8 	add.w	r3, r7, #464	; 0x1d0
 8005398:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 800539a:	f507 73e8 	add.w	r3, r7, #464	; 0x1d0
 800539e:	681b      	ldr	r3, [r3, #0]
 80053a0:	fab3 f483 	clz	r4, r3
 80053a4:	f507 73e6 	add.w	r3, r7, #460	; 0x1cc
 80053a8:	601c      	str	r4, [r3, #0]
  return(result);
 80053aa:	f507 73e6 	add.w	r3, r7, #460	; 0x1cc
 80053ae:	681b      	ldr	r3, [r3, #0]
 80053b0:	b2db      	uxtb	r3, r3
 80053b2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80053b6:	461a      	mov	r2, r3
 80053b8:	f44f 63d0 	mov.w	r3, #1664	; 0x680
 80053bc:	f2c4 2347 	movt	r3, #16967	; 0x4247
 80053c0:	18d3      	adds	r3, r2, r3
 80053c2:	f04f 0201 	mov.w	r2, #1
 80053c6:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80053c8:	f7fc ffd0 	bl	800236c <HAL_GetTick>
 80053cc:	f8c7 039c 	str.w	r0, [r7, #924]	; 0x39c
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80053d0:	e010      	b.n	80053f4 <HAL_RCC_OscConfig+0xccc>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80053d2:	f7fc ffcb 	bl	800236c <HAL_GetTick>
 80053d6:	4602      	mov	r2, r0
 80053d8:	f8d7 339c 	ldr.w	r3, [r7, #924]	; 0x39c
 80053dc:	1ad3      	subs	r3, r2, r3
 80053de:	2b64      	cmp	r3, #100	; 0x64
 80053e0:	bf94      	ite	ls
 80053e2:	2300      	movls	r3, #0
 80053e4:	2301      	movhi	r3, #1
 80053e6:	b2db      	uxtb	r3, r3
 80053e8:	2b00      	cmp	r3, #0
 80053ea:	d003      	beq.n	80053f4 <HAL_RCC_OscConfig+0xccc>
        {
          return HAL_TIMEOUT;
 80053ec:	f04f 0303 	mov.w	r3, #3
 80053f0:	f000 be2b 	b.w	800604a <HAL_RCC_OscConfig+0x1922>
 80053f4:	f507 73e4 	add.w	r3, r7, #456	; 0x1c8
 80053f8:	f04f 0202 	mov.w	r2, #2
 80053fc:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80053fe:	f507 73e4 	add.w	r3, r7, #456	; 0x1c8
 8005402:	681b      	ldr	r3, [r3, #0]
 8005404:	fa93 f4a3 	rbit	r4, r3
 8005408:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 800540c:	601c      	str	r4, [r3, #0]
   return(result);
 800540e:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8005412:	681b      	ldr	r3, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8005414:	461a      	mov	r2, r3
 8005416:	f507 73e0 	add.w	r3, r7, #448	; 0x1c0
 800541a:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 800541c:	f507 73e0 	add.w	r3, r7, #448	; 0x1c0
 8005420:	681b      	ldr	r3, [r3, #0]
 8005422:	fab3 f483 	clz	r4, r3
 8005426:	f507 73de 	add.w	r3, r7, #444	; 0x1bc
 800542a:	601c      	str	r4, [r3, #0]
  return(result);
 800542c:	f507 73de 	add.w	r3, r7, #444	; 0x1bc
 8005430:	681b      	ldr	r3, [r3, #0]
 8005432:	b2db      	uxtb	r3, r3
 8005434:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 8005438:	b2db      	uxtb	r3, r3
 800543a:	ea4f 1363 	mov.w	r3, r3, asr #5
 800543e:	2b01      	cmp	r3, #1
 8005440:	d105      	bne.n	800544e <HAL_RCC_OscConfig+0xd26>
 8005442:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8005446:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800544a:	681b      	ldr	r3, [r3, #0]
 800544c:	e004      	b.n	8005458 <HAL_RCC_OscConfig+0xd30>
 800544e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8005452:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005456:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005458:	f507 72dc 	add.w	r2, r7, #440	; 0x1b8
 800545c:	f04f 0102 	mov.w	r1, #2
 8005460:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005462:	f507 72dc 	add.w	r2, r7, #440	; 0x1b8
 8005466:	6812      	ldr	r2, [r2, #0]
 8005468:	fa92 f4a2 	rbit	r4, r2
 800546c:	f507 72da 	add.w	r2, r7, #436	; 0x1b4
 8005470:	6014      	str	r4, [r2, #0]
   return(result);
 8005472:	f507 72da 	add.w	r2, r7, #436	; 0x1b4
 8005476:	6812      	ldr	r2, [r2, #0]
 8005478:	4611      	mov	r1, r2
 800547a:	f507 72d8 	add.w	r2, r7, #432	; 0x1b0
 800547e:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8005480:	f507 72d8 	add.w	r2, r7, #432	; 0x1b0
 8005484:	6812      	ldr	r2, [r2, #0]
 8005486:	fab2 f482 	clz	r4, r2
 800548a:	f507 72d6 	add.w	r2, r7, #428	; 0x1ac
 800548e:	6014      	str	r4, [r2, #0]
  return(result);
 8005490:	f507 72d6 	add.w	r2, r7, #428	; 0x1ac
 8005494:	6812      	ldr	r2, [r2, #0]
 8005496:	b2d2      	uxtb	r2, r2
 8005498:	f002 021f 	and.w	r2, r2, #31
 800549c:	fa23 f302 	lsr.w	r3, r3, r2
 80054a0:	f003 0301 	and.w	r3, r3, #1
 80054a4:	2b00      	cmp	r3, #0
 80054a6:	bf14      	ite	ne
 80054a8:	2300      	movne	r3, #0
 80054aa:	2301      	moveq	r3, #1
 80054ac:	b2db      	uxtb	r3, r3
 80054ae:	2b00      	cmp	r3, #0
 80054b0:	d18f      	bne.n	80053d2 <HAL_RCC_OscConfig+0xcaa>
 80054b2:	e09f      	b.n	80055f4 <HAL_RCC_OscConfig+0xecc>
 80054b4:	f507 73d4 	add.w	r3, r7, #424	; 0x1a8
 80054b8:	f04f 0201 	mov.w	r2, #1
 80054bc:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80054be:	f507 73d4 	add.w	r3, r7, #424	; 0x1a8
 80054c2:	681b      	ldr	r3, [r3, #0]
 80054c4:	fa93 f4a3 	rbit	r4, r3
 80054c8:	f507 73d2 	add.w	r3, r7, #420	; 0x1a4
 80054cc:	601c      	str	r4, [r3, #0]
   return(result);
 80054ce:	f507 73d2 	add.w	r3, r7, #420	; 0x1a4
 80054d2:	681b      	ldr	r3, [r3, #0]
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 80054d4:	461a      	mov	r2, r3
 80054d6:	f507 73d0 	add.w	r3, r7, #416	; 0x1a0
 80054da:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80054dc:	f507 73d0 	add.w	r3, r7, #416	; 0x1a0
 80054e0:	681b      	ldr	r3, [r3, #0]
 80054e2:	fab3 f483 	clz	r4, r3
 80054e6:	f507 73ce 	add.w	r3, r7, #412	; 0x19c
 80054ea:	601c      	str	r4, [r3, #0]
  return(result);
 80054ec:	f507 73ce 	add.w	r3, r7, #412	; 0x19c
 80054f0:	681b      	ldr	r3, [r3, #0]
 80054f2:	b2db      	uxtb	r3, r3
 80054f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80054f8:	461a      	mov	r2, r3
 80054fa:	f44f 63d0 	mov.w	r3, #1664	; 0x680
 80054fe:	f2c4 2347 	movt	r3, #16967	; 0x4247
 8005502:	18d3      	adds	r3, r2, r3
 8005504:	f04f 0200 	mov.w	r2, #0
 8005508:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800550a:	f7fc ff2f 	bl	800236c <HAL_GetTick>
 800550e:	f8c7 039c 	str.w	r0, [r7, #924]	; 0x39c
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8005512:	e010      	b.n	8005536 <HAL_RCC_OscConfig+0xe0e>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8005514:	f7fc ff2a 	bl	800236c <HAL_GetTick>
 8005518:	4602      	mov	r2, r0
 800551a:	f8d7 339c 	ldr.w	r3, [r7, #924]	; 0x39c
 800551e:	1ad3      	subs	r3, r2, r3
 8005520:	2b64      	cmp	r3, #100	; 0x64
 8005522:	bf94      	ite	ls
 8005524:	2300      	movls	r3, #0
 8005526:	2301      	movhi	r3, #1
 8005528:	b2db      	uxtb	r3, r3
 800552a:	2b00      	cmp	r3, #0
 800552c:	d003      	beq.n	8005536 <HAL_RCC_OscConfig+0xe0e>
        {
          return HAL_TIMEOUT;
 800552e:	f04f 0303 	mov.w	r3, #3
 8005532:	f000 bd8a 	b.w	800604a <HAL_RCC_OscConfig+0x1922>
 8005536:	f507 73cc 	add.w	r3, r7, #408	; 0x198
 800553a:	f04f 0202 	mov.w	r2, #2
 800553e:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005540:	f507 73cc 	add.w	r3, r7, #408	; 0x198
 8005544:	681b      	ldr	r3, [r3, #0]
 8005546:	fa93 f4a3 	rbit	r4, r3
 800554a:	f507 73ca 	add.w	r3, r7, #404	; 0x194
 800554e:	601c      	str	r4, [r3, #0]
   return(result);
 8005550:	f507 73ca 	add.w	r3, r7, #404	; 0x194
 8005554:	681b      	ldr	r3, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8005556:	461a      	mov	r2, r3
 8005558:	f507 73c8 	add.w	r3, r7, #400	; 0x190
 800555c:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 800555e:	f507 73c8 	add.w	r3, r7, #400	; 0x190
 8005562:	681b      	ldr	r3, [r3, #0]
 8005564:	fab3 f483 	clz	r4, r3
 8005568:	f507 73c6 	add.w	r3, r7, #396	; 0x18c
 800556c:	601c      	str	r4, [r3, #0]
  return(result);
 800556e:	f507 73c6 	add.w	r3, r7, #396	; 0x18c
 8005572:	681b      	ldr	r3, [r3, #0]
 8005574:	b2db      	uxtb	r3, r3
 8005576:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 800557a:	b2db      	uxtb	r3, r3
 800557c:	ea4f 1363 	mov.w	r3, r3, asr #5
 8005580:	2b01      	cmp	r3, #1
 8005582:	d105      	bne.n	8005590 <HAL_RCC_OscConfig+0xe68>
 8005584:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8005588:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800558c:	681b      	ldr	r3, [r3, #0]
 800558e:	e004      	b.n	800559a <HAL_RCC_OscConfig+0xe72>
 8005590:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8005594:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005598:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800559a:	f507 72c4 	add.w	r2, r7, #392	; 0x188
 800559e:	f04f 0102 	mov.w	r1, #2
 80055a2:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80055a4:	f507 72c4 	add.w	r2, r7, #392	; 0x188
 80055a8:	6812      	ldr	r2, [r2, #0]
 80055aa:	fa92 f4a2 	rbit	r4, r2
 80055ae:	f507 72c2 	add.w	r2, r7, #388	; 0x184
 80055b2:	6014      	str	r4, [r2, #0]
   return(result);
 80055b4:	f507 72c2 	add.w	r2, r7, #388	; 0x184
 80055b8:	6812      	ldr	r2, [r2, #0]
 80055ba:	4611      	mov	r1, r2
 80055bc:	f507 72c0 	add.w	r2, r7, #384	; 0x180
 80055c0:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80055c2:	f507 72c0 	add.w	r2, r7, #384	; 0x180
 80055c6:	6812      	ldr	r2, [r2, #0]
 80055c8:	fab2 f482 	clz	r4, r2
 80055cc:	f507 72be 	add.w	r2, r7, #380	; 0x17c
 80055d0:	6014      	str	r4, [r2, #0]
  return(result);
 80055d2:	f507 72be 	add.w	r2, r7, #380	; 0x17c
 80055d6:	6812      	ldr	r2, [r2, #0]
 80055d8:	b2d2      	uxtb	r2, r2
 80055da:	f002 021f 	and.w	r2, r2, #31
 80055de:	fa23 f302 	lsr.w	r3, r3, r2
 80055e2:	f003 0301 	and.w	r3, r3, #1
 80055e6:	2b00      	cmp	r3, #0
 80055e8:	bf0c      	ite	eq
 80055ea:	2300      	moveq	r3, #0
 80055ec:	2301      	movne	r3, #1
 80055ee:	b2db      	uxtb	r3, r3
 80055f0:	2b00      	cmp	r3, #0
 80055f2:	d18f      	bne.n	8005514 <HAL_RCC_OscConfig+0xdec>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80055f4:	f107 0304 	add.w	r3, r7, #4
 80055f8:	681b      	ldr	r3, [r3, #0]
 80055fa:	681b      	ldr	r3, [r3, #0]
 80055fc:	f003 0304 	and.w	r3, r3, #4
 8005600:	2b00      	cmp	r3, #0
 8005602:	f000 830c 	beq.w	8005c1e <HAL_RCC_OscConfig+0x14f6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __PWR_CLK_ENABLE();
 8005606:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800560a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800560e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8005612:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8005616:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8005618:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800561c:	625a      	str	r2, [r3, #36]	; 0x24
    
    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR, PWR_CR_DBP);
 800561e:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8005622:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8005626:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 800562a:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800562e:	6812      	ldr	r2, [r2, #0]
 8005630:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8005634:	601a      	str	r2, [r3, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8005636:	f7fc fe99 	bl	800236c <HAL_GetTick>
 800563a:	f8c7 039c 	str.w	r0, [r7, #924]	; 0x39c
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 800563e:	e010      	b.n	8005662 <HAL_RCC_OscConfig+0xf3a>
    {
      if((HAL_GetTick() - tickstart ) > DBP_TIMEOUT_VALUE)
 8005640:	f7fc fe94 	bl	800236c <HAL_GetTick>
 8005644:	4602      	mov	r2, r0
 8005646:	f8d7 339c 	ldr.w	r3, [r7, #924]	; 0x39c
 800564a:	1ad3      	subs	r3, r2, r3
 800564c:	2b64      	cmp	r3, #100	; 0x64
 800564e:	bf94      	ite	ls
 8005650:	2300      	movls	r3, #0
 8005652:	2301      	movhi	r3, #1
 8005654:	b2db      	uxtb	r3, r3
 8005656:	2b00      	cmp	r3, #0
 8005658:	d003      	beq.n	8005662 <HAL_RCC_OscConfig+0xf3a>
      {
        return HAL_TIMEOUT;
 800565a:	f04f 0303 	mov.w	r3, #3
 800565e:	f000 bcf4 	b.w	800604a <HAL_RCC_OscConfig+0x1922>
    SET_BIT(PWR->CR, PWR_CR_DBP);

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8005662:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8005666:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800566a:	681b      	ldr	r3, [r3, #0]
 800566c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8005670:	2b00      	cmp	r3, #0
 8005672:	bf14      	ite	ne
 8005674:	2300      	movne	r3, #0
 8005676:	2301      	moveq	r3, #1
 8005678:	b2db      	uxtb	r3, r3
 800567a:	2b00      	cmp	r3, #0
 800567c:	d1e0      	bne.n	8005640 <HAL_RCC_OscConfig+0xf18>
 800567e:	f507 73bc 	add.w	r3, r7, #376	; 0x178
 8005682:	f44f 7280 	mov.w	r2, #256	; 0x100
 8005686:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005688:	f507 73bc 	add.w	r3, r7, #376	; 0x178
 800568c:	681b      	ldr	r3, [r3, #0]
 800568e:	fa93 f4a3 	rbit	r4, r3
 8005692:	f507 73ba 	add.w	r3, r7, #372	; 0x174
 8005696:	601c      	str	r4, [r3, #0]
   return(result);
 8005698:	f507 73ba 	add.w	r3, r7, #372	; 0x174
 800569c:	681b      	ldr	r3, [r3, #0]
        return HAL_TIMEOUT;
      }      
    }
    
    /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 800569e:	461a      	mov	r2, r3
 80056a0:	f507 73b8 	add.w	r3, r7, #368	; 0x170
 80056a4:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80056a6:	f507 73b8 	add.w	r3, r7, #368	; 0x170
 80056aa:	681b      	ldr	r3, [r3, #0]
 80056ac:	fab3 f483 	clz	r4, r3
 80056b0:	f507 73b6 	add.w	r3, r7, #364	; 0x16c
 80056b4:	601c      	str	r4, [r3, #0]
  return(result);
 80056b6:	f507 73b6 	add.w	r3, r7, #364	; 0x16c
 80056ba:	681b      	ldr	r3, [r3, #0]
 80056bc:	b2db      	uxtb	r3, r3
 80056be:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80056c2:	461a      	mov	r2, r3
 80056c4:	f44f 63d0 	mov.w	r3, #1664	; 0x680
 80056c8:	f2c4 2347 	movt	r3, #16967	; 0x4247
 80056cc:	18d3      	adds	r3, r2, r3
 80056ce:	f04f 0200 	mov.w	r2, #0
 80056d2:	601a      	str	r2, [r3, #0]
 80056d4:	f507 73b4 	add.w	r3, r7, #360	; 0x168
 80056d8:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80056dc:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80056de:	f507 73b4 	add.w	r3, r7, #360	; 0x168
 80056e2:	681b      	ldr	r3, [r3, #0]
 80056e4:	fa93 f4a3 	rbit	r4, r3
 80056e8:	f507 73b2 	add.w	r3, r7, #356	; 0x164
 80056ec:	601c      	str	r4, [r3, #0]
   return(result);
 80056ee:	f507 73b2 	add.w	r3, r7, #356	; 0x164
 80056f2:	681b      	ldr	r3, [r3, #0]
 80056f4:	461a      	mov	r2, r3
 80056f6:	f507 73b0 	add.w	r3, r7, #352	; 0x160
 80056fa:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80056fc:	f507 73b0 	add.w	r3, r7, #352	; 0x160
 8005700:	681b      	ldr	r3, [r3, #0]
 8005702:	fab3 f483 	clz	r4, r3
 8005706:	f507 73ae 	add.w	r3, r7, #348	; 0x15c
 800570a:	601c      	str	r4, [r3, #0]
  return(result);
 800570c:	f507 73ae 	add.w	r3, r7, #348	; 0x15c
 8005710:	681b      	ldr	r3, [r3, #0]
 8005712:	b2db      	uxtb	r3, r3
 8005714:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005718:	461a      	mov	r2, r3
 800571a:	f44f 63d0 	mov.w	r3, #1664	; 0x680
 800571e:	f2c4 2347 	movt	r3, #16967	; 0x4247
 8005722:	18d3      	adds	r3, r2, r3
 8005724:	f04f 0200 	mov.w	r2, #0
 8005728:	601a      	str	r2, [r3, #0]
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800572a:	f7fc fe1f 	bl	800236c <HAL_GetTick>
 800572e:	f8c7 039c 	str.w	r0, [r7, #924]	; 0x39c
    
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8005732:	e012      	b.n	800575a <HAL_RCC_OscConfig+0x1032>
    {
      if((HAL_GetTick() - tickstart ) > LSE_TIMEOUT_VALUE)
 8005734:	f7fc fe1a 	bl	800236c <HAL_GetTick>
 8005738:	4602      	mov	r2, r0
 800573a:	f8d7 339c 	ldr.w	r3, [r7, #924]	; 0x39c
 800573e:	1ad2      	subs	r2, r2, r3
 8005740:	f241 3388 	movw	r3, #5000	; 0x1388
 8005744:	429a      	cmp	r2, r3
 8005746:	bf94      	ite	ls
 8005748:	2300      	movls	r3, #0
 800574a:	2301      	movhi	r3, #1
 800574c:	b2db      	uxtb	r3, r3
 800574e:	2b00      	cmp	r3, #0
 8005750:	d003      	beq.n	800575a <HAL_RCC_OscConfig+0x1032>
      {
        return HAL_TIMEOUT;
 8005752:	f04f 0303 	mov.w	r3, #3
 8005756:	f000 bc78 	b.w	800604a <HAL_RCC_OscConfig+0x1922>
 800575a:	f507 73ac 	add.w	r3, r7, #344	; 0x158
 800575e:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005762:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005764:	f507 73ac 	add.w	r3, r7, #344	; 0x158
 8005768:	681b      	ldr	r3, [r3, #0]
 800576a:	fa93 f4a3 	rbit	r4, r3
 800576e:	f507 73aa 	add.w	r3, r7, #340	; 0x154
 8005772:	601c      	str	r4, [r3, #0]
   return(result);
 8005774:	f507 73aa 	add.w	r3, r7, #340	; 0x154
 8005778:	681b      	ldr	r3, [r3, #0]
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800577a:	461a      	mov	r2, r3
 800577c:	f507 73a8 	add.w	r3, r7, #336	; 0x150
 8005780:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8005782:	f507 73a8 	add.w	r3, r7, #336	; 0x150
 8005786:	681b      	ldr	r3, [r3, #0]
 8005788:	fab3 f483 	clz	r4, r3
 800578c:	f507 73a6 	add.w	r3, r7, #332	; 0x14c
 8005790:	601c      	str	r4, [r3, #0]
  return(result);
 8005792:	f507 73a6 	add.w	r3, r7, #332	; 0x14c
 8005796:	681b      	ldr	r3, [r3, #0]
 8005798:	b2db      	uxtb	r3, r3
 800579a:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 800579e:	b2db      	uxtb	r3, r3
 80057a0:	ea4f 1363 	mov.w	r3, r3, asr #5
 80057a4:	2b01      	cmp	r3, #1
 80057a6:	d105      	bne.n	80057b4 <HAL_RCC_OscConfig+0x108c>
 80057a8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80057ac:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80057b0:	681b      	ldr	r3, [r3, #0]
 80057b2:	e004      	b.n	80057be <HAL_RCC_OscConfig+0x1096>
 80057b4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80057b8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80057bc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80057be:	f507 72a4 	add.w	r2, r7, #328	; 0x148
 80057c2:	f44f 7100 	mov.w	r1, #512	; 0x200
 80057c6:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80057c8:	f507 72a4 	add.w	r2, r7, #328	; 0x148
 80057cc:	6812      	ldr	r2, [r2, #0]
 80057ce:	fa92 f4a2 	rbit	r4, r2
 80057d2:	f507 72a2 	add.w	r2, r7, #324	; 0x144
 80057d6:	6014      	str	r4, [r2, #0]
   return(result);
 80057d8:	f507 72a2 	add.w	r2, r7, #324	; 0x144
 80057dc:	6812      	ldr	r2, [r2, #0]
 80057de:	4611      	mov	r1, r2
 80057e0:	f507 72a0 	add.w	r2, r7, #320	; 0x140
 80057e4:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80057e6:	f507 72a0 	add.w	r2, r7, #320	; 0x140
 80057ea:	6812      	ldr	r2, [r2, #0]
 80057ec:	fab2 f482 	clz	r4, r2
 80057f0:	f507 729e 	add.w	r2, r7, #316	; 0x13c
 80057f4:	6014      	str	r4, [r2, #0]
  return(result);
 80057f6:	f507 729e 	add.w	r2, r7, #316	; 0x13c
 80057fa:	6812      	ldr	r2, [r2, #0]
 80057fc:	b2d2      	uxtb	r2, r2
 80057fe:	f002 021f 	and.w	r2, r2, #31
 8005802:	fa23 f302 	lsr.w	r3, r3, r2
 8005806:	f003 0301 	and.w	r3, r3, #1
 800580a:	2b00      	cmp	r3, #0
 800580c:	bf0c      	ite	eq
 800580e:	2300      	moveq	r3, #0
 8005810:	2301      	movne	r3, #1
 8005812:	b2db      	uxtb	r3, r3
 8005814:	2b00      	cmp	r3, #0
 8005816:	d18d      	bne.n	8005734 <HAL_RCC_OscConfig+0x100c>
        return HAL_TIMEOUT;
      }
    }
    
    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8005818:	f107 0304 	add.w	r3, r7, #4
 800581c:	681b      	ldr	r3, [r3, #0]
 800581e:	689b      	ldr	r3, [r3, #8]
 8005820:	2b00      	cmp	r3, #0
 8005822:	d156      	bne.n	80058d2 <HAL_RCC_OscConfig+0x11aa>
 8005824:	f507 739c 	add.w	r3, r7, #312	; 0x138
 8005828:	f44f 7280 	mov.w	r2, #256	; 0x100
 800582c:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800582e:	f507 739c 	add.w	r3, r7, #312	; 0x138
 8005832:	681b      	ldr	r3, [r3, #0]
 8005834:	fa93 f4a3 	rbit	r4, r3
 8005838:	f507 739a 	add.w	r3, r7, #308	; 0x134
 800583c:	601c      	str	r4, [r3, #0]
   return(result);
 800583e:	f507 739a 	add.w	r3, r7, #308	; 0x134
 8005842:	681b      	ldr	r3, [r3, #0]
 8005844:	461a      	mov	r2, r3
 8005846:	f507 7398 	add.w	r3, r7, #304	; 0x130
 800584a:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 800584c:	f507 7398 	add.w	r3, r7, #304	; 0x130
 8005850:	681b      	ldr	r3, [r3, #0]
 8005852:	fab3 f483 	clz	r4, r3
 8005856:	f507 7396 	add.w	r3, r7, #300	; 0x12c
 800585a:	601c      	str	r4, [r3, #0]
  return(result);
 800585c:	f507 7396 	add.w	r3, r7, #300	; 0x12c
 8005860:	681b      	ldr	r3, [r3, #0]
 8005862:	b2db      	uxtb	r3, r3
 8005864:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005868:	461a      	mov	r2, r3
 800586a:	f44f 63d0 	mov.w	r3, #1664	; 0x680
 800586e:	f2c4 2347 	movt	r3, #16967	; 0x4247
 8005872:	18d3      	adds	r3, r2, r3
 8005874:	f04f 0200 	mov.w	r2, #0
 8005878:	601a      	str	r2, [r3, #0]
 800587a:	f507 7394 	add.w	r3, r7, #296	; 0x128
 800587e:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8005882:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005884:	f507 7394 	add.w	r3, r7, #296	; 0x128
 8005888:	681b      	ldr	r3, [r3, #0]
 800588a:	fa93 f4a3 	rbit	r4, r3
 800588e:	f507 7392 	add.w	r3, r7, #292	; 0x124
 8005892:	601c      	str	r4, [r3, #0]
   return(result);
 8005894:	f507 7392 	add.w	r3, r7, #292	; 0x124
 8005898:	681b      	ldr	r3, [r3, #0]
 800589a:	461a      	mov	r2, r3
 800589c:	f507 7390 	add.w	r3, r7, #288	; 0x120
 80058a0:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80058a2:	f507 7390 	add.w	r3, r7, #288	; 0x120
 80058a6:	681b      	ldr	r3, [r3, #0]
 80058a8:	fab3 f483 	clz	r4, r3
 80058ac:	f507 738e 	add.w	r3, r7, #284	; 0x11c
 80058b0:	601c      	str	r4, [r3, #0]
  return(result);
 80058b2:	f507 738e 	add.w	r3, r7, #284	; 0x11c
 80058b6:	681b      	ldr	r3, [r3, #0]
 80058b8:	b2db      	uxtb	r3, r3
 80058ba:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80058be:	461a      	mov	r2, r3
 80058c0:	f44f 63d0 	mov.w	r3, #1664	; 0x680
 80058c4:	f2c4 2347 	movt	r3, #16967	; 0x4247
 80058c8:	18d3      	adds	r3, r2, r3
 80058ca:	f04f 0200 	mov.w	r2, #0
 80058ce:	601a      	str	r2, [r3, #0]
 80058d0:	e0b2      	b.n	8005a38 <HAL_RCC_OscConfig+0x1310>
 80058d2:	f107 0304 	add.w	r3, r7, #4
 80058d6:	681b      	ldr	r3, [r3, #0]
 80058d8:	689b      	ldr	r3, [r3, #8]
 80058da:	2b01      	cmp	r3, #1
 80058dc:	d156      	bne.n	800598c <HAL_RCC_OscConfig+0x1264>
 80058de:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80058e2:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80058e6:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80058e8:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80058ec:	681b      	ldr	r3, [r3, #0]
 80058ee:	fa93 f4a3 	rbit	r4, r3
 80058f2:	f507 738a 	add.w	r3, r7, #276	; 0x114
 80058f6:	601c      	str	r4, [r3, #0]
   return(result);
 80058f8:	f507 738a 	add.w	r3, r7, #276	; 0x114
 80058fc:	681b      	ldr	r3, [r3, #0]
 80058fe:	461a      	mov	r2, r3
 8005900:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8005904:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8005906:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800590a:	681b      	ldr	r3, [r3, #0]
 800590c:	fab3 f483 	clz	r4, r3
 8005910:	f507 7386 	add.w	r3, r7, #268	; 0x10c
 8005914:	601c      	str	r4, [r3, #0]
  return(result);
 8005916:	f507 7386 	add.w	r3, r7, #268	; 0x10c
 800591a:	681b      	ldr	r3, [r3, #0]
 800591c:	b2db      	uxtb	r3, r3
 800591e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005922:	461a      	mov	r2, r3
 8005924:	f44f 63d0 	mov.w	r3, #1664	; 0x680
 8005928:	f2c4 2347 	movt	r3, #16967	; 0x4247
 800592c:	18d3      	adds	r3, r2, r3
 800592e:	f04f 0200 	mov.w	r2, #0
 8005932:	601a      	str	r2, [r3, #0]
 8005934:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8005938:	f44f 7280 	mov.w	r2, #256	; 0x100
 800593c:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800593e:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8005942:	681b      	ldr	r3, [r3, #0]
 8005944:	fa93 f4a3 	rbit	r4, r3
 8005948:	f507 7382 	add.w	r3, r7, #260	; 0x104
 800594c:	601c      	str	r4, [r3, #0]
   return(result);
 800594e:	f507 7382 	add.w	r3, r7, #260	; 0x104
 8005952:	681b      	ldr	r3, [r3, #0]
 8005954:	461a      	mov	r2, r3
 8005956:	f507 7380 	add.w	r3, r7, #256	; 0x100
 800595a:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 800595c:	f507 7380 	add.w	r3, r7, #256	; 0x100
 8005960:	681b      	ldr	r3, [r3, #0]
 8005962:	fab3 f483 	clz	r4, r3
 8005966:	f107 03fc 	add.w	r3, r7, #252	; 0xfc
 800596a:	601c      	str	r4, [r3, #0]
  return(result);
 800596c:	f107 03fc 	add.w	r3, r7, #252	; 0xfc
 8005970:	681b      	ldr	r3, [r3, #0]
 8005972:	b2db      	uxtb	r3, r3
 8005974:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005978:	461a      	mov	r2, r3
 800597a:	f44f 63d0 	mov.w	r3, #1664	; 0x680
 800597e:	f2c4 2347 	movt	r3, #16967	; 0x4247
 8005982:	18d3      	adds	r3, r2, r3
 8005984:	f04f 0201 	mov.w	r2, #1
 8005988:	601a      	str	r2, [r3, #0]
 800598a:	e055      	b.n	8005a38 <HAL_RCC_OscConfig+0x1310>
 800598c:	f107 03f8 	add.w	r3, r7, #248	; 0xf8
 8005990:	f44f 7280 	mov.w	r2, #256	; 0x100
 8005994:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005996:	f107 03f8 	add.w	r3, r7, #248	; 0xf8
 800599a:	681b      	ldr	r3, [r3, #0]
 800599c:	fa93 f4a3 	rbit	r4, r3
 80059a0:	f107 03f4 	add.w	r3, r7, #244	; 0xf4
 80059a4:	601c      	str	r4, [r3, #0]
   return(result);
 80059a6:	f107 03f4 	add.w	r3, r7, #244	; 0xf4
 80059aa:	681b      	ldr	r3, [r3, #0]
 80059ac:	461a      	mov	r2, r3
 80059ae:	f107 03f0 	add.w	r3, r7, #240	; 0xf0
 80059b2:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80059b4:	f107 03f0 	add.w	r3, r7, #240	; 0xf0
 80059b8:	681b      	ldr	r3, [r3, #0]
 80059ba:	fab3 f483 	clz	r4, r3
 80059be:	f107 03ec 	add.w	r3, r7, #236	; 0xec
 80059c2:	601c      	str	r4, [r3, #0]
  return(result);
 80059c4:	f107 03ec 	add.w	r3, r7, #236	; 0xec
 80059c8:	681b      	ldr	r3, [r3, #0]
 80059ca:	b2db      	uxtb	r3, r3
 80059cc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80059d0:	461a      	mov	r2, r3
 80059d2:	f44f 63d0 	mov.w	r3, #1664	; 0x680
 80059d6:	f2c4 2347 	movt	r3, #16967	; 0x4247
 80059da:	18d3      	adds	r3, r2, r3
 80059dc:	f04f 0200 	mov.w	r2, #0
 80059e0:	601a      	str	r2, [r3, #0]
 80059e2:	f107 03e8 	add.w	r3, r7, #232	; 0xe8
 80059e6:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80059ea:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80059ec:	f107 03e8 	add.w	r3, r7, #232	; 0xe8
 80059f0:	681b      	ldr	r3, [r3, #0]
 80059f2:	fa93 f4a3 	rbit	r4, r3
 80059f6:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
 80059fa:	601c      	str	r4, [r3, #0]
   return(result);
 80059fc:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
 8005a00:	681b      	ldr	r3, [r3, #0]
 8005a02:	461a      	mov	r2, r3
 8005a04:	f107 03e0 	add.w	r3, r7, #224	; 0xe0
 8005a08:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8005a0a:	f107 03e0 	add.w	r3, r7, #224	; 0xe0
 8005a0e:	681b      	ldr	r3, [r3, #0]
 8005a10:	fab3 f483 	clz	r4, r3
 8005a14:	f107 03dc 	add.w	r3, r7, #220	; 0xdc
 8005a18:	601c      	str	r4, [r3, #0]
  return(result);
 8005a1a:	f107 03dc 	add.w	r3, r7, #220	; 0xdc
 8005a1e:	681b      	ldr	r3, [r3, #0]
 8005a20:	b2db      	uxtb	r3, r3
 8005a22:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005a26:	461a      	mov	r2, r3
 8005a28:	f44f 63d0 	mov.w	r3, #1664	; 0x680
 8005a2c:	f2c4 2347 	movt	r3, #16967	; 0x4247
 8005a30:	18d3      	adds	r3, r2, r3
 8005a32:	f04f 0201 	mov.w	r2, #1
 8005a36:	601a      	str	r2, [r3, #0]
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) == RCC_LSE_ON)
 8005a38:	f107 0304 	add.w	r3, r7, #4
 8005a3c:	681b      	ldr	r3, [r3, #0]
 8005a3e:	689b      	ldr	r3, [r3, #8]
 8005a40:	2b01      	cmp	r3, #1
 8005a42:	d176      	bne.n	8005b32 <HAL_RCC_OscConfig+0x140a>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8005a44:	f7fc fc92 	bl	800236c <HAL_GetTick>
 8005a48:	f8c7 039c 	str.w	r0, [r7, #924]	; 0x39c
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8005a4c:	e011      	b.n	8005a72 <HAL_RCC_OscConfig+0x134a>
      {
        if((HAL_GetTick() - tickstart ) > LSE_TIMEOUT_VALUE)
 8005a4e:	f7fc fc8d 	bl	800236c <HAL_GetTick>
 8005a52:	4602      	mov	r2, r0
 8005a54:	f8d7 339c 	ldr.w	r3, [r7, #924]	; 0x39c
 8005a58:	1ad2      	subs	r2, r2, r3
 8005a5a:	f241 3388 	movw	r3, #5000	; 0x1388
 8005a5e:	429a      	cmp	r2, r3
 8005a60:	bf94      	ite	ls
 8005a62:	2300      	movls	r3, #0
 8005a64:	2301      	movhi	r3, #1
 8005a66:	b2db      	uxtb	r3, r3
 8005a68:	2b00      	cmp	r3, #0
 8005a6a:	d002      	beq.n	8005a72 <HAL_RCC_OscConfig+0x134a>
        {
          return HAL_TIMEOUT;
 8005a6c:	f04f 0303 	mov.w	r3, #3
 8005a70:	e2eb      	b.n	800604a <HAL_RCC_OscConfig+0x1922>
 8005a72:	f107 03d8 	add.w	r3, r7, #216	; 0xd8
 8005a76:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005a7a:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005a7c:	f107 03d8 	add.w	r3, r7, #216	; 0xd8
 8005a80:	681b      	ldr	r3, [r3, #0]
 8005a82:	fa93 f4a3 	rbit	r4, r3
 8005a86:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
 8005a8a:	601c      	str	r4, [r3, #0]
   return(result);
 8005a8c:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
 8005a90:	681b      	ldr	r3, [r3, #0]
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8005a92:	461a      	mov	r2, r3
 8005a94:	f107 03d0 	add.w	r3, r7, #208	; 0xd0
 8005a98:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8005a9a:	f107 03d0 	add.w	r3, r7, #208	; 0xd0
 8005a9e:	681b      	ldr	r3, [r3, #0]
 8005aa0:	fab3 f483 	clz	r4, r3
 8005aa4:	f107 03cc 	add.w	r3, r7, #204	; 0xcc
 8005aa8:	601c      	str	r4, [r3, #0]
  return(result);
 8005aaa:	f107 03cc 	add.w	r3, r7, #204	; 0xcc
 8005aae:	681b      	ldr	r3, [r3, #0]
 8005ab0:	b2db      	uxtb	r3, r3
 8005ab2:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 8005ab6:	b2db      	uxtb	r3, r3
 8005ab8:	ea4f 1363 	mov.w	r3, r3, asr #5
 8005abc:	2b01      	cmp	r3, #1
 8005abe:	d105      	bne.n	8005acc <HAL_RCC_OscConfig+0x13a4>
 8005ac0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8005ac4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005ac8:	681b      	ldr	r3, [r3, #0]
 8005aca:	e004      	b.n	8005ad6 <HAL_RCC_OscConfig+0x13ae>
 8005acc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8005ad0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005ad4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005ad6:	f107 02c8 	add.w	r2, r7, #200	; 0xc8
 8005ada:	f44f 7100 	mov.w	r1, #512	; 0x200
 8005ade:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005ae0:	f107 02c8 	add.w	r2, r7, #200	; 0xc8
 8005ae4:	6812      	ldr	r2, [r2, #0]
 8005ae6:	fa92 f4a2 	rbit	r4, r2
 8005aea:	f107 02c4 	add.w	r2, r7, #196	; 0xc4
 8005aee:	6014      	str	r4, [r2, #0]
   return(result);
 8005af0:	f107 02c4 	add.w	r2, r7, #196	; 0xc4
 8005af4:	6812      	ldr	r2, [r2, #0]
 8005af6:	4611      	mov	r1, r2
 8005af8:	f107 02c0 	add.w	r2, r7, #192	; 0xc0
 8005afc:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8005afe:	f107 02c0 	add.w	r2, r7, #192	; 0xc0
 8005b02:	6812      	ldr	r2, [r2, #0]
 8005b04:	fab2 f482 	clz	r4, r2
 8005b08:	f107 02bc 	add.w	r2, r7, #188	; 0xbc
 8005b0c:	6014      	str	r4, [r2, #0]
  return(result);
 8005b0e:	f107 02bc 	add.w	r2, r7, #188	; 0xbc
 8005b12:	6812      	ldr	r2, [r2, #0]
 8005b14:	b2d2      	uxtb	r2, r2
 8005b16:	f002 021f 	and.w	r2, r2, #31
 8005b1a:	fa23 f302 	lsr.w	r3, r3, r2
 8005b1e:	f003 0301 	and.w	r3, r3, #1
 8005b22:	2b00      	cmp	r3, #0
 8005b24:	bf14      	ite	ne
 8005b26:	2300      	movne	r3, #0
 8005b28:	2301      	moveq	r3, #1
 8005b2a:	b2db      	uxtb	r3, r3
 8005b2c:	2b00      	cmp	r3, #0
 8005b2e:	d18e      	bne.n	8005a4e <HAL_RCC_OscConfig+0x1326>
 8005b30:	e075      	b.n	8005c1e <HAL_RCC_OscConfig+0x14f6>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8005b32:	f7fc fc1b 	bl	800236c <HAL_GetTick>
 8005b36:	f8c7 039c 	str.w	r0, [r7, #924]	; 0x39c
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8005b3a:	e011      	b.n	8005b60 <HAL_RCC_OscConfig+0x1438>
      {
        if((HAL_GetTick() - tickstart ) > LSE_TIMEOUT_VALUE)
 8005b3c:	f7fc fc16 	bl	800236c <HAL_GetTick>
 8005b40:	4602      	mov	r2, r0
 8005b42:	f8d7 339c 	ldr.w	r3, [r7, #924]	; 0x39c
 8005b46:	1ad2      	subs	r2, r2, r3
 8005b48:	f241 3388 	movw	r3, #5000	; 0x1388
 8005b4c:	429a      	cmp	r2, r3
 8005b4e:	bf94      	ite	ls
 8005b50:	2300      	movls	r3, #0
 8005b52:	2301      	movhi	r3, #1
 8005b54:	b2db      	uxtb	r3, r3
 8005b56:	2b00      	cmp	r3, #0
 8005b58:	d002      	beq.n	8005b60 <HAL_RCC_OscConfig+0x1438>
        {
          return HAL_TIMEOUT;
 8005b5a:	f04f 0303 	mov.w	r3, #3
 8005b5e:	e274      	b.n	800604a <HAL_RCC_OscConfig+0x1922>
 8005b60:	f107 03b8 	add.w	r3, r7, #184	; 0xb8
 8005b64:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005b68:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005b6a:	f107 03b8 	add.w	r3, r7, #184	; 0xb8
 8005b6e:	681b      	ldr	r3, [r3, #0]
 8005b70:	fa93 f4a3 	rbit	r4, r3
 8005b74:	f107 03b4 	add.w	r3, r7, #180	; 0xb4
 8005b78:	601c      	str	r4, [r3, #0]
   return(result);
 8005b7a:	f107 03b4 	add.w	r3, r7, #180	; 0xb4
 8005b7e:	681b      	ldr	r3, [r3, #0]
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8005b80:	461a      	mov	r2, r3
 8005b82:	f107 03b0 	add.w	r3, r7, #176	; 0xb0
 8005b86:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8005b88:	f107 03b0 	add.w	r3, r7, #176	; 0xb0
 8005b8c:	681b      	ldr	r3, [r3, #0]
 8005b8e:	fab3 f483 	clz	r4, r3
 8005b92:	f107 03ac 	add.w	r3, r7, #172	; 0xac
 8005b96:	601c      	str	r4, [r3, #0]
  return(result);
 8005b98:	f107 03ac 	add.w	r3, r7, #172	; 0xac
 8005b9c:	681b      	ldr	r3, [r3, #0]
 8005b9e:	b2db      	uxtb	r3, r3
 8005ba0:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 8005ba4:	b2db      	uxtb	r3, r3
 8005ba6:	ea4f 1363 	mov.w	r3, r3, asr #5
 8005baa:	2b01      	cmp	r3, #1
 8005bac:	d105      	bne.n	8005bba <HAL_RCC_OscConfig+0x1492>
 8005bae:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8005bb2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005bb6:	681b      	ldr	r3, [r3, #0]
 8005bb8:	e004      	b.n	8005bc4 <HAL_RCC_OscConfig+0x149c>
 8005bba:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8005bbe:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005bc2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005bc4:	f107 02a8 	add.w	r2, r7, #168	; 0xa8
 8005bc8:	f44f 7100 	mov.w	r1, #512	; 0x200
 8005bcc:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005bce:	f107 02a8 	add.w	r2, r7, #168	; 0xa8
 8005bd2:	6812      	ldr	r2, [r2, #0]
 8005bd4:	fa92 f4a2 	rbit	r4, r2
 8005bd8:	f107 02a4 	add.w	r2, r7, #164	; 0xa4
 8005bdc:	6014      	str	r4, [r2, #0]
   return(result);
 8005bde:	f107 02a4 	add.w	r2, r7, #164	; 0xa4
 8005be2:	6812      	ldr	r2, [r2, #0]
 8005be4:	4611      	mov	r1, r2
 8005be6:	f107 02a0 	add.w	r2, r7, #160	; 0xa0
 8005bea:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8005bec:	f107 02a0 	add.w	r2, r7, #160	; 0xa0
 8005bf0:	6812      	ldr	r2, [r2, #0]
 8005bf2:	fab2 f482 	clz	r4, r2
 8005bf6:	f107 029c 	add.w	r2, r7, #156	; 0x9c
 8005bfa:	6014      	str	r4, [r2, #0]
  return(result);
 8005bfc:	f107 029c 	add.w	r2, r7, #156	; 0x9c
 8005c00:	6812      	ldr	r2, [r2, #0]
 8005c02:	b2d2      	uxtb	r2, r2
 8005c04:	f002 021f 	and.w	r2, r2, #31
 8005c08:	fa23 f302 	lsr.w	r3, r3, r2
 8005c0c:	f003 0301 	and.w	r3, r3, #1
 8005c10:	2b00      	cmp	r3, #0
 8005c12:	bf0c      	ite	eq
 8005c14:	2300      	moveq	r3, #0
 8005c16:	2301      	movne	r3, #1
 8005c18:	b2db      	uxtb	r3, r3
 8005c1a:	2b00      	cmp	r3, #0
 8005c1c:	d18e      	bne.n	8005b3c <HAL_RCC_OscConfig+0x1414>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8005c1e:	f107 0304 	add.w	r3, r7, #4
 8005c22:	681b      	ldr	r3, [r3, #0]
 8005c24:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005c26:	2b00      	cmp	r3, #0
 8005c28:	f000 820d 	beq.w	8006046 <HAL_RCC_OscConfig+0x191e>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8005c2c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8005c30:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005c34:	689b      	ldr	r3, [r3, #8]
 8005c36:	f003 030c 	and.w	r3, r3, #12
 8005c3a:	2b0c      	cmp	r3, #12
 8005c3c:	bf0c      	ite	eq
 8005c3e:	2300      	moveq	r3, #0
 8005c40:	2301      	movne	r3, #1
 8005c42:	b2db      	uxtb	r3, r3
 8005c44:	2b00      	cmp	r3, #0
 8005c46:	f000 81fb 	beq.w	8006040 <HAL_RCC_OscConfig+0x1918>
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8005c4a:	f107 0304 	add.w	r3, r7, #4
 8005c4e:	681b      	ldr	r3, [r3, #0]
 8005c50:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005c52:	2b02      	cmp	r3, #2
 8005c54:	f040 8156 	bne.w	8005f04 <HAL_RCC_OscConfig+0x17dc>
 8005c58:	f107 0398 	add.w	r3, r7, #152	; 0x98
 8005c5c:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8005c60:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005c62:	f107 0398 	add.w	r3, r7, #152	; 0x98
 8005c66:	681b      	ldr	r3, [r3, #0]
 8005c68:	fa93 f4a3 	rbit	r4, r3
 8005c6c:	f107 0394 	add.w	r3, r7, #148	; 0x94
 8005c70:	601c      	str	r4, [r3, #0]
   return(result);
 8005c72:	f107 0394 	add.w	r3, r7, #148	; 0x94
 8005c76:	681b      	ldr	r3, [r3, #0]
        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
        assert_param(IS_RCC_PLL_DIV(RCC_OscInitStruct->PLL.PLLDIV));
        
        
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8005c78:	461a      	mov	r2, r3
 8005c7a:	f107 0390 	add.w	r3, r7, #144	; 0x90
 8005c7e:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8005c80:	f107 0390 	add.w	r3, r7, #144	; 0x90
 8005c84:	681b      	ldr	r3, [r3, #0]
 8005c86:	fab3 f483 	clz	r4, r3
 8005c8a:	f107 038c 	add.w	r3, r7, #140	; 0x8c
 8005c8e:	601c      	str	r4, [r3, #0]
  return(result);
 8005c90:	f107 038c 	add.w	r3, r7, #140	; 0x8c
 8005c94:	681b      	ldr	r3, [r3, #0]
 8005c96:	b2db      	uxtb	r3, r3
 8005c98:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005c9c:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8005ca0:	f503 038e 	add.w	r3, r3, #4653056	; 0x470000
 8005ca4:	f04f 0200 	mov.w	r2, #0
 8005ca8:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8005caa:	f7fc fb5f 	bl	800236c <HAL_GetTick>
 8005cae:	f8c7 039c 	str.w	r0, [r7, #924]	; 0x39c
        
        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8005cb2:	e00f      	b.n	8005cd4 <HAL_RCC_OscConfig+0x15ac>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8005cb4:	f7fc fb5a 	bl	800236c <HAL_GetTick>
 8005cb8:	4602      	mov	r2, r0
 8005cba:	f8d7 339c 	ldr.w	r3, [r7, #924]	; 0x39c
 8005cbe:	1ad3      	subs	r3, r2, r3
 8005cc0:	2b64      	cmp	r3, #100	; 0x64
 8005cc2:	bf94      	ite	ls
 8005cc4:	2300      	movls	r3, #0
 8005cc6:	2301      	movhi	r3, #1
 8005cc8:	b2db      	uxtb	r3, r3
 8005cca:	2b00      	cmp	r3, #0
 8005ccc:	d002      	beq.n	8005cd4 <HAL_RCC_OscConfig+0x15ac>
          {
            return HAL_TIMEOUT;
 8005cce:	f04f 0303 	mov.w	r3, #3
 8005cd2:	e1ba      	b.n	800604a <HAL_RCC_OscConfig+0x1922>
 8005cd4:	f107 0388 	add.w	r3, r7, #136	; 0x88
 8005cd8:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 8005cdc:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005cde:	f107 0388 	add.w	r3, r7, #136	; 0x88
 8005ce2:	681b      	ldr	r3, [r3, #0]
 8005ce4:	fa93 f4a3 	rbit	r4, r3
 8005ce8:	f107 0384 	add.w	r3, r7, #132	; 0x84
 8005cec:	601c      	str	r4, [r3, #0]
   return(result);
 8005cee:	f107 0384 	add.w	r3, r7, #132	; 0x84
 8005cf2:	681b      	ldr	r3, [r3, #0]
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8005cf4:	461a      	mov	r2, r3
 8005cf6:	f107 0380 	add.w	r3, r7, #128	; 0x80
 8005cfa:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8005cfc:	f107 0380 	add.w	r3, r7, #128	; 0x80
 8005d00:	681b      	ldr	r3, [r3, #0]
 8005d02:	fab3 f483 	clz	r4, r3
 8005d06:	f107 037c 	add.w	r3, r7, #124	; 0x7c
 8005d0a:	601c      	str	r4, [r3, #0]
  return(result);
 8005d0c:	f107 037c 	add.w	r3, r7, #124	; 0x7c
 8005d10:	681b      	ldr	r3, [r3, #0]
 8005d12:	b2db      	uxtb	r3, r3
 8005d14:	f043 0320 	orr.w	r3, r3, #32
 8005d18:	b2db      	uxtb	r3, r3
 8005d1a:	ea4f 1363 	mov.w	r3, r3, asr #5
 8005d1e:	2b01      	cmp	r3, #1
 8005d20:	d105      	bne.n	8005d2e <HAL_RCC_OscConfig+0x1606>
 8005d22:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8005d26:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005d2a:	681b      	ldr	r3, [r3, #0]
 8005d2c:	e004      	b.n	8005d38 <HAL_RCC_OscConfig+0x1610>
 8005d2e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8005d32:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005d36:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005d38:	f107 0278 	add.w	r2, r7, #120	; 0x78
 8005d3c:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
 8005d40:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005d42:	f107 0278 	add.w	r2, r7, #120	; 0x78
 8005d46:	6812      	ldr	r2, [r2, #0]
 8005d48:	fa92 f4a2 	rbit	r4, r2
 8005d4c:	f107 0274 	add.w	r2, r7, #116	; 0x74
 8005d50:	6014      	str	r4, [r2, #0]
   return(result);
 8005d52:	f107 0274 	add.w	r2, r7, #116	; 0x74
 8005d56:	6812      	ldr	r2, [r2, #0]
 8005d58:	4611      	mov	r1, r2
 8005d5a:	f107 0270 	add.w	r2, r7, #112	; 0x70
 8005d5e:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8005d60:	f107 0270 	add.w	r2, r7, #112	; 0x70
 8005d64:	6812      	ldr	r2, [r2, #0]
 8005d66:	fab2 f482 	clz	r4, r2
 8005d6a:	f107 026c 	add.w	r2, r7, #108	; 0x6c
 8005d6e:	6014      	str	r4, [r2, #0]
  return(result);
 8005d70:	f107 026c 	add.w	r2, r7, #108	; 0x6c
 8005d74:	6812      	ldr	r2, [r2, #0]
 8005d76:	b2d2      	uxtb	r2, r2
 8005d78:	f002 021f 	and.w	r2, r2, #31
 8005d7c:	fa23 f302 	lsr.w	r3, r3, r2
 8005d80:	f003 0301 	and.w	r3, r3, #1
 8005d84:	2b00      	cmp	r3, #0
 8005d86:	bf0c      	ite	eq
 8005d88:	2300      	moveq	r3, #0
 8005d8a:	2301      	movne	r3, #1
 8005d8c:	b2db      	uxtb	r3, r3
 8005d8e:	2b00      	cmp	r3, #0
 8005d90:	d190      	bne.n	8005cb4 <HAL_RCC_OscConfig+0x158c>
        }
        
        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
                             RCC_OscInitStruct->PLL.PLLMUL,
                             RCC_OscInitStruct->PLL.PLLDIV);
 8005d92:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8005d96:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005d9a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8005d9e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8005da2:	6892      	ldr	r2, [r2, #8]
 8005da4:	f422 017d 	bic.w	r1, r2, #16580608	; 0xfd0000
 8005da8:	f107 0204 	add.w	r2, r7, #4
 8005dac:	6812      	ldr	r2, [r2, #0]
 8005dae:	6a90      	ldr	r0, [r2, #40]	; 0x28
 8005db0:	f107 0204 	add.w	r2, r7, #4
 8005db4:	6812      	ldr	r2, [r2, #0]
 8005db6:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8005db8:	4310      	orrs	r0, r2
 8005dba:	f107 0204 	add.w	r2, r7, #4
 8005dbe:	6812      	ldr	r2, [r2, #0]
 8005dc0:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8005dc2:	4302      	orrs	r2, r0
 8005dc4:	430a      	orrs	r2, r1
 8005dc6:	609a      	str	r2, [r3, #8]
 8005dc8:	f107 0368 	add.w	r3, r7, #104	; 0x68
 8005dcc:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8005dd0:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005dd2:	f107 0368 	add.w	r3, r7, #104	; 0x68
 8005dd6:	681b      	ldr	r3, [r3, #0]
 8005dd8:	fa93 f4a3 	rbit	r4, r3
 8005ddc:	f107 0364 	add.w	r3, r7, #100	; 0x64
 8005de0:	601c      	str	r4, [r3, #0]
   return(result);
 8005de2:	f107 0364 	add.w	r3, r7, #100	; 0x64
 8005de6:	681b      	ldr	r3, [r3, #0]
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8005de8:	461a      	mov	r2, r3
 8005dea:	f107 0360 	add.w	r3, r7, #96	; 0x60
 8005dee:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8005df0:	f107 0360 	add.w	r3, r7, #96	; 0x60
 8005df4:	681b      	ldr	r3, [r3, #0]
 8005df6:	fab3 f483 	clz	r4, r3
 8005dfa:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 8005dfe:	601c      	str	r4, [r3, #0]
  return(result);
 8005e00:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 8005e04:	681b      	ldr	r3, [r3, #0]
 8005e06:	b2db      	uxtb	r3, r3
 8005e08:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005e0c:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8005e10:	f503 038e 	add.w	r3, r3, #4653056	; 0x470000
 8005e14:	f04f 0201 	mov.w	r2, #1
 8005e18:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8005e1a:	f7fc faa7 	bl	800236c <HAL_GetTick>
 8005e1e:	f8c7 039c 	str.w	r0, [r7, #924]	; 0x39c
        
        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8005e22:	e00f      	b.n	8005e44 <HAL_RCC_OscConfig+0x171c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8005e24:	f7fc faa2 	bl	800236c <HAL_GetTick>
 8005e28:	4602      	mov	r2, r0
 8005e2a:	f8d7 339c 	ldr.w	r3, [r7, #924]	; 0x39c
 8005e2e:	1ad3      	subs	r3, r2, r3
 8005e30:	2b64      	cmp	r3, #100	; 0x64
 8005e32:	bf94      	ite	ls
 8005e34:	2300      	movls	r3, #0
 8005e36:	2301      	movhi	r3, #1
 8005e38:	b2db      	uxtb	r3, r3
 8005e3a:	2b00      	cmp	r3, #0
 8005e3c:	d002      	beq.n	8005e44 <HAL_RCC_OscConfig+0x171c>
          {
            return HAL_TIMEOUT;
 8005e3e:	f04f 0303 	mov.w	r3, #3
 8005e42:	e102      	b.n	800604a <HAL_RCC_OscConfig+0x1922>
 8005e44:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8005e48:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 8005e4c:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005e4e:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8005e52:	681b      	ldr	r3, [r3, #0]
 8005e54:	fa93 f4a3 	rbit	r4, r3
 8005e58:	f107 0354 	add.w	r3, r7, #84	; 0x54
 8005e5c:	601c      	str	r4, [r3, #0]
   return(result);
 8005e5e:	f107 0354 	add.w	r3, r7, #84	; 0x54
 8005e62:	681b      	ldr	r3, [r3, #0]
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8005e64:	461a      	mov	r2, r3
 8005e66:	f107 0350 	add.w	r3, r7, #80	; 0x50
 8005e6a:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8005e6c:	f107 0350 	add.w	r3, r7, #80	; 0x50
 8005e70:	681b      	ldr	r3, [r3, #0]
 8005e72:	fab3 f483 	clz	r4, r3
 8005e76:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8005e7a:	601c      	str	r4, [r3, #0]
  return(result);
 8005e7c:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8005e80:	681b      	ldr	r3, [r3, #0]
 8005e82:	b2db      	uxtb	r3, r3
 8005e84:	f043 0320 	orr.w	r3, r3, #32
 8005e88:	b2db      	uxtb	r3, r3
 8005e8a:	ea4f 1363 	mov.w	r3, r3, asr #5
 8005e8e:	2b01      	cmp	r3, #1
 8005e90:	d105      	bne.n	8005e9e <HAL_RCC_OscConfig+0x1776>
 8005e92:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8005e96:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005e9a:	681b      	ldr	r3, [r3, #0]
 8005e9c:	e004      	b.n	8005ea8 <HAL_RCC_OscConfig+0x1780>
 8005e9e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8005ea2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005ea6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005ea8:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8005eac:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
 8005eb0:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005eb2:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8005eb6:	6812      	ldr	r2, [r2, #0]
 8005eb8:	fa92 f4a2 	rbit	r4, r2
 8005ebc:	f107 0244 	add.w	r2, r7, #68	; 0x44
 8005ec0:	6014      	str	r4, [r2, #0]
   return(result);
 8005ec2:	f107 0244 	add.w	r2, r7, #68	; 0x44
 8005ec6:	6812      	ldr	r2, [r2, #0]
 8005ec8:	4611      	mov	r1, r2
 8005eca:	f107 0240 	add.w	r2, r7, #64	; 0x40
 8005ece:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8005ed0:	f107 0240 	add.w	r2, r7, #64	; 0x40
 8005ed4:	6812      	ldr	r2, [r2, #0]
 8005ed6:	fab2 f482 	clz	r4, r2
 8005eda:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 8005ede:	6014      	str	r4, [r2, #0]
  return(result);
 8005ee0:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 8005ee4:	6812      	ldr	r2, [r2, #0]
 8005ee6:	b2d2      	uxtb	r2, r2
 8005ee8:	f002 021f 	and.w	r2, r2, #31
 8005eec:	fa23 f302 	lsr.w	r3, r3, r2
 8005ef0:	f003 0301 	and.w	r3, r3, #1
 8005ef4:	2b00      	cmp	r3, #0
 8005ef6:	bf14      	ite	ne
 8005ef8:	2300      	movne	r3, #0
 8005efa:	2301      	moveq	r3, #1
 8005efc:	b2db      	uxtb	r3, r3
 8005efe:	2b00      	cmp	r3, #0
 8005f00:	d190      	bne.n	8005e24 <HAL_RCC_OscConfig+0x16fc>
 8005f02:	e0a0      	b.n	8006046 <HAL_RCC_OscConfig+0x191e>
 8005f04:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8005f08:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8005f0c:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005f0e:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8005f12:	681b      	ldr	r3, [r3, #0]
 8005f14:	fa93 f4a3 	rbit	r4, r3
 8005f18:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8005f1c:	601c      	str	r4, [r3, #0]
   return(result);
 8005f1e:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8005f22:	681b      	ldr	r3, [r3, #0]
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8005f24:	461a      	mov	r2, r3
 8005f26:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8005f2a:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8005f2c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8005f30:	681b      	ldr	r3, [r3, #0]
 8005f32:	fab3 f483 	clz	r4, r3
 8005f36:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8005f3a:	601c      	str	r4, [r3, #0]
  return(result);
 8005f3c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8005f40:	681b      	ldr	r3, [r3, #0]
 8005f42:	b2db      	uxtb	r3, r3
 8005f44:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005f48:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8005f4c:	f503 038e 	add.w	r3, r3, #4653056	; 0x470000
 8005f50:	f04f 0200 	mov.w	r2, #0
 8005f54:	601a      	str	r2, [r3, #0]
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8005f56:	f7fc fa09 	bl	800236c <HAL_GetTick>
 8005f5a:	f8c7 039c 	str.w	r0, [r7, #924]	; 0x39c
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8005f5e:	e00f      	b.n	8005f80 <HAL_RCC_OscConfig+0x1858>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8005f60:	f7fc fa04 	bl	800236c <HAL_GetTick>
 8005f64:	4602      	mov	r2, r0
 8005f66:	f8d7 339c 	ldr.w	r3, [r7, #924]	; 0x39c
 8005f6a:	1ad3      	subs	r3, r2, r3
 8005f6c:	2b64      	cmp	r3, #100	; 0x64
 8005f6e:	bf94      	ite	ls
 8005f70:	2300      	movls	r3, #0
 8005f72:	2301      	movhi	r3, #1
 8005f74:	b2db      	uxtb	r3, r3
 8005f76:	2b00      	cmp	r3, #0
 8005f78:	d002      	beq.n	8005f80 <HAL_RCC_OscConfig+0x1858>
          {
            return HAL_TIMEOUT;
 8005f7a:	f04f 0303 	mov.w	r3, #3
 8005f7e:	e064      	b.n	800604a <HAL_RCC_OscConfig+0x1922>
 8005f80:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8005f84:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 8005f88:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005f8a:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8005f8e:	681b      	ldr	r3, [r3, #0]
 8005f90:	fa93 f4a3 	rbit	r4, r3
 8005f94:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8005f98:	601c      	str	r4, [r3, #0]
   return(result);
 8005f9a:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8005f9e:	681b      	ldr	r3, [r3, #0]
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8005fa0:	461a      	mov	r2, r3
 8005fa2:	f107 0320 	add.w	r3, r7, #32
 8005fa6:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8005fa8:	f107 0320 	add.w	r3, r7, #32
 8005fac:	681b      	ldr	r3, [r3, #0]
 8005fae:	fab3 f483 	clz	r4, r3
 8005fb2:	f107 031c 	add.w	r3, r7, #28
 8005fb6:	601c      	str	r4, [r3, #0]
  return(result);
 8005fb8:	f107 031c 	add.w	r3, r7, #28
 8005fbc:	681b      	ldr	r3, [r3, #0]
 8005fbe:	b2db      	uxtb	r3, r3
 8005fc0:	f043 0320 	orr.w	r3, r3, #32
 8005fc4:	b2db      	uxtb	r3, r3
 8005fc6:	ea4f 1363 	mov.w	r3, r3, asr #5
 8005fca:	2b01      	cmp	r3, #1
 8005fcc:	d105      	bne.n	8005fda <HAL_RCC_OscConfig+0x18b2>
 8005fce:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8005fd2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005fd6:	681b      	ldr	r3, [r3, #0]
 8005fd8:	e004      	b.n	8005fe4 <HAL_RCC_OscConfig+0x18bc>
 8005fda:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8005fde:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005fe2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005fe4:	f107 0218 	add.w	r2, r7, #24
 8005fe8:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
 8005fec:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005fee:	f107 0218 	add.w	r2, r7, #24
 8005ff2:	6812      	ldr	r2, [r2, #0]
 8005ff4:	fa92 f4a2 	rbit	r4, r2
 8005ff8:	f107 0214 	add.w	r2, r7, #20
 8005ffc:	6014      	str	r4, [r2, #0]
   return(result);
 8005ffe:	f107 0214 	add.w	r2, r7, #20
 8006002:	6812      	ldr	r2, [r2, #0]
 8006004:	4611      	mov	r1, r2
 8006006:	f107 0210 	add.w	r2, r7, #16
 800600a:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 800600c:	f107 0210 	add.w	r2, r7, #16
 8006010:	6812      	ldr	r2, [r2, #0]
 8006012:	fab2 f482 	clz	r4, r2
 8006016:	f107 020c 	add.w	r2, r7, #12
 800601a:	6014      	str	r4, [r2, #0]
  return(result);
 800601c:	f107 020c 	add.w	r2, r7, #12
 8006020:	6812      	ldr	r2, [r2, #0]
 8006022:	b2d2      	uxtb	r2, r2
 8006024:	f002 021f 	and.w	r2, r2, #31
 8006028:	fa23 f302 	lsr.w	r3, r3, r2
 800602c:	f003 0301 	and.w	r3, r3, #1
 8006030:	2b00      	cmp	r3, #0
 8006032:	bf0c      	ite	eq
 8006034:	2300      	moveq	r3, #0
 8006036:	2301      	movne	r3, #1
 8006038:	b2db      	uxtb	r3, r3
 800603a:	2b00      	cmp	r3, #0
 800603c:	d190      	bne.n	8005f60 <HAL_RCC_OscConfig+0x1838>
 800603e:	e002      	b.n	8006046 <HAL_RCC_OscConfig+0x191e>
        }
      }
    }
    else
    {
      return HAL_ERROR;
 8006040:	f04f 0301 	mov.w	r3, #1
 8006044:	e001      	b.n	800604a <HAL_RCC_OscConfig+0x1922>
    }
  }
  return HAL_OK;
 8006046:	f04f 0300 	mov.w	r3, #0
}
 800604a:	4618      	mov	r0, r3
 800604c:	f507 7769 	add.w	r7, r7, #932	; 0x3a4
 8006050:	46bd      	mov	sp, r7
 8006052:	bd90      	pop	{r4, r7, pc}

08006054 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8006054:	b590      	push	{r4, r7, lr}
 8006056:	b0c5      	sub	sp, #276	; 0x114
 8006058:	af00      	add	r7, sp, #0
 800605a:	f107 0304 	add.w	r3, r7, #4
 800605e:	6018      	str	r0, [r3, #0]
 8006060:	463b      	mov	r3, r7
 8006062:	6019      	str	r1, [r3, #0]
  uint32_t tickstart = 0;
 8006064:	f04f 0300 	mov.w	r3, #0
 8006068:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
  must be correctly programmed according to the frequency of the CPU clock 
  (HCLK) and the supply voltage of the device. */
  
  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 800606c:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8006070:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006074:	681b      	ldr	r3, [r3, #0]
 8006076:	f003 0201 	and.w	r2, r3, #1
 800607a:	463b      	mov	r3, r7
 800607c:	681b      	ldr	r3, [r3, #0]
 800607e:	429a      	cmp	r2, r3
 8006080:	bf2c      	ite	cs
 8006082:	2300      	movcs	r3, #0
 8006084:	2301      	movcc	r3, #1
 8006086:	b2db      	uxtb	r3, r3
 8006088:	2b00      	cmp	r3, #0
 800608a:	f000 8258 	beq.w	800653e <HAL_RCC_ClockConfig+0x4ea>
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800608e:	463b      	mov	r3, r7
 8006090:	681b      	ldr	r3, [r3, #0]
 8006092:	2b01      	cmp	r3, #1
 8006094:	d10b      	bne.n	80060ae <HAL_RCC_ClockConfig+0x5a>
 8006096:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 800609a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800609e:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
 80060a2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80060a6:	6812      	ldr	r2, [r2, #0]
 80060a8:	f042 0204 	orr.w	r2, r2, #4
 80060ac:	601a      	str	r2, [r3, #0]
 80060ae:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 80060b2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80060b6:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
 80060ba:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80060be:	6812      	ldr	r2, [r2, #0]
 80060c0:	f022 0101 	bic.w	r1, r2, #1
 80060c4:	463a      	mov	r2, r7
 80060c6:	6812      	ldr	r2, [r2, #0]
 80060c8:	430a      	orrs	r2, r1
 80060ca:	601a      	str	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 80060cc:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 80060d0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80060d4:	681b      	ldr	r3, [r3, #0]
 80060d6:	f003 0201 	and.w	r2, r3, #1
 80060da:	463b      	mov	r3, r7
 80060dc:	681b      	ldr	r3, [r3, #0]
 80060de:	429a      	cmp	r2, r3
 80060e0:	bf0c      	ite	eq
 80060e2:	2300      	moveq	r3, #0
 80060e4:	2301      	movne	r3, #1
 80060e6:	b2db      	uxtb	r3, r3
 80060e8:	2b00      	cmp	r3, #0
 80060ea:	d003      	beq.n	80060f4 <HAL_RCC_ClockConfig+0xa0>
    {
      return HAL_ERROR;
 80060ec:	f04f 0301 	mov.w	r3, #1
 80060f0:	f000 bc83 	b.w	80069fa <HAL_RCC_ClockConfig+0x9a6>
    }
    
    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80060f4:	f107 0304 	add.w	r3, r7, #4
 80060f8:	681b      	ldr	r3, [r3, #0]
 80060fa:	681b      	ldr	r3, [r3, #0]
 80060fc:	f003 0302 	and.w	r3, r3, #2
 8006100:	2b00      	cmp	r3, #0
 8006102:	d010      	beq.n	8006126 <HAL_RCC_ClockConfig+0xd2>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8006104:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006108:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800610c:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8006110:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8006114:	6892      	ldr	r2, [r2, #8]
 8006116:	f022 01f0 	bic.w	r1, r2, #240	; 0xf0
 800611a:	f107 0204 	add.w	r2, r7, #4
 800611e:	6812      	ldr	r2, [r2, #0]
 8006120:	6892      	ldr	r2, [r2, #8]
 8006122:	430a      	orrs	r2, r1
 8006124:	609a      	str	r2, [r3, #8]
    }

    /*------------------------- SYSCLK Configuration ---------------------------*/ 
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8006126:	f107 0304 	add.w	r3, r7, #4
 800612a:	681b      	ldr	r3, [r3, #0]
 800612c:	681b      	ldr	r3, [r3, #0]
 800612e:	f003 0301 	and.w	r3, r3, #1
 8006132:	2b00      	cmp	r3, #0
 8006134:	f000 8427 	beq.w	8006986 <HAL_RCC_ClockConfig+0x932>
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8006138:	f107 0304 	add.w	r3, r7, #4
 800613c:	681b      	ldr	r3, [r3, #0]
 800613e:	685b      	ldr	r3, [r3, #4]
 8006140:	2b02      	cmp	r3, #2
 8006142:	d151      	bne.n	80061e8 <HAL_RCC_ClockConfig+0x194>
 8006144:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8006148:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800614c:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006150:	fa93 f4a3 	rbit	r4, r3
 8006154:	f8c7 4104 	str.w	r4, [r7, #260]	; 0x104
   return(result);
 8006158:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800615c:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8006160:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8006164:	fab3 f483 	clz	r4, r3
 8006168:	f8c7 40fc 	str.w	r4, [r7, #252]	; 0xfc
  return(result);
 800616c:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8006170:	b2db      	uxtb	r3, r3
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8006172:	f043 0320 	orr.w	r3, r3, #32
 8006176:	b2db      	uxtb	r3, r3
 8006178:	ea4f 1363 	mov.w	r3, r3, asr #5
 800617c:	2b01      	cmp	r3, #1
 800617e:	d105      	bne.n	800618c <HAL_RCC_ClockConfig+0x138>
 8006180:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006184:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006188:	681b      	ldr	r3, [r3, #0]
 800618a:	e004      	b.n	8006196 <HAL_RCC_ClockConfig+0x142>
 800618c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006190:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006194:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006196:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 800619a:	f8c7 20f8 	str.w	r2, [r7, #248]	; 0xf8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800619e:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 80061a2:	fa92 f4a2 	rbit	r4, r2
 80061a6:	f8c7 40f4 	str.w	r4, [r7, #244]	; 0xf4
   return(result);
 80061aa:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 80061ae:	f8c7 20f0 	str.w	r2, [r7, #240]	; 0xf0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80061b2:	f8d7 20f0 	ldr.w	r2, [r7, #240]	; 0xf0
 80061b6:	fab2 f482 	clz	r4, r2
 80061ba:	f8c7 40ec 	str.w	r4, [r7, #236]	; 0xec
  return(result);
 80061be:	f8d7 20ec 	ldr.w	r2, [r7, #236]	; 0xec
 80061c2:	b2d2      	uxtb	r2, r2
 80061c4:	f002 021f 	and.w	r2, r2, #31
 80061c8:	fa23 f302 	lsr.w	r3, r3, r2
 80061cc:	f003 0301 	and.w	r3, r3, #1
 80061d0:	2b00      	cmp	r3, #0
 80061d2:	bf14      	ite	ne
 80061d4:	2300      	movne	r3, #0
 80061d6:	2301      	moveq	r3, #1
 80061d8:	b2db      	uxtb	r3, r3
 80061da:	2b00      	cmp	r3, #0
 80061dc:	f000 8101 	beq.w	80063e2 <HAL_RCC_ClockConfig+0x38e>
        {
          return HAL_ERROR;
 80061e0:	f04f 0301 	mov.w	r3, #1
 80061e4:	f000 bc09 	b.w	80069fa <HAL_RCC_ClockConfig+0x9a6>
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80061e8:	f107 0304 	add.w	r3, r7, #4
 80061ec:	681b      	ldr	r3, [r3, #0]
 80061ee:	685b      	ldr	r3, [r3, #4]
 80061f0:	2b03      	cmp	r3, #3
 80061f2:	d150      	bne.n	8006296 <HAL_RCC_ClockConfig+0x242>
 80061f4:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 80061f8:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80061fc:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 8006200:	fa93 f4a3 	rbit	r4, r3
 8006204:	f8c7 40e4 	str.w	r4, [r7, #228]	; 0xe4
   return(result);
 8006208:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800620c:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8006210:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8006214:	fab3 f483 	clz	r4, r3
 8006218:	f8c7 40dc 	str.w	r4, [r7, #220]	; 0xdc
  return(result);
 800621c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8006220:	b2db      	uxtb	r3, r3
      {
        /* Check the PLL ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8006222:	f043 0320 	orr.w	r3, r3, #32
 8006226:	b2db      	uxtb	r3, r3
 8006228:	ea4f 1363 	mov.w	r3, r3, asr #5
 800622c:	2b01      	cmp	r3, #1
 800622e:	d105      	bne.n	800623c <HAL_RCC_ClockConfig+0x1e8>
 8006230:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006234:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006238:	681b      	ldr	r3, [r3, #0]
 800623a:	e004      	b.n	8006246 <HAL_RCC_ClockConfig+0x1f2>
 800623c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006240:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006244:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006246:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 800624a:	f8c7 20d8 	str.w	r2, [r7, #216]	; 0xd8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800624e:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
 8006252:	fa92 f4a2 	rbit	r4, r2
 8006256:	f8c7 40d4 	str.w	r4, [r7, #212]	; 0xd4
   return(result);
 800625a:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 800625e:	f8c7 20d0 	str.w	r2, [r7, #208]	; 0xd0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8006262:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 8006266:	fab2 f482 	clz	r4, r2
 800626a:	f8c7 40cc 	str.w	r4, [r7, #204]	; 0xcc
  return(result);
 800626e:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
 8006272:	b2d2      	uxtb	r2, r2
 8006274:	f002 021f 	and.w	r2, r2, #31
 8006278:	fa23 f302 	lsr.w	r3, r3, r2
 800627c:	f003 0301 	and.w	r3, r3, #1
 8006280:	2b00      	cmp	r3, #0
 8006282:	bf14      	ite	ne
 8006284:	2300      	movne	r3, #0
 8006286:	2301      	moveq	r3, #1
 8006288:	b2db      	uxtb	r3, r3
 800628a:	2b00      	cmp	r3, #0
 800628c:	f000 80a9 	beq.w	80063e2 <HAL_RCC_ClockConfig+0x38e>
        {
          return HAL_ERROR;
 8006290:	f04f 0301 	mov.w	r3, #1
 8006294:	e3b1      	b.n	80069fa <HAL_RCC_ClockConfig+0x9a6>
        }
      }
      /* HSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 8006296:	f107 0304 	add.w	r3, r7, #4
 800629a:	681b      	ldr	r3, [r3, #0]
 800629c:	685b      	ldr	r3, [r3, #4]
 800629e:	2b01      	cmp	r3, #1
 80062a0:	d14f      	bne.n	8006342 <HAL_RCC_ClockConfig+0x2ee>
 80062a2:	f04f 0302 	mov.w	r3, #2
 80062a6:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80062aa:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 80062ae:	fa93 f4a3 	rbit	r4, r3
 80062b2:	f8c7 40c4 	str.w	r4, [r7, #196]	; 0xc4
   return(result);
 80062b6:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 80062ba:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80062be:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 80062c2:	fab3 f483 	clz	r4, r3
 80062c6:	f8c7 40bc 	str.w	r4, [r7, #188]	; 0xbc
  return(result);
 80062ca:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 80062ce:	b2db      	uxtb	r3, r3
      {
        /* Check the HSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80062d0:	f043 0320 	orr.w	r3, r3, #32
 80062d4:	b2db      	uxtb	r3, r3
 80062d6:	ea4f 1363 	mov.w	r3, r3, asr #5
 80062da:	2b01      	cmp	r3, #1
 80062dc:	d105      	bne.n	80062ea <HAL_RCC_ClockConfig+0x296>
 80062de:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80062e2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80062e6:	681b      	ldr	r3, [r3, #0]
 80062e8:	e004      	b.n	80062f4 <HAL_RCC_ClockConfig+0x2a0>
 80062ea:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80062ee:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80062f2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80062f4:	f04f 0202 	mov.w	r2, #2
 80062f8:	f8c7 20b8 	str.w	r2, [r7, #184]	; 0xb8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80062fc:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 8006300:	fa92 f4a2 	rbit	r4, r2
 8006304:	f8c7 40b4 	str.w	r4, [r7, #180]	; 0xb4
   return(result);
 8006308:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 800630c:	f8c7 20b0 	str.w	r2, [r7, #176]	; 0xb0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8006310:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 8006314:	fab2 f482 	clz	r4, r2
 8006318:	f8c7 40ac 	str.w	r4, [r7, #172]	; 0xac
  return(result);
 800631c:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 8006320:	b2d2      	uxtb	r2, r2
 8006322:	f002 021f 	and.w	r2, r2, #31
 8006326:	fa23 f302 	lsr.w	r3, r3, r2
 800632a:	f003 0301 	and.w	r3, r3, #1
 800632e:	2b00      	cmp	r3, #0
 8006330:	bf14      	ite	ne
 8006332:	2300      	movne	r3, #0
 8006334:	2301      	moveq	r3, #1
 8006336:	b2db      	uxtb	r3, r3
 8006338:	2b00      	cmp	r3, #0
 800633a:	d052      	beq.n	80063e2 <HAL_RCC_ClockConfig+0x38e>
        {
          return HAL_ERROR;
 800633c:	f04f 0301 	mov.w	r3, #1
 8006340:	e35b      	b.n	80069fa <HAL_RCC_ClockConfig+0x9a6>
 8006342:	f44f 7300 	mov.w	r3, #512	; 0x200
 8006346:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800634a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800634e:	fa93 f4a3 	rbit	r4, r3
 8006352:	f8c7 40a4 	str.w	r4, [r7, #164]	; 0xa4
   return(result);
 8006356:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800635a:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 800635e:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8006362:	fab3 f483 	clz	r4, r3
 8006366:	f8c7 409c 	str.w	r4, [r7, #156]	; 0x9c
  return(result);
 800636a:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800636e:	b2db      	uxtb	r3, r3
      }
      /* MSI is selected as System Clock Source */
      else
      {
        /* Check the MSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
 8006370:	f043 0320 	orr.w	r3, r3, #32
 8006374:	b2db      	uxtb	r3, r3
 8006376:	ea4f 1363 	mov.w	r3, r3, asr #5
 800637a:	2b01      	cmp	r3, #1
 800637c:	d105      	bne.n	800638a <HAL_RCC_ClockConfig+0x336>
 800637e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006382:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006386:	681b      	ldr	r3, [r3, #0]
 8006388:	e004      	b.n	8006394 <HAL_RCC_ClockConfig+0x340>
 800638a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800638e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006392:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006394:	f44f 7200 	mov.w	r2, #512	; 0x200
 8006398:	f8c7 2098 	str.w	r2, [r7, #152]	; 0x98
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800639c:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 80063a0:	fa92 f4a2 	rbit	r4, r2
 80063a4:	f8c7 4094 	str.w	r4, [r7, #148]	; 0x94
   return(result);
 80063a8:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 80063ac:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80063b0:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 80063b4:	fab2 f482 	clz	r4, r2
 80063b8:	f8c7 408c 	str.w	r4, [r7, #140]	; 0x8c
  return(result);
 80063bc:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 80063c0:	b2d2      	uxtb	r2, r2
 80063c2:	f002 021f 	and.w	r2, r2, #31
 80063c6:	fa23 f302 	lsr.w	r3, r3, r2
 80063ca:	f003 0301 	and.w	r3, r3, #1
 80063ce:	2b00      	cmp	r3, #0
 80063d0:	bf14      	ite	ne
 80063d2:	2300      	movne	r3, #0
 80063d4:	2301      	moveq	r3, #1
 80063d6:	b2db      	uxtb	r3, r3
 80063d8:	2b00      	cmp	r3, #0
 80063da:	d002      	beq.n	80063e2 <HAL_RCC_ClockConfig+0x38e>
        {
          return HAL_ERROR;
 80063dc:	f04f 0301 	mov.w	r3, #1
 80063e0:	e30b      	b.n	80069fa <HAL_RCC_ClockConfig+0x9a6>
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 80063e2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80063e6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80063ea:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80063ee:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80063f2:	6892      	ldr	r2, [r2, #8]
 80063f4:	f022 0103 	bic.w	r1, r2, #3
 80063f8:	f107 0204 	add.w	r2, r7, #4
 80063fc:	6812      	ldr	r2, [r2, #0]
 80063fe:	6852      	ldr	r2, [r2, #4]
 8006400:	430a      	orrs	r2, r1
 8006402:	609a      	str	r2, [r3, #8]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8006404:	f7fb ffb2 	bl	800236c <HAL_GetTick>
 8006408:	f8c7 010c 	str.w	r0, [r7, #268]	; 0x10c
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800640c:	f107 0304 	add.w	r3, r7, #4
 8006410:	681b      	ldr	r3, [r3, #0]
 8006412:	685b      	ldr	r3, [r3, #4]
 8006414:	2b02      	cmp	r3, #2
 8006416:	d121      	bne.n	800645c <HAL_RCC_ClockConfig+0x408>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 8006418:	e011      	b.n	800643e <HAL_RCC_ClockConfig+0x3ea>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800641a:	f7fb ffa7 	bl	800236c <HAL_GetTick>
 800641e:	4602      	mov	r2, r0
 8006420:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8006424:	1ad2      	subs	r2, r2, r3
 8006426:	f241 3388 	movw	r3, #5000	; 0x1388
 800642a:	429a      	cmp	r2, r3
 800642c:	bf94      	ite	ls
 800642e:	2300      	movls	r3, #0
 8006430:	2301      	movhi	r3, #1
 8006432:	b2db      	uxtb	r3, r3
 8006434:	2b00      	cmp	r3, #0
 8006436:	d002      	beq.n	800643e <HAL_RCC_ClockConfig+0x3ea>
          {
            return HAL_TIMEOUT;
 8006438:	f04f 0303 	mov.w	r3, #3
 800643c:	e2dd      	b.n	80069fa <HAL_RCC_ClockConfig+0x9a6>
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 800643e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006442:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006446:	689b      	ldr	r3, [r3, #8]
 8006448:	f003 030c 	and.w	r3, r3, #12
 800644c:	2b08      	cmp	r3, #8
 800644e:	bf0c      	ite	eq
 8006450:	2300      	moveq	r3, #0
 8006452:	2301      	movne	r3, #1
 8006454:	b2db      	uxtb	r3, r3
 8006456:	2b00      	cmp	r3, #0
 8006458:	d1df      	bne.n	800641a <HAL_RCC_ClockConfig+0x3c6>
 800645a:	e294      	b.n	8006986 <HAL_RCC_ClockConfig+0x932>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800645c:	f107 0304 	add.w	r3, r7, #4
 8006460:	681b      	ldr	r3, [r3, #0]
 8006462:	685b      	ldr	r3, [r3, #4]
 8006464:	2b03      	cmp	r3, #3
 8006466:	d121      	bne.n	80064ac <HAL_RCC_ClockConfig+0x458>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8006468:	e011      	b.n	800648e <HAL_RCC_ClockConfig+0x43a>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800646a:	f7fb ff7f 	bl	800236c <HAL_GetTick>
 800646e:	4602      	mov	r2, r0
 8006470:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8006474:	1ad2      	subs	r2, r2, r3
 8006476:	f241 3388 	movw	r3, #5000	; 0x1388
 800647a:	429a      	cmp	r2, r3
 800647c:	bf94      	ite	ls
 800647e:	2300      	movls	r3, #0
 8006480:	2301      	movhi	r3, #1
 8006482:	b2db      	uxtb	r3, r3
 8006484:	2b00      	cmp	r3, #0
 8006486:	d002      	beq.n	800648e <HAL_RCC_ClockConfig+0x43a>
          {
            return HAL_TIMEOUT;
 8006488:	f04f 0303 	mov.w	r3, #3
 800648c:	e2b5      	b.n	80069fa <HAL_RCC_ClockConfig+0x9a6>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 800648e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006492:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006496:	689b      	ldr	r3, [r3, #8]
 8006498:	f003 030c 	and.w	r3, r3, #12
 800649c:	2b0c      	cmp	r3, #12
 800649e:	bf0c      	ite	eq
 80064a0:	2300      	moveq	r3, #0
 80064a2:	2301      	movne	r3, #1
 80064a4:	b2db      	uxtb	r3, r3
 80064a6:	2b00      	cmp	r3, #0
 80064a8:	d1df      	bne.n	800646a <HAL_RCC_ClockConfig+0x416>
 80064aa:	e26c      	b.n	8006986 <HAL_RCC_ClockConfig+0x932>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 80064ac:	f107 0304 	add.w	r3, r7, #4
 80064b0:	681b      	ldr	r3, [r3, #0]
 80064b2:	685b      	ldr	r3, [r3, #4]
 80064b4:	2b01      	cmp	r3, #1
 80064b6:	d133      	bne.n	8006520 <HAL_RCC_ClockConfig+0x4cc>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 80064b8:	e011      	b.n	80064de <HAL_RCC_ClockConfig+0x48a>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80064ba:	f7fb ff57 	bl	800236c <HAL_GetTick>
 80064be:	4602      	mov	r2, r0
 80064c0:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80064c4:	1ad2      	subs	r2, r2, r3
 80064c6:	f241 3388 	movw	r3, #5000	; 0x1388
 80064ca:	429a      	cmp	r2, r3
 80064cc:	bf94      	ite	ls
 80064ce:	2300      	movls	r3, #0
 80064d0:	2301      	movhi	r3, #1
 80064d2:	b2db      	uxtb	r3, r3
 80064d4:	2b00      	cmp	r3, #0
 80064d6:	d002      	beq.n	80064de <HAL_RCC_ClockConfig+0x48a>
          {
            return HAL_TIMEOUT;
 80064d8:	f04f 0303 	mov.w	r3, #3
 80064dc:	e28d      	b.n	80069fa <HAL_RCC_ClockConfig+0x9a6>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 80064de:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80064e2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80064e6:	689b      	ldr	r3, [r3, #8]
 80064e8:	f003 030c 	and.w	r3, r3, #12
 80064ec:	2b04      	cmp	r3, #4
 80064ee:	bf0c      	ite	eq
 80064f0:	2300      	moveq	r3, #0
 80064f2:	2301      	movne	r3, #1
 80064f4:	b2db      	uxtb	r3, r3
 80064f6:	2b00      	cmp	r3, #0
 80064f8:	d1df      	bne.n	80064ba <HAL_RCC_ClockConfig+0x466>
 80064fa:	e244      	b.n	8006986 <HAL_RCC_ClockConfig+0x932>
      }      
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80064fc:	f7fb ff36 	bl	800236c <HAL_GetTick>
 8006500:	4602      	mov	r2, r0
 8006502:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8006506:	1ad2      	subs	r2, r2, r3
 8006508:	f241 3388 	movw	r3, #5000	; 0x1388
 800650c:	429a      	cmp	r2, r3
 800650e:	bf94      	ite	ls
 8006510:	2300      	movls	r3, #0
 8006512:	2301      	movhi	r3, #1
 8006514:	b2db      	uxtb	r3, r3
 8006516:	2b00      	cmp	r3, #0
 8006518:	d002      	beq.n	8006520 <HAL_RCC_ClockConfig+0x4cc>
          {
            return HAL_TIMEOUT;
 800651a:	f04f 0303 	mov.w	r3, #3
 800651e:	e26c      	b.n	80069fa <HAL_RCC_ClockConfig+0x9a6>
          }
        }
      }      
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
 8006520:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006524:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006528:	689b      	ldr	r3, [r3, #8]
 800652a:	f003 030c 	and.w	r3, r3, #12
 800652e:	2b00      	cmp	r3, #0
 8006530:	bf0c      	ite	eq
 8006532:	2300      	moveq	r3, #0
 8006534:	2301      	movne	r3, #1
 8006536:	b2db      	uxtb	r3, r3
 8006538:	2b00      	cmp	r3, #0
 800653a:	d1df      	bne.n	80064fc <HAL_RCC_ClockConfig+0x4a8>
 800653c:	e223      	b.n	8006986 <HAL_RCC_ClockConfig+0x932>
  }
  /* Decreasing the CPU frequency */
  else
  {
    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800653e:	f107 0304 	add.w	r3, r7, #4
 8006542:	681b      	ldr	r3, [r3, #0]
 8006544:	681b      	ldr	r3, [r3, #0]
 8006546:	f003 0302 	and.w	r3, r3, #2
 800654a:	2b00      	cmp	r3, #0
 800654c:	d010      	beq.n	8006570 <HAL_RCC_ClockConfig+0x51c>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800654e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006552:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006556:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800655a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800655e:	6892      	ldr	r2, [r2, #8]
 8006560:	f022 01f0 	bic.w	r1, r2, #240	; 0xf0
 8006564:	f107 0204 	add.w	r2, r7, #4
 8006568:	6812      	ldr	r2, [r2, #0]
 800656a:	6892      	ldr	r2, [r2, #8]
 800656c:	430a      	orrs	r2, r1
 800656e:	609a      	str	r2, [r3, #8]
    }
    
    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8006570:	f107 0304 	add.w	r3, r7, #4
 8006574:	681b      	ldr	r3, [r3, #0]
 8006576:	681b      	ldr	r3, [r3, #0]
 8006578:	f003 0301 	and.w	r3, r3, #1
 800657c:	2b00      	cmp	r3, #0
 800657e:	f000 81d0 	beq.w	8006922 <HAL_RCC_ClockConfig+0x8ce>
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8006582:	f107 0304 	add.w	r3, r7, #4
 8006586:	681b      	ldr	r3, [r3, #0]
 8006588:	685b      	ldr	r3, [r3, #4]
 800658a:	2b02      	cmp	r3, #2
 800658c:	d146      	bne.n	800661c <HAL_RCC_ClockConfig+0x5c8>
 800658e:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8006592:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006596:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800659a:	fa93 f4a3 	rbit	r4, r3
 800659e:	f8c7 4084 	str.w	r4, [r7, #132]	; 0x84
   return(result);
 80065a2:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80065a6:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80065aa:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 80065ae:	fab3 f483 	clz	r4, r3
 80065b2:	67fc      	str	r4, [r7, #124]	; 0x7c
  return(result);
 80065b4:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80065b6:	b2db      	uxtb	r3, r3
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80065b8:	f043 0320 	orr.w	r3, r3, #32
 80065bc:	b2db      	uxtb	r3, r3
 80065be:	ea4f 1363 	mov.w	r3, r3, asr #5
 80065c2:	2b01      	cmp	r3, #1
 80065c4:	d105      	bne.n	80065d2 <HAL_RCC_ClockConfig+0x57e>
 80065c6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80065ca:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80065ce:	681b      	ldr	r3, [r3, #0]
 80065d0:	e004      	b.n	80065dc <HAL_RCC_ClockConfig+0x588>
 80065d2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80065d6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80065da:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80065dc:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 80065e0:	67ba      	str	r2, [r7, #120]	; 0x78
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80065e2:	6fba      	ldr	r2, [r7, #120]	; 0x78
 80065e4:	fa92 f4a2 	rbit	r4, r2
 80065e8:	677c      	str	r4, [r7, #116]	; 0x74
   return(result);
 80065ea:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 80065ec:	673a      	str	r2, [r7, #112]	; 0x70
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80065ee:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 80065f0:	fab2 f482 	clz	r4, r2
 80065f4:	66fc      	str	r4, [r7, #108]	; 0x6c
  return(result);
 80065f6:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 80065f8:	b2d2      	uxtb	r2, r2
 80065fa:	f002 021f 	and.w	r2, r2, #31
 80065fe:	fa23 f302 	lsr.w	r3, r3, r2
 8006602:	f003 0301 	and.w	r3, r3, #1
 8006606:	2b00      	cmp	r3, #0
 8006608:	bf14      	ite	ne
 800660a:	2300      	movne	r3, #0
 800660c:	2301      	moveq	r3, #1
 800660e:	b2db      	uxtb	r3, r3
 8006610:	2b00      	cmp	r3, #0
 8006612:	f000 80d9 	beq.w	80067c8 <HAL_RCC_ClockConfig+0x774>
        {
          return HAL_ERROR;
 8006616:	f04f 0301 	mov.w	r3, #1
 800661a:	e1ee      	b.n	80069fa <HAL_RCC_ClockConfig+0x9a6>
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800661c:	f107 0304 	add.w	r3, r7, #4
 8006620:	681b      	ldr	r3, [r3, #0]
 8006622:	685b      	ldr	r3, [r3, #4]
 8006624:	2b03      	cmp	r3, #3
 8006626:	d140      	bne.n	80066aa <HAL_RCC_ClockConfig+0x656>
 8006628:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800662c:	66bb      	str	r3, [r7, #104]	; 0x68
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800662e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8006630:	fa93 f4a3 	rbit	r4, r3
 8006634:	667c      	str	r4, [r7, #100]	; 0x64
   return(result);
 8006636:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8006638:	663b      	str	r3, [r7, #96]	; 0x60
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 800663a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800663c:	fab3 f483 	clz	r4, r3
 8006640:	65fc      	str	r4, [r7, #92]	; 0x5c
  return(result);
 8006642:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8006644:	b2db      	uxtb	r3, r3
      {
        /* Check the PLL ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8006646:	f043 0320 	orr.w	r3, r3, #32
 800664a:	b2db      	uxtb	r3, r3
 800664c:	ea4f 1363 	mov.w	r3, r3, asr #5
 8006650:	2b01      	cmp	r3, #1
 8006652:	d105      	bne.n	8006660 <HAL_RCC_ClockConfig+0x60c>
 8006654:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006658:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800665c:	681b      	ldr	r3, [r3, #0]
 800665e:	e004      	b.n	800666a <HAL_RCC_ClockConfig+0x616>
 8006660:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006664:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006668:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800666a:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 800666e:	65ba      	str	r2, [r7, #88]	; 0x58
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006670:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8006672:	fa92 f4a2 	rbit	r4, r2
 8006676:	657c      	str	r4, [r7, #84]	; 0x54
   return(result);
 8006678:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800667a:	653a      	str	r2, [r7, #80]	; 0x50
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 800667c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800667e:	fab2 f482 	clz	r4, r2
 8006682:	64fc      	str	r4, [r7, #76]	; 0x4c
  return(result);
 8006684:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8006686:	b2d2      	uxtb	r2, r2
 8006688:	f002 021f 	and.w	r2, r2, #31
 800668c:	fa23 f302 	lsr.w	r3, r3, r2
 8006690:	f003 0301 	and.w	r3, r3, #1
 8006694:	2b00      	cmp	r3, #0
 8006696:	bf14      	ite	ne
 8006698:	2300      	movne	r3, #0
 800669a:	2301      	moveq	r3, #1
 800669c:	b2db      	uxtb	r3, r3
 800669e:	2b00      	cmp	r3, #0
 80066a0:	f000 8092 	beq.w	80067c8 <HAL_RCC_ClockConfig+0x774>
        {
          return HAL_ERROR;
 80066a4:	f04f 0301 	mov.w	r3, #1
 80066a8:	e1a7      	b.n	80069fa <HAL_RCC_ClockConfig+0x9a6>
        }
      }
      /* HSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 80066aa:	f107 0304 	add.w	r3, r7, #4
 80066ae:	681b      	ldr	r3, [r3, #0]
 80066b0:	685b      	ldr	r3, [r3, #4]
 80066b2:	2b01      	cmp	r3, #1
 80066b4:	d13f      	bne.n	8006736 <HAL_RCC_ClockConfig+0x6e2>
 80066b6:	f04f 0302 	mov.w	r3, #2
 80066ba:	64bb      	str	r3, [r7, #72]	; 0x48
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80066bc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80066be:	fa93 f4a3 	rbit	r4, r3
 80066c2:	647c      	str	r4, [r7, #68]	; 0x44
   return(result);
 80066c4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80066c6:	643b      	str	r3, [r7, #64]	; 0x40
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80066c8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80066ca:	fab3 f483 	clz	r4, r3
 80066ce:	63fc      	str	r4, [r7, #60]	; 0x3c
  return(result);
 80066d0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80066d2:	b2db      	uxtb	r3, r3
      {
        /* Check the HSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80066d4:	f043 0320 	orr.w	r3, r3, #32
 80066d8:	b2db      	uxtb	r3, r3
 80066da:	ea4f 1363 	mov.w	r3, r3, asr #5
 80066de:	2b01      	cmp	r3, #1
 80066e0:	d105      	bne.n	80066ee <HAL_RCC_ClockConfig+0x69a>
 80066e2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80066e6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80066ea:	681b      	ldr	r3, [r3, #0]
 80066ec:	e004      	b.n	80066f8 <HAL_RCC_ClockConfig+0x6a4>
 80066ee:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80066f2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80066f6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80066f8:	f04f 0202 	mov.w	r2, #2
 80066fc:	63ba      	str	r2, [r7, #56]	; 0x38
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80066fe:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8006700:	fa92 f4a2 	rbit	r4, r2
 8006704:	637c      	str	r4, [r7, #52]	; 0x34
   return(result);
 8006706:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8006708:	633a      	str	r2, [r7, #48]	; 0x30
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 800670a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800670c:	fab2 f482 	clz	r4, r2
 8006710:	62fc      	str	r4, [r7, #44]	; 0x2c
  return(result);
 8006712:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8006714:	b2d2      	uxtb	r2, r2
 8006716:	f002 021f 	and.w	r2, r2, #31
 800671a:	fa23 f302 	lsr.w	r3, r3, r2
 800671e:	f003 0301 	and.w	r3, r3, #1
 8006722:	2b00      	cmp	r3, #0
 8006724:	bf14      	ite	ne
 8006726:	2300      	movne	r3, #0
 8006728:	2301      	moveq	r3, #1
 800672a:	b2db      	uxtb	r3, r3
 800672c:	2b00      	cmp	r3, #0
 800672e:	d04b      	beq.n	80067c8 <HAL_RCC_ClockConfig+0x774>
        {
          return HAL_ERROR;
 8006730:	f04f 0301 	mov.w	r3, #1
 8006734:	e161      	b.n	80069fa <HAL_RCC_ClockConfig+0x9a6>
 8006736:	f44f 7300 	mov.w	r3, #512	; 0x200
 800673a:	62bb      	str	r3, [r7, #40]	; 0x28
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800673c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800673e:	fa93 f4a3 	rbit	r4, r3
 8006742:	627c      	str	r4, [r7, #36]	; 0x24
   return(result);
 8006744:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006746:	623b      	str	r3, [r7, #32]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8006748:	6a3b      	ldr	r3, [r7, #32]
 800674a:	fab3 f483 	clz	r4, r3
 800674e:	61fc      	str	r4, [r7, #28]
  return(result);
 8006750:	69fb      	ldr	r3, [r7, #28]
 8006752:	b2db      	uxtb	r3, r3
      }
      /* MSI is selected as System Clock Source */
      else
      {
        /* Check the MSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
 8006754:	f043 0320 	orr.w	r3, r3, #32
 8006758:	b2db      	uxtb	r3, r3
 800675a:	ea4f 1363 	mov.w	r3, r3, asr #5
 800675e:	2b01      	cmp	r3, #1
 8006760:	d105      	bne.n	800676e <HAL_RCC_ClockConfig+0x71a>
 8006762:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006766:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800676a:	681b      	ldr	r3, [r3, #0]
 800676c:	e004      	b.n	8006778 <HAL_RCC_ClockConfig+0x724>
 800676e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006772:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006776:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006778:	f44f 7200 	mov.w	r2, #512	; 0x200
 800677c:	61ba      	str	r2, [r7, #24]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800677e:	69ba      	ldr	r2, [r7, #24]
 8006780:	fa92 f4a2 	rbit	r4, r2
 8006784:	617c      	str	r4, [r7, #20]
   return(result);
 8006786:	697a      	ldr	r2, [r7, #20]
 8006788:	4611      	mov	r1, r2
 800678a:	f107 0210 	add.w	r2, r7, #16
 800678e:	6011      	str	r1, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8006790:	f107 0210 	add.w	r2, r7, #16
 8006794:	6812      	ldr	r2, [r2, #0]
 8006796:	fab2 f482 	clz	r4, r2
 800679a:	f107 020c 	add.w	r2, r7, #12
 800679e:	6014      	str	r4, [r2, #0]
  return(result);
 80067a0:	f107 020c 	add.w	r2, r7, #12
 80067a4:	6812      	ldr	r2, [r2, #0]
 80067a6:	b2d2      	uxtb	r2, r2
 80067a8:	f002 021f 	and.w	r2, r2, #31
 80067ac:	fa23 f302 	lsr.w	r3, r3, r2
 80067b0:	f003 0301 	and.w	r3, r3, #1
 80067b4:	2b00      	cmp	r3, #0
 80067b6:	bf14      	ite	ne
 80067b8:	2300      	movne	r3, #0
 80067ba:	2301      	moveq	r3, #1
 80067bc:	b2db      	uxtb	r3, r3
 80067be:	2b00      	cmp	r3, #0
 80067c0:	d002      	beq.n	80067c8 <HAL_RCC_ClockConfig+0x774>
        {
          return HAL_ERROR;
 80067c2:	f04f 0301 	mov.w	r3, #1
 80067c6:	e118      	b.n	80069fa <HAL_RCC_ClockConfig+0x9a6>
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 80067c8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80067cc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80067d0:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80067d4:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80067d8:	6892      	ldr	r2, [r2, #8]
 80067da:	f022 0103 	bic.w	r1, r2, #3
 80067de:	f107 0204 	add.w	r2, r7, #4
 80067e2:	6812      	ldr	r2, [r2, #0]
 80067e4:	6852      	ldr	r2, [r2, #4]
 80067e6:	430a      	orrs	r2, r1
 80067e8:	609a      	str	r2, [r3, #8]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80067ea:	f7fb fdbf 	bl	800236c <HAL_GetTick>
 80067ee:	f8c7 010c 	str.w	r0, [r7, #268]	; 0x10c
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80067f2:	f107 0304 	add.w	r3, r7, #4
 80067f6:	681b      	ldr	r3, [r3, #0]
 80067f8:	685b      	ldr	r3, [r3, #4]
 80067fa:	2b02      	cmp	r3, #2
 80067fc:	d121      	bne.n	8006842 <HAL_RCC_ClockConfig+0x7ee>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 80067fe:	e011      	b.n	8006824 <HAL_RCC_ClockConfig+0x7d0>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8006800:	f7fb fdb4 	bl	800236c <HAL_GetTick>
 8006804:	4602      	mov	r2, r0
 8006806:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 800680a:	1ad2      	subs	r2, r2, r3
 800680c:	f241 3388 	movw	r3, #5000	; 0x1388
 8006810:	429a      	cmp	r2, r3
 8006812:	bf94      	ite	ls
 8006814:	2300      	movls	r3, #0
 8006816:	2301      	movhi	r3, #1
 8006818:	b2db      	uxtb	r3, r3
 800681a:	2b00      	cmp	r3, #0
 800681c:	d002      	beq.n	8006824 <HAL_RCC_ClockConfig+0x7d0>
          {
            return HAL_TIMEOUT;
 800681e:	f04f 0303 	mov.w	r3, #3
 8006822:	e0ea      	b.n	80069fa <HAL_RCC_ClockConfig+0x9a6>
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 8006824:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006828:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800682c:	689b      	ldr	r3, [r3, #8]
 800682e:	f003 030c 	and.w	r3, r3, #12
 8006832:	2b08      	cmp	r3, #8
 8006834:	bf0c      	ite	eq
 8006836:	2300      	moveq	r3, #0
 8006838:	2301      	movne	r3, #1
 800683a:	b2db      	uxtb	r3, r3
 800683c:	2b00      	cmp	r3, #0
 800683e:	d1df      	bne.n	8006800 <HAL_RCC_ClockConfig+0x7ac>
 8006840:	e06f      	b.n	8006922 <HAL_RCC_ClockConfig+0x8ce>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8006842:	f107 0304 	add.w	r3, r7, #4
 8006846:	681b      	ldr	r3, [r3, #0]
 8006848:	685b      	ldr	r3, [r3, #4]
 800684a:	2b03      	cmp	r3, #3
 800684c:	d121      	bne.n	8006892 <HAL_RCC_ClockConfig+0x83e>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 800684e:	e011      	b.n	8006874 <HAL_RCC_ClockConfig+0x820>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8006850:	f7fb fd8c 	bl	800236c <HAL_GetTick>
 8006854:	4602      	mov	r2, r0
 8006856:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 800685a:	1ad2      	subs	r2, r2, r3
 800685c:	f241 3388 	movw	r3, #5000	; 0x1388
 8006860:	429a      	cmp	r2, r3
 8006862:	bf94      	ite	ls
 8006864:	2300      	movls	r3, #0
 8006866:	2301      	movhi	r3, #1
 8006868:	b2db      	uxtb	r3, r3
 800686a:	2b00      	cmp	r3, #0
 800686c:	d002      	beq.n	8006874 <HAL_RCC_ClockConfig+0x820>
          {
            return HAL_TIMEOUT;
 800686e:	f04f 0303 	mov.w	r3, #3
 8006872:	e0c2      	b.n	80069fa <HAL_RCC_ClockConfig+0x9a6>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8006874:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006878:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800687c:	689b      	ldr	r3, [r3, #8]
 800687e:	f003 030c 	and.w	r3, r3, #12
 8006882:	2b0c      	cmp	r3, #12
 8006884:	bf0c      	ite	eq
 8006886:	2300      	moveq	r3, #0
 8006888:	2301      	movne	r3, #1
 800688a:	b2db      	uxtb	r3, r3
 800688c:	2b00      	cmp	r3, #0
 800688e:	d1df      	bne.n	8006850 <HAL_RCC_ClockConfig+0x7fc>
 8006890:	e047      	b.n	8006922 <HAL_RCC_ClockConfig+0x8ce>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 8006892:	f107 0304 	add.w	r3, r7, #4
 8006896:	681b      	ldr	r3, [r3, #0]
 8006898:	685b      	ldr	r3, [r3, #4]
 800689a:	2b01      	cmp	r3, #1
 800689c:	d133      	bne.n	8006906 <HAL_RCC_ClockConfig+0x8b2>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 800689e:	e011      	b.n	80068c4 <HAL_RCC_ClockConfig+0x870>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80068a0:	f7fb fd64 	bl	800236c <HAL_GetTick>
 80068a4:	4602      	mov	r2, r0
 80068a6:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80068aa:	1ad2      	subs	r2, r2, r3
 80068ac:	f241 3388 	movw	r3, #5000	; 0x1388
 80068b0:	429a      	cmp	r2, r3
 80068b2:	bf94      	ite	ls
 80068b4:	2300      	movls	r3, #0
 80068b6:	2301      	movhi	r3, #1
 80068b8:	b2db      	uxtb	r3, r3
 80068ba:	2b00      	cmp	r3, #0
 80068bc:	d002      	beq.n	80068c4 <HAL_RCC_ClockConfig+0x870>
          {
            return HAL_TIMEOUT;
 80068be:	f04f 0303 	mov.w	r3, #3
 80068c2:	e09a      	b.n	80069fa <HAL_RCC_ClockConfig+0x9a6>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 80068c4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80068c8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80068cc:	689b      	ldr	r3, [r3, #8]
 80068ce:	f003 030c 	and.w	r3, r3, #12
 80068d2:	2b04      	cmp	r3, #4
 80068d4:	bf0c      	ite	eq
 80068d6:	2300      	moveq	r3, #0
 80068d8:	2301      	movne	r3, #1
 80068da:	b2db      	uxtb	r3, r3
 80068dc:	2b00      	cmp	r3, #0
 80068de:	d1df      	bne.n	80068a0 <HAL_RCC_ClockConfig+0x84c>
 80068e0:	e01f      	b.n	8006922 <HAL_RCC_ClockConfig+0x8ce>
      }      
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80068e2:	f7fb fd43 	bl	800236c <HAL_GetTick>
 80068e6:	4602      	mov	r2, r0
 80068e8:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80068ec:	1ad2      	subs	r2, r2, r3
 80068ee:	f241 3388 	movw	r3, #5000	; 0x1388
 80068f2:	429a      	cmp	r2, r3
 80068f4:	bf94      	ite	ls
 80068f6:	2300      	movls	r3, #0
 80068f8:	2301      	movhi	r3, #1
 80068fa:	b2db      	uxtb	r3, r3
 80068fc:	2b00      	cmp	r3, #0
 80068fe:	d002      	beq.n	8006906 <HAL_RCC_ClockConfig+0x8b2>
          {
            return HAL_TIMEOUT;
 8006900:	f04f 0303 	mov.w	r3, #3
 8006904:	e079      	b.n	80069fa <HAL_RCC_ClockConfig+0x9a6>
          }
        }
      }      
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
 8006906:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800690a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800690e:	689b      	ldr	r3, [r3, #8]
 8006910:	f003 030c 	and.w	r3, r3, #12
 8006914:	2b00      	cmp	r3, #0
 8006916:	bf0c      	ite	eq
 8006918:	2300      	moveq	r3, #0
 800691a:	2301      	movne	r3, #1
 800691c:	b2db      	uxtb	r3, r3
 800691e:	2b00      	cmp	r3, #0
 8006920:	d1df      	bne.n	80068e2 <HAL_RCC_ClockConfig+0x88e>
        }
      }
    } 
    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8006922:	463b      	mov	r3, r7
 8006924:	681b      	ldr	r3, [r3, #0]
 8006926:	2b01      	cmp	r3, #1
 8006928:	d10b      	bne.n	8006942 <HAL_RCC_ClockConfig+0x8ee>
 800692a:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 800692e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006932:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
 8006936:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800693a:	6812      	ldr	r2, [r2, #0]
 800693c:	f042 0204 	orr.w	r2, r2, #4
 8006940:	601a      	str	r2, [r3, #0]
 8006942:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8006946:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800694a:	f44f 5270 	mov.w	r2, #15360	; 0x3c00
 800694e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8006952:	6812      	ldr	r2, [r2, #0]
 8006954:	f022 0101 	bic.w	r1, r2, #1
 8006958:	463a      	mov	r2, r7
 800695a:	6812      	ldr	r2, [r2, #0]
 800695c:	430a      	orrs	r2, r1
 800695e:	601a      	str	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8006960:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8006964:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006968:	681b      	ldr	r3, [r3, #0]
 800696a:	f003 0201 	and.w	r2, r3, #1
 800696e:	463b      	mov	r3, r7
 8006970:	681b      	ldr	r3, [r3, #0]
 8006972:	429a      	cmp	r2, r3
 8006974:	bf0c      	ite	eq
 8006976:	2300      	moveq	r3, #0
 8006978:	2301      	movne	r3, #1
 800697a:	b2db      	uxtb	r3, r3
 800697c:	2b00      	cmp	r3, #0
 800697e:	d002      	beq.n	8006986 <HAL_RCC_ClockConfig+0x932>
    {
      return HAL_ERROR;
 8006980:	f04f 0301 	mov.w	r3, #1
 8006984:	e039      	b.n	80069fa <HAL_RCC_ClockConfig+0x9a6>
    }
  }
  
  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8006986:	f107 0304 	add.w	r3, r7, #4
 800698a:	681b      	ldr	r3, [r3, #0]
 800698c:	681b      	ldr	r3, [r3, #0]
 800698e:	f003 0304 	and.w	r3, r3, #4
 8006992:	2b00      	cmp	r3, #0
 8006994:	d010      	beq.n	80069b8 <HAL_RCC_ClockConfig+0x964>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8006996:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800699a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800699e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80069a2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80069a6:	6892      	ldr	r2, [r2, #8]
 80069a8:	f422 61e0 	bic.w	r1, r2, #1792	; 0x700
 80069ac:	f107 0204 	add.w	r2, r7, #4
 80069b0:	6812      	ldr	r2, [r2, #0]
 80069b2:	68d2      	ldr	r2, [r2, #12]
 80069b4:	430a      	orrs	r2, r1
 80069b6:	609a      	str	r2, [r3, #8]
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80069b8:	f107 0304 	add.w	r3, r7, #4
 80069bc:	681b      	ldr	r3, [r3, #0]
 80069be:	681b      	ldr	r3, [r3, #0]
 80069c0:	f003 0308 	and.w	r3, r3, #8
 80069c4:	2b00      	cmp	r3, #0
 80069c6:	d012      	beq.n	80069ee <HAL_RCC_ClockConfig+0x99a>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 80069c8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80069cc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80069d0:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80069d4:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80069d8:	6892      	ldr	r2, [r2, #8]
 80069da:	f422 5160 	bic.w	r1, r2, #14336	; 0x3800
 80069de:	f107 0204 	add.w	r2, r7, #4
 80069e2:	6812      	ldr	r2, [r2, #0]
 80069e4:	6912      	ldr	r2, [r2, #16]
 80069e6:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80069ea:	430a      	orrs	r2, r1
 80069ec:	609a      	str	r2, [r3, #8]
  }
  
  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 80069ee:	f04f 0000 	mov.w	r0, #0
 80069f2:	f7fb fc89 	bl	8002308 <HAL_InitTick>
  
  return HAL_OK;
 80069f6:	f04f 0300 	mov.w	r3, #0
}
 80069fa:	4618      	mov	r0, r3
 80069fc:	f507 778a 	add.w	r7, r7, #276	; 0x114
 8006a00:	46bd      	mov	sp, r7
 8006a02:	bd90      	pop	{r4, r7, pc}

08006a04 <HAL_RCC_GetSysClockFreq>:
  *         
  *               
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8006a04:	b490      	push	{r4, r7}
 8006a06:	b092      	sub	sp, #72	; 0x48
 8006a08:	af00      	add	r7, sp, #0
  uint32_t tmpreg = 0, pllm = 0, plld = 0, pllvco = 0, msiclkrange = 0;
 8006a0a:	f04f 0300 	mov.w	r3, #0
 8006a0e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8006a10:	f04f 0300 	mov.w	r3, #0
 8006a14:	63bb      	str	r3, [r7, #56]	; 0x38
 8006a16:	f04f 0300 	mov.w	r3, #0
 8006a1a:	637b      	str	r3, [r7, #52]	; 0x34
 8006a1c:	f04f 0300 	mov.w	r3, #0
 8006a20:	647b      	str	r3, [r7, #68]	; 0x44
 8006a22:	f04f 0300 	mov.w	r3, #0
 8006a26:	633b      	str	r3, [r7, #48]	; 0x30
  uint32_t sysclockfreq = 0;
 8006a28:	f04f 0300 	mov.w	r3, #0
 8006a2c:	643b      	str	r3, [r7, #64]	; 0x40
  
  tmpreg = RCC->CFGR;
 8006a2e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006a32:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006a36:	689b      	ldr	r3, [r3, #8]
 8006a38:	63fb      	str	r3, [r7, #60]	; 0x3c
  
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 8006a3a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8006a3c:	f003 030c 	and.w	r3, r3, #12
 8006a40:	2b08      	cmp	r3, #8
 8006a42:	d009      	beq.n	8006a58 <HAL_RCC_GetSysClockFreq+0x54>
 8006a44:	2b0c      	cmp	r3, #12
 8006a46:	d00d      	beq.n	8006a64 <HAL_RCC_GetSysClockFreq+0x60>
 8006a48:	2b04      	cmp	r3, #4
 8006a4a:	d167      	bne.n	8006b1c <HAL_RCC_GetSysClockFreq+0x118>
  {
  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8006a4c:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 8006a50:	f2c0 03f4 	movt	r3, #244	; 0xf4
 8006a54:	643b      	str	r3, [r7, #64]	; 0x40
      break;
 8006a56:	e083      	b.n	8006b60 <HAL_RCC_GetSysClockFreq+0x15c>
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 8006a58:	f44f 5390 	mov.w	r3, #4608	; 0x1200
 8006a5c:	f2c0 037a 	movt	r3, #122	; 0x7a
 8006a60:	643b      	str	r3, [r7, #64]	; 0x40
      break;
 8006a62:	e07d      	b.n	8006b60 <HAL_RCC_GetSysClockFreq+0x15c>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock */
    {
      pllm = aPLLMulFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> POSITION_VAL(RCC_CFGR_PLLMUL)];
 8006a64:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8006a66:	f403 1270 	and.w	r2, r3, #3932160	; 0x3c0000
 8006a6a:	f44f 1370 	mov.w	r3, #3932160	; 0x3c0000
 8006a6e:	62fb      	str	r3, [r7, #44]	; 0x2c
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006a70:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006a72:	fa93 f4a3 	rbit	r4, r3
 8006a76:	62bc      	str	r4, [r7, #40]	; 0x28
   return(result);
 8006a78:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006a7a:	627b      	str	r3, [r7, #36]	; 0x24
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8006a7c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006a7e:	fab3 f483 	clz	r4, r3
 8006a82:	623c      	str	r4, [r7, #32]
  return(result);
 8006a84:	6a3b      	ldr	r3, [r7, #32]
 8006a86:	b2db      	uxtb	r3, r3
 8006a88:	fa22 f203 	lsr.w	r2, r2, r3
 8006a8c:	f646 53f4 	movw	r3, #28148	; 0x6df4
 8006a90:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006a94:	5c9b      	ldrb	r3, [r3, r2]
 8006a96:	63bb      	str	r3, [r7, #56]	; 0x38
      plld = aPLLDivisionFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLDIV) >> POSITION_VAL(RCC_CFGR_PLLDIV)];
 8006a98:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8006a9a:	f403 0240 	and.w	r2, r3, #12582912	; 0xc00000
 8006a9e:	f44f 0340 	mov.w	r3, #12582912	; 0xc00000
 8006aa2:	61fb      	str	r3, [r7, #28]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006aa4:	69fb      	ldr	r3, [r7, #28]
 8006aa6:	fa93 f4a3 	rbit	r4, r3
 8006aaa:	61bc      	str	r4, [r7, #24]
   return(result);
 8006aac:	69bb      	ldr	r3, [r7, #24]
 8006aae:	617b      	str	r3, [r7, #20]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8006ab0:	697b      	ldr	r3, [r7, #20]
 8006ab2:	fab3 f483 	clz	r4, r3
 8006ab6:	613c      	str	r4, [r7, #16]
  return(result);
 8006ab8:	693b      	ldr	r3, [r7, #16]
 8006aba:	b2db      	uxtb	r3, r3
 8006abc:	fa22 f203 	lsr.w	r2, r2, r3
 8006ac0:	f646 53f0 	movw	r3, #28144	; 0x6df0
 8006ac4:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006ac8:	5c9b      	ldrb	r3, [r3, r2]
 8006aca:	637b      	str	r3, [r7, #52]	; 0x34
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8006acc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006ad0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006ad4:	689b      	ldr	r3, [r3, #8]
 8006ad6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8006ada:	2b00      	cmp	r3, #0
 8006adc:	bf0c      	ite	eq
 8006ade:	2300      	moveq	r3, #0
 8006ae0:	2301      	movne	r3, #1
 8006ae2:	b2db      	uxtb	r3, r3
 8006ae4:	2b00      	cmp	r3, #0
 8006ae6:	d00b      	beq.n	8006b00 <HAL_RCC_GetSysClockFreq+0xfc>
      {
        /* HSE used as PLL clock source */
        pllvco = HSE_VALUE * (pllm / plld);
 8006ae8:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8006aea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8006aec:	fbb2 f2f3 	udiv	r2, r2, r3
 8006af0:	f44f 5390 	mov.w	r3, #4608	; 0x1200
 8006af4:	f2c0 037a 	movt	r3, #122	; 0x7a
 8006af8:	fb03 f302 	mul.w	r3, r3, r2
 8006afc:	647b      	str	r3, [r7, #68]	; 0x44
 8006afe:	e00a      	b.n	8006b16 <HAL_RCC_GetSysClockFreq+0x112>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = HSI_VALUE * (pllm / plld);
 8006b00:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8006b02:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8006b04:	fbb2 f2f3 	udiv	r2, r2, r3
 8006b08:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 8006b0c:	f2c0 03f4 	movt	r3, #244	; 0xf4
 8006b10:	fb03 f302 	mul.w	r3, r3, r2
 8006b14:	647b      	str	r3, [r7, #68]	; 0x44
      }
      sysclockfreq = pllvco;
 8006b16:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8006b18:	643b      	str	r3, [r7, #64]	; 0x40
      break;
 8006b1a:	e021      	b.n	8006b60 <HAL_RCC_GetSysClockFreq+0x15c>
    }
  case RCC_CFGR_SWS_MSI:  /* MSI used as system clock source */
  default: /* MSI used as system clock */
    {
      msiclkrange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> POSITION_VAL(RCC_ICSCR_MSIRANGE);
 8006b1c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006b20:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006b24:	685b      	ldr	r3, [r3, #4]
 8006b26:	f403 4260 	and.w	r2, r3, #57344	; 0xe000
 8006b2a:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 8006b2e:	60fb      	str	r3, [r7, #12]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006b30:	68fb      	ldr	r3, [r7, #12]
 8006b32:	fa93 f4a3 	rbit	r4, r3
 8006b36:	60bc      	str	r4, [r7, #8]
   return(result);
 8006b38:	68bb      	ldr	r3, [r7, #8]
 8006b3a:	607b      	str	r3, [r7, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8006b3c:	687b      	ldr	r3, [r7, #4]
 8006b3e:	fab3 f483 	clz	r4, r3
 8006b42:	603c      	str	r4, [r7, #0]
  return(result);
 8006b44:	683b      	ldr	r3, [r7, #0]
 8006b46:	b2db      	uxtb	r3, r3
 8006b48:	fa22 f303 	lsr.w	r3, r2, r3
 8006b4c:	633b      	str	r3, [r7, #48]	; 0x30
      sysclockfreq = (32768 * (1 << (msiclkrange + 1)));
 8006b4e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8006b50:	f103 0301 	add.w	r3, r3, #1
 8006b54:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8006b58:	fa02 f303 	lsl.w	r3, r2, r3
 8006b5c:	643b      	str	r3, [r7, #64]	; 0x40
      break;
 8006b5e:	bf00      	nop
    }
  }
  return sysclockfreq;
 8006b60:	6c3b      	ldr	r3, [r7, #64]	; 0x40
}
 8006b62:	4618      	mov	r0, r3
 8006b64:	f107 0748 	add.w	r7, r7, #72	; 0x48
 8006b68:	46bd      	mov	sp, r7
 8006b6a:	bc90      	pop	{r4, r7}
 8006b6c:	4770      	bx	lr
 8006b6e:	bf00      	nop

08006b70 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8006b70:	b590      	push	{r4, r7, lr}
 8006b72:	b085      	sub	sp, #20
 8006b74:	af00      	add	r7, sp, #0
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> aAPBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 8006b76:	f7ff ff45 	bl	8006a04 <HAL_RCC_GetSysClockFreq>
 8006b7a:	4602      	mov	r2, r0
 8006b7c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8006b80:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006b84:	689b      	ldr	r3, [r3, #8]
 8006b86:	f003 01f0 	and.w	r1, r3, #240	; 0xf0
 8006b8a:	f04f 03f0 	mov.w	r3, #240	; 0xf0
 8006b8e:	60fb      	str	r3, [r7, #12]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006b90:	68fb      	ldr	r3, [r7, #12]
 8006b92:	fa93 f4a3 	rbit	r4, r3
 8006b96:	60bc      	str	r4, [r7, #8]
   return(result);
 8006b98:	68bb      	ldr	r3, [r7, #8]
 8006b9a:	607b      	str	r3, [r7, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
   uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8006b9c:	687b      	ldr	r3, [r7, #4]
 8006b9e:	fab3 f483 	clz	r4, r3
 8006ba2:	603c      	str	r4, [r7, #0]
  return(result);
 8006ba4:	683b      	ldr	r3, [r7, #0]
 8006ba6:	b2db      	uxtb	r3, r3
 8006ba8:	fa21 f103 	lsr.w	r1, r1, r3
 8006bac:	f646 53e0 	movw	r3, #28128	; 0x6de0
 8006bb0:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006bb4:	5c5b      	ldrb	r3, [r3, r1]
 8006bb6:	fa22 f203 	lsr.w	r2, r2, r3
 8006bba:	f240 0300 	movw	r3, #0
 8006bbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006bc2:	601a      	str	r2, [r3, #0]
  return SystemCoreClock;
 8006bc4:	f240 0300 	movw	r3, #0
 8006bc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006bcc:	681b      	ldr	r3, [r3, #0]
}
 8006bce:	4618      	mov	r0, r3
 8006bd0:	f107 0714 	add.w	r7, r7, #20
 8006bd4:	46bd      	mov	sp, r7
 8006bd6:	bd90      	pop	{r4, r7, pc}

08006bd8 <__register_exitproc>:
 8006bd8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006bdc:	4c27      	ldr	r4, [pc, #156]	; (8006c7c <__register_exitproc+0xa4>)
 8006bde:	b084      	sub	sp, #16
 8006be0:	6825      	ldr	r5, [r4, #0]
 8006be2:	4607      	mov	r7, r0
 8006be4:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
 8006be8:	2c00      	cmp	r4, #0
 8006bea:	d041      	beq.n	8006c70 <__register_exitproc+0x98>
 8006bec:	6866      	ldr	r6, [r4, #4]
 8006bee:	2e1f      	cmp	r6, #31
 8006bf0:	dd1c      	ble.n	8006c2c <__register_exitproc+0x54>
 8006bf2:	4823      	ldr	r0, [pc, #140]	; (8006c80 <__register_exitproc+0xa8>)
 8006bf4:	b910      	cbnz	r0, 8006bfc <__register_exitproc+0x24>
 8006bf6:	f04f 30ff 	mov.w	r0, #4294967295
 8006bfa:	e01f      	b.n	8006c3c <__register_exitproc+0x64>
 8006bfc:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8006c00:	9103      	str	r1, [sp, #12]
 8006c02:	9202      	str	r2, [sp, #8]
 8006c04:	9301      	str	r3, [sp, #4]
 8006c06:	f3af 8000 	nop.w
 8006c0a:	9903      	ldr	r1, [sp, #12]
 8006c0c:	4604      	mov	r4, r0
 8006c0e:	9a02      	ldr	r2, [sp, #8]
 8006c10:	9b01      	ldr	r3, [sp, #4]
 8006c12:	2800      	cmp	r0, #0
 8006c14:	d0ef      	beq.n	8006bf6 <__register_exitproc+0x1e>
 8006c16:	f8d5 6148 	ldr.w	r6, [r5, #328]	; 0x148
 8006c1a:	2000      	movs	r0, #0
 8006c1c:	6060      	str	r0, [r4, #4]
 8006c1e:	6026      	str	r6, [r4, #0]
 8006c20:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
 8006c24:	f8c4 0188 	str.w	r0, [r4, #392]	; 0x188
 8006c28:	f8c4 018c 	str.w	r0, [r4, #396]	; 0x18c
 8006c2c:	6865      	ldr	r5, [r4, #4]
 8006c2e:	b947      	cbnz	r7, 8006c42 <__register_exitproc+0x6a>
 8006c30:	1ca8      	adds	r0, r5, #2
 8006c32:	3501      	adds	r5, #1
 8006c34:	f844 1020 	str.w	r1, [r4, r0, lsl #2]
 8006c38:	6065      	str	r5, [r4, #4]
 8006c3a:	2000      	movs	r0, #0
 8006c3c:	b004      	add	sp, #16
 8006c3e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006c42:	2001      	movs	r0, #1
 8006c44:	fa00 f005 	lsl.w	r0, r0, r5
 8006c48:	f8d4 6188 	ldr.w	r6, [r4, #392]	; 0x188
 8006c4c:	eb04 0885 	add.w	r8, r4, r5, lsl #2
 8006c50:	4306      	orrs	r6, r0
 8006c52:	2f02      	cmp	r7, #2
 8006c54:	f8c8 2088 	str.w	r2, [r8, #136]	; 0x88
 8006c58:	f8c4 6188 	str.w	r6, [r4, #392]	; 0x188
 8006c5c:	f8c8 3108 	str.w	r3, [r8, #264]	; 0x108
 8006c60:	d1e6      	bne.n	8006c30 <__register_exitproc+0x58>
 8006c62:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
 8006c66:	ea43 0200 	orr.w	r2, r3, r0
 8006c6a:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
 8006c6e:	e7df      	b.n	8006c30 <__register_exitproc+0x58>
 8006c70:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
 8006c74:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
 8006c78:	e7b8      	b.n	8006bec <__register_exitproc+0x14>
 8006c7a:	bf00      	nop
 8006c7c:	08006e04 	.word	0x08006e04
 8006c80:	00000000 	.word	0x00000000

08006c84 <__libc_fini_array>:
 8006c84:	4b11      	ldr	r3, [pc, #68]	; (8006ccc <__libc_fini_array+0x48>)
 8006c86:	4a12      	ldr	r2, [pc, #72]	; (8006cd0 <__libc_fini_array+0x4c>)
 8006c88:	b570      	push	{r4, r5, r6, lr}
 8006c8a:	1a98      	subs	r0, r3, r2
 8006c8c:	1083      	asrs	r3, r0, #2
 8006c8e:	d018      	beq.n	8006cc2 <__libc_fini_array+0x3e>
 8006c90:	1e59      	subs	r1, r3, #1
 8006c92:	eb02 0483 	add.w	r4, r2, r3, lsl #2
 8006c96:	460d      	mov	r5, r1
 8006c98:	f854 2d04 	ldr.w	r2, [r4, #-4]!
 8006c9c:	f001 0601 	and.w	r6, r1, #1
 8006ca0:	4790      	blx	r2
 8006ca2:	b175      	cbz	r5, 8006cc2 <__libc_fini_array+0x3e>
 8006ca4:	b126      	cbz	r6, 8006cb0 <__libc_fini_array+0x2c>
 8006ca6:	f854 0d04 	ldr.w	r0, [r4, #-4]!
 8006caa:	4780      	blx	r0
 8006cac:	3d01      	subs	r5, #1
 8006cae:	d008      	beq.n	8006cc2 <__libc_fini_array+0x3e>
 8006cb0:	f854 3d04 	ldr.w	r3, [r4, #-4]!
 8006cb4:	4798      	blx	r3
 8006cb6:	3d01      	subs	r5, #1
 8006cb8:	f854 1d04 	ldr.w	r1, [r4, #-4]!
 8006cbc:	4788      	blx	r1
 8006cbe:	3d01      	subs	r5, #1
 8006cc0:	d1f6      	bne.n	8006cb0 <__libc_fini_array+0x2c>
 8006cc2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8006cc6:	f000 b8b3 	b.w	8006e30 <_fini>
 8006cca:	bf00      	nop
 8006ccc:	08006e40 	.word	0x08006e40
 8006cd0:	08006e3c 	.word	0x08006e3c

08006cd4 <__libc_init_array>:
 8006cd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006cd6:	4f20      	ldr	r7, [pc, #128]	; (8006d58 <__libc_init_array+0x84>)
 8006cd8:	4c20      	ldr	r4, [pc, #128]	; (8006d5c <__libc_init_array+0x88>)
 8006cda:	1b38      	subs	r0, r7, r4
 8006cdc:	1087      	asrs	r7, r0, #2
 8006cde:	d017      	beq.n	8006d10 <__libc_init_array+0x3c>
 8006ce0:	1e7a      	subs	r2, r7, #1
 8006ce2:	6823      	ldr	r3, [r4, #0]
 8006ce4:	2501      	movs	r5, #1
 8006ce6:	f002 0601 	and.w	r6, r2, #1
 8006cea:	4798      	blx	r3
 8006cec:	42af      	cmp	r7, r5
 8006cee:	d00f      	beq.n	8006d10 <__libc_init_array+0x3c>
 8006cf0:	b12e      	cbz	r6, 8006cfe <__libc_init_array+0x2a>
 8006cf2:	f854 1f04 	ldr.w	r1, [r4, #4]!
 8006cf6:	2502      	movs	r5, #2
 8006cf8:	4788      	blx	r1
 8006cfa:	42af      	cmp	r7, r5
 8006cfc:	d008      	beq.n	8006d10 <__libc_init_array+0x3c>
 8006cfe:	6860      	ldr	r0, [r4, #4]
 8006d00:	4780      	blx	r0
 8006d02:	3502      	adds	r5, #2
 8006d04:	68a2      	ldr	r2, [r4, #8]
 8006d06:	1d26      	adds	r6, r4, #4
 8006d08:	4790      	blx	r2
 8006d0a:	3408      	adds	r4, #8
 8006d0c:	42af      	cmp	r7, r5
 8006d0e:	d1f6      	bne.n	8006cfe <__libc_init_array+0x2a>
 8006d10:	4f13      	ldr	r7, [pc, #76]	; (8006d60 <__libc_init_array+0x8c>)
 8006d12:	4c14      	ldr	r4, [pc, #80]	; (8006d64 <__libc_init_array+0x90>)
 8006d14:	f000 f882 	bl	8006e1c <_init>
 8006d18:	1b3b      	subs	r3, r7, r4
 8006d1a:	109f      	asrs	r7, r3, #2
 8006d1c:	d018      	beq.n	8006d50 <__libc_init_array+0x7c>
 8006d1e:	1e7d      	subs	r5, r7, #1
 8006d20:	6821      	ldr	r1, [r4, #0]
 8006d22:	f005 0601 	and.w	r6, r5, #1
 8006d26:	2501      	movs	r5, #1
 8006d28:	4788      	blx	r1
 8006d2a:	42af      	cmp	r7, r5
 8006d2c:	d011      	beq.n	8006d52 <__libc_init_array+0x7e>
 8006d2e:	b12e      	cbz	r6, 8006d3c <__libc_init_array+0x68>
 8006d30:	f854 0f04 	ldr.w	r0, [r4, #4]!
 8006d34:	2502      	movs	r5, #2
 8006d36:	4780      	blx	r0
 8006d38:	42af      	cmp	r7, r5
 8006d3a:	d00b      	beq.n	8006d54 <__libc_init_array+0x80>
 8006d3c:	6862      	ldr	r2, [r4, #4]
 8006d3e:	4790      	blx	r2
 8006d40:	3502      	adds	r5, #2
 8006d42:	68a3      	ldr	r3, [r4, #8]
 8006d44:	1d26      	adds	r6, r4, #4
 8006d46:	4798      	blx	r3
 8006d48:	3408      	adds	r4, #8
 8006d4a:	42af      	cmp	r7, r5
 8006d4c:	d1f6      	bne.n	8006d3c <__libc_init_array+0x68>
 8006d4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006d50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006d52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006d54:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006d56:	bf00      	nop
 8006d58:	08006e28 	.word	0x08006e28
 8006d5c:	08006e28 	.word	0x08006e28
 8006d60:	08006e30 	.word	0x08006e30
 8006d64:	08006e28 	.word	0x08006e28

08006d68 <register_fini>:
 8006d68:	4b02      	ldr	r3, [pc, #8]	; (8006d74 <register_fini+0xc>)
 8006d6a:	b113      	cbz	r3, 8006d72 <register_fini+0xa>
 8006d6c:	4802      	ldr	r0, [pc, #8]	; (8006d78 <register_fini+0x10>)
 8006d6e:	f000 b805 	b.w	8006d7c <atexit>
 8006d72:	4770      	bx	lr
 8006d74:	00000000 	.word	0x00000000
 8006d78:	08006c85 	.word	0x08006c85

08006d7c <atexit>:
 8006d7c:	4601      	mov	r1, r0
 8006d7e:	2000      	movs	r0, #0
 8006d80:	4602      	mov	r2, r0
 8006d82:	4603      	mov	r3, r0
 8006d84:	f7ff bf28 	b.w	8006bd8 <__register_exitproc>
 8006d88:	334d5453 	.word	0x334d5453
 8006d8c:	69562032 	.word	0x69562032
 8006d90:	61757472 	.word	0x61757472
 8006d94:	6f43206c 	.word	0x6f43206c
 8006d98:	726f506d 	.word	0x726f506d
 8006d9c:	00000074 	.word	0x00000074
 8006da0:	694d5453 	.word	0x694d5453
 8006da4:	656f7263 	.word	0x656f7263
 8006da8:	7463656c 	.word	0x7463656c
 8006dac:	696e6f72 	.word	0x696e6f72
 8006db0:	00007363 	.word	0x00007363
 8006db4:	30303030 	.word	0x30303030
 8006db8:	30303030 	.word	0x30303030
 8006dbc:	41313030 	.word	0x41313030
 8006dc0:	00000000 	.word	0x00000000
 8006dc4:	20434443 	.word	0x20434443
 8006dc8:	666e6f43 	.word	0x666e6f43
 8006dcc:	00006769 	.word	0x00006769
 8006dd0:	20434443 	.word	0x20434443
 8006dd4:	65746e49 	.word	0x65746e49
 8006dd8:	63616672 	.word	0x63616672
 8006ddc:	00000065 	.word	0x00000065

08006de0 <aAPBAHBPrescTable>:
 8006de0:	00000000 04030201 04030201 09080706     ................

08006df0 <aPLLDivisionFactorTable>:
 8006df0:	04030201                                ....

08006df4 <aPLLMulFactorTable>:
 8006df4:	08060403 2018100c 00000030 00000043     ....... 0...C...

08006e04 <_global_impure_ptr>:
 8006e04:	20000158                                X.. 

08006e08 <__data_array_start>:
 8006e08:	08006e40 	.word	0x08006e40
 8006e0c:	20000000 	.word	0x20000000
 8006e10:	20000580 	.word	0x20000580

08006e14 <__bss_array_start>:
 8006e14:	20000580 	.word	0x20000580
 8006e18:	20001f90 	.word	0x20001f90

08006e1c <_init>:
 8006e1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006e1e:	bf00      	nop
 8006e20:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8006e22:	bc08      	pop	{r3}
 8006e24:	469e      	mov	lr, r3
 8006e26:	4770      	bx	lr

08006e28 <__init_array_start>:
 8006e28:	08006d69 	.word	0x08006d69

08006e2c <__frame_dummy_init_array_entry>:
 8006e2c:	08000119                                ....

08006e30 <_fini>:
 8006e30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006e32:	bf00      	nop
 8006e34:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8006e36:	bc08      	pop	{r3}
 8006e38:	469e      	mov	lr, r3
 8006e3a:	4770      	bx	lr

08006e3c <__fini_array_start>:
 8006e3c:	080000f5 	.word	0x080000f5
