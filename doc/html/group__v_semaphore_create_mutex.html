<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>mg-stm32l_acquisition_supervisor: vSemaphoreCreateMutex</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">mg-stm32l_acquisition_supervisor
   &#160;<span id="projectnumber">0.1.0-120906</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">vSemaphoreCreateMutex</div>  </div>
</div><!--header-->
<div class="contents">
<p>semphr. h </p>
<pre>xSemaphoreHandle xSemaphoreCreateMutex( void )</pre><p><em>Macro</em> that implements a mutex semaphore by using the existing queue mechanism.</p>
<p>Mutexes created using this macro can be accessed using the xSemaphoreTake() and xSemaphoreGive() macros. The xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros should not be used.</p>
<p>This type of semaphore uses a priority inheritance mechanism so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer required.</p>
<p>Mutex type semaphores cannot be used from within interrupt service routines.</p>
<p>See vSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within interrupt service routines.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>xSemaphore Handle to the created mutex semaphore. Should be of type xSemaphoreHandle.</dd></dl>
<p>Example usage: </p>
<pre>
 xSemaphoreHandle xSemaphore;</pre><pre> void vATask( void * pvParameters )
 {
Semaphore cannot be used before a call to xSemaphoreCreateMutex().
This is a macro so pass the variable in directly.
    xSemaphore = xSemaphoreCreateMutex();</pre><pre>    if( xSemaphore != NULL )
    {
The semaphore was created successfully.
The semaphore can now be used.  
    }
 }
 </pre><p>semphr. h </p>
<pre>xSemaphoreHandle xSemaphoreCreateRecursiveMutex( void )</pre><p><em>Macro</em> that implements a recursive mutex by using the existing queue mechanism.</p>
<p>Mutexes created using this macro can be accessed using the xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros. The xSemaphoreTake() and xSemaphoreGive() macros should not be used.</p>
<p>A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request. For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also 'given' the mutex back exactly five times.</p>
<p>This type of semaphore uses a priority inheritance mechanism so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer required.</p>
<p>Mutex type semaphores cannot be used from within interrupt service routines.</p>
<p>See vSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within interrupt service routines.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>xSemaphore Handle to the created mutex semaphore. Should be of type xSemaphoreHandle.</dd></dl>
<p>Example usage: </p>
<pre>
 xSemaphoreHandle xSemaphore;</pre><pre> void vATask( void * pvParameters )
 {
Semaphore cannot be used before a call to xSemaphoreCreateMutex().
This is a macro so pass the variable in directly.
    xSemaphore = xSemaphoreCreateRecursiveMutex();</pre><pre>    if( xSemaphore != NULL )
    {
The semaphore was created successfully.
The semaphore can now be used.  
    }
 }
 </pre> </div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 6 2012 21:45:10 for mg-stm32l_acquisition_supervisor by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
